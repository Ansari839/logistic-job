
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model Branch
 * 
 */
export type Branch = $Result.DefaultSelection<Prisma.$BranchPayload>
/**
 * Model Currency
 * 
 */
export type Currency = $Result.DefaultSelection<Prisma.$CurrencyPayload>
/**
 * Model CompanyCurrency
 * 
 */
export type CompanyCurrency = $Result.DefaultSelection<Prisma.$CompanyCurrencyPayload>
/**
 * Model TaxSetting
 * 
 */
export type TaxSetting = $Result.DefaultSelection<Prisma.$TaxSettingPayload>
/**
 * Model SystemSetting
 * 
 */
export type SystemSetting = $Result.DefaultSelection<Prisma.$SystemSettingPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Vendor
 * 
 */
export type Vendor = $Result.DefaultSelection<Prisma.$VendorPayload>
/**
 * Model Job
 * 
 */
export type Job = $Result.DefaultSelection<Prisma.$JobPayload>
/**
 * Model ExpenseMaster
 * 
 */
export type ExpenseMaster = $Result.DefaultSelection<Prisma.$ExpenseMasterPayload>
/**
 * Model Expense
 * 
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>
/**
 * Model ServiceInvoice
 * 
 */
export type ServiceInvoice = $Result.DefaultSelection<Prisma.$ServiceInvoicePayload>
/**
 * Model ServiceInvoiceItem
 * 
 */
export type ServiceInvoiceItem = $Result.DefaultSelection<Prisma.$ServiceInvoiceItemPayload>
/**
 * Model FreightInvoice
 * 
 */
export type FreightInvoice = $Result.DefaultSelection<Prisma.$FreightInvoicePayload>
/**
 * Model FreightInvoiceItem
 * 
 */
export type FreightInvoiceItem = $Result.DefaultSelection<Prisma.$FreightInvoiceItemPayload>
/**
 * Model ProductCategory
 * 
 */
export type ProductCategory = $Result.DefaultSelection<Prisma.$ProductCategoryPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Warehouse
 * 
 */
export type Warehouse = $Result.DefaultSelection<Prisma.$WarehousePayload>
/**
 * Model StockMovement
 * 
 */
export type StockMovement = $Result.DefaultSelection<Prisma.$StockMovementPayload>
/**
 * Model PurchaseInvoice
 * 
 */
export type PurchaseInvoice = $Result.DefaultSelection<Prisma.$PurchaseInvoicePayload>
/**
 * Model PurchaseInvoiceItem
 * 
 */
export type PurchaseInvoiceItem = $Result.DefaultSelection<Prisma.$PurchaseInvoiceItemPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model AccountEntry
 * 
 */
export type AccountEntry = $Result.DefaultSelection<Prisma.$AccountEntryPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model FinancialPeriod
 * 
 */
export type FinancialPeriod = $Result.DefaultSelection<Prisma.$FinancialPeriodPayload>
/**
 * Model Port
 * 
 */
export type Port = $Result.DefaultSelection<Prisma.$PortPayload>
/**
 * Model Voucher
 * 
 */
export type Voucher = $Result.DefaultSelection<Prisma.$VoucherPayload>
/**
 * Model VoucherEntry
 * 
 */
export type VoucherEntry = $Result.DefaultSelection<Prisma.$VoucherEntryPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  OPERATOR: 'OPERATOR',
  ACCOUNTS: 'ACCOUNTS',
  SALES: 'SALES'
};

export type Role = (typeof Role)[keyof typeof Role]


export const JobType: {
  IMPORT: 'IMPORT',
  EXPORT: 'EXPORT'
};

export type JobType = (typeof JobType)[keyof typeof JobType]


export const InvoiceStatus: {
  DRAFT: 'DRAFT',
  SENT: 'SENT',
  PAID: 'PAID',
  CANCELLED: 'CANCELLED'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const InvoiceType: {
  MASTER: 'MASTER',
  PROFORMA: 'PROFORMA'
};

export type InvoiceType = (typeof InvoiceType)[keyof typeof InvoiceType]


export const AccountType: {
  ASSET: 'ASSET',
  LIABILITY: 'LIABILITY',
  EQUITY: 'EQUITY',
  REVENUE: 'REVENUE',
  EXPENSE: 'EXPENSE'
};

export type AccountType = (typeof AccountType)[keyof typeof AccountType]


export const VoucherType: {
  PAYMENT: 'PAYMENT',
  RECEIPT: 'RECEIPT',
  JOURNAL: 'JOURNAL',
  CONTRA: 'CONTRA'
};

export type VoucherType = (typeof VoucherType)[keyof typeof VoucherType]


export const VoucherStatus: {
  DRAFT: 'DRAFT',
  POSTED: 'POSTED',
  CANCELLED: 'CANCELLED'
};

export type VoucherStatus = (typeof VoucherStatus)[keyof typeof VoucherStatus]


export const TransactionType: {
  JOURNAL: 'JOURNAL',
  RECEIPT: 'RECEIPT',
  PAYMENT: 'PAYMENT',
  CONTRA: 'CONTRA',
  INVOICE: 'INVOICE',
  PURCHASE: 'PURCHASE'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const PaymentMode: {
  CASH: 'CASH',
  BANK: 'BANK',
  CHEQUE: 'CHEQUE',
  ONLINE: 'ONLINE'
};

export type PaymentMode = (typeof PaymentMode)[keyof typeof PaymentMode]


export const JobStatus: {
  DRAFT: 'DRAFT',
  IN_PROGRESS: 'IN_PROGRESS',
  CLOSED: 'CLOSED',
  CANCELLED: 'CANCELLED'
};

export type JobStatus = (typeof JobStatus)[keyof typeof JobStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type JobType = $Enums.JobType

export const JobType: typeof $Enums.JobType

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type InvoiceType = $Enums.InvoiceType

export const InvoiceType: typeof $Enums.InvoiceType

export type AccountType = $Enums.AccountType

export const AccountType: typeof $Enums.AccountType

export type VoucherType = $Enums.VoucherType

export const VoucherType: typeof $Enums.VoucherType

export type VoucherStatus = $Enums.VoucherStatus

export const VoucherStatus: typeof $Enums.VoucherStatus

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type PaymentMode = $Enums.PaymentMode

export const PaymentMode: typeof $Enums.PaymentMode

export type JobStatus = $Enums.JobStatus

export const JobStatus: typeof $Enums.JobStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Companies
 * const companies = await prisma.company.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Companies
   * const companies = await prisma.company.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.branch`: Exposes CRUD operations for the **Branch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branch.findMany()
    * ```
    */
  get branch(): Prisma.BranchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.currency`: Exposes CRUD operations for the **Currency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Currencies
    * const currencies = await prisma.currency.findMany()
    * ```
    */
  get currency(): Prisma.CurrencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyCurrency`: Exposes CRUD operations for the **CompanyCurrency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyCurrencies
    * const companyCurrencies = await prisma.companyCurrency.findMany()
    * ```
    */
  get companyCurrency(): Prisma.CompanyCurrencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taxSetting`: Exposes CRUD operations for the **TaxSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaxSettings
    * const taxSettings = await prisma.taxSetting.findMany()
    * ```
    */
  get taxSetting(): Prisma.TaxSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemSetting`: Exposes CRUD operations for the **SystemSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSetting.findMany()
    * ```
    */
  get systemSetting(): Prisma.SystemSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendor`: Exposes CRUD operations for the **Vendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendor.findMany()
    * ```
    */
  get vendor(): Prisma.VendorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job`: Exposes CRUD operations for the **Job** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.job.findMany()
    * ```
    */
  get job(): Prisma.JobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expenseMaster`: Exposes CRUD operations for the **ExpenseMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExpenseMasters
    * const expenseMasters = await prisma.expenseMaster.findMany()
    * ```
    */
  get expenseMaster(): Prisma.ExpenseMasterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceInvoice`: Exposes CRUD operations for the **ServiceInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceInvoices
    * const serviceInvoices = await prisma.serviceInvoice.findMany()
    * ```
    */
  get serviceInvoice(): Prisma.ServiceInvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceInvoiceItem`: Exposes CRUD operations for the **ServiceInvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceInvoiceItems
    * const serviceInvoiceItems = await prisma.serviceInvoiceItem.findMany()
    * ```
    */
  get serviceInvoiceItem(): Prisma.ServiceInvoiceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.freightInvoice`: Exposes CRUD operations for the **FreightInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FreightInvoices
    * const freightInvoices = await prisma.freightInvoice.findMany()
    * ```
    */
  get freightInvoice(): Prisma.FreightInvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.freightInvoiceItem`: Exposes CRUD operations for the **FreightInvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FreightInvoiceItems
    * const freightInvoiceItems = await prisma.freightInvoiceItem.findMany()
    * ```
    */
  get freightInvoiceItem(): Prisma.FreightInvoiceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productCategory`: Exposes CRUD operations for the **ProductCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCategories
    * const productCategories = await prisma.productCategory.findMany()
    * ```
    */
  get productCategory(): Prisma.ProductCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.warehouse`: Exposes CRUD operations for the **Warehouse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Warehouses
    * const warehouses = await prisma.warehouse.findMany()
    * ```
    */
  get warehouse(): Prisma.WarehouseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockMovement`: Exposes CRUD operations for the **StockMovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockMovements
    * const stockMovements = await prisma.stockMovement.findMany()
    * ```
    */
  get stockMovement(): Prisma.StockMovementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseInvoice`: Exposes CRUD operations for the **PurchaseInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseInvoices
    * const purchaseInvoices = await prisma.purchaseInvoice.findMany()
    * ```
    */
  get purchaseInvoice(): Prisma.PurchaseInvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseInvoiceItem`: Exposes CRUD operations for the **PurchaseInvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseInvoiceItems
    * const purchaseInvoiceItems = await prisma.purchaseInvoiceItem.findMany()
    * ```
    */
  get purchaseInvoiceItem(): Prisma.PurchaseInvoiceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accountEntry`: Exposes CRUD operations for the **AccountEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountEntries
    * const accountEntries = await prisma.accountEntry.findMany()
    * ```
    */
  get accountEntry(): Prisma.AccountEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.financialPeriod`: Exposes CRUD operations for the **FinancialPeriod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinancialPeriods
    * const financialPeriods = await prisma.financialPeriod.findMany()
    * ```
    */
  get financialPeriod(): Prisma.FinancialPeriodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.port`: Exposes CRUD operations for the **Port** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ports
    * const ports = await prisma.port.findMany()
    * ```
    */
  get port(): Prisma.PortDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.voucher`: Exposes CRUD operations for the **Voucher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vouchers
    * const vouchers = await prisma.voucher.findMany()
    * ```
    */
  get voucher(): Prisma.VoucherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.voucherEntry`: Exposes CRUD operations for the **VoucherEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VoucherEntries
    * const voucherEntries = await prisma.voucherEntry.findMany()
    * ```
    */
  get voucherEntry(): Prisma.VoucherEntryDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Company: 'Company',
    Branch: 'Branch',
    Currency: 'Currency',
    CompanyCurrency: 'CompanyCurrency',
    TaxSetting: 'TaxSetting',
    SystemSetting: 'SystemSetting',
    User: 'User',
    Customer: 'Customer',
    Vendor: 'Vendor',
    Job: 'Job',
    ExpenseMaster: 'ExpenseMaster',
    Expense: 'Expense',
    ServiceInvoice: 'ServiceInvoice',
    ServiceInvoiceItem: 'ServiceInvoiceItem',
    FreightInvoice: 'FreightInvoice',
    FreightInvoiceItem: 'FreightInvoiceItem',
    ProductCategory: 'ProductCategory',
    Product: 'Product',
    Warehouse: 'Warehouse',
    StockMovement: 'StockMovement',
    PurchaseInvoice: 'PurchaseInvoice',
    PurchaseInvoiceItem: 'PurchaseInvoiceItem',
    Account: 'Account',
    Transaction: 'Transaction',
    AccountEntry: 'AccountEntry',
    Payment: 'Payment',
    AuditLog: 'AuditLog',
    FinancialPeriod: 'FinancialPeriod',
    Port: 'Port',
    Voucher: 'Voucher',
    VoucherEntry: 'VoucherEntry'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "company" | "branch" | "currency" | "companyCurrency" | "taxSetting" | "systemSetting" | "user" | "customer" | "vendor" | "job" | "expenseMaster" | "expense" | "serviceInvoice" | "serviceInvoiceItem" | "freightInvoice" | "freightInvoiceItem" | "productCategory" | "product" | "warehouse" | "stockMovement" | "purchaseInvoice" | "purchaseInvoiceItem" | "account" | "transaction" | "accountEntry" | "payment" | "auditLog" | "financialPeriod" | "port" | "voucher" | "voucherEntry"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      Branch: {
        payload: Prisma.$BranchPayload<ExtArgs>
        fields: Prisma.BranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findFirst: {
            args: Prisma.BranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findMany: {
            args: Prisma.BranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          create: {
            args: Prisma.BranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          createMany: {
            args: Prisma.BranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          delete: {
            args: Prisma.BranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          update: {
            args: Prisma.BranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          deleteMany: {
            args: Prisma.BranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BranchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          upsert: {
            args: Prisma.BranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          aggregate: {
            args: Prisma.BranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranch>
          }
          groupBy: {
            args: Prisma.BranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchCountArgs<ExtArgs>
            result: $Utils.Optional<BranchCountAggregateOutputType> | number
          }
        }
      }
      Currency: {
        payload: Prisma.$CurrencyPayload<ExtArgs>
        fields: Prisma.CurrencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CurrencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CurrencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          findFirst: {
            args: Prisma.CurrencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CurrencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          findMany: {
            args: Prisma.CurrencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          create: {
            args: Prisma.CurrencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          createMany: {
            args: Prisma.CurrencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CurrencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          delete: {
            args: Prisma.CurrencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          update: {
            args: Prisma.CurrencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          deleteMany: {
            args: Prisma.CurrencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CurrencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CurrencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          upsert: {
            args: Prisma.CurrencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          aggregate: {
            args: Prisma.CurrencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurrency>
          }
          groupBy: {
            args: Prisma.CurrencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CurrencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CurrencyCountArgs<ExtArgs>
            result: $Utils.Optional<CurrencyCountAggregateOutputType> | number
          }
        }
      }
      CompanyCurrency: {
        payload: Prisma.$CompanyCurrencyPayload<ExtArgs>
        fields: Prisma.CompanyCurrencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyCurrencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyCurrencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyCurrencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyCurrencyPayload>
          }
          findFirst: {
            args: Prisma.CompanyCurrencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyCurrencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyCurrencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyCurrencyPayload>
          }
          findMany: {
            args: Prisma.CompanyCurrencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyCurrencyPayload>[]
          }
          create: {
            args: Prisma.CompanyCurrencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyCurrencyPayload>
          }
          createMany: {
            args: Prisma.CompanyCurrencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCurrencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyCurrencyPayload>[]
          }
          delete: {
            args: Prisma.CompanyCurrencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyCurrencyPayload>
          }
          update: {
            args: Prisma.CompanyCurrencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyCurrencyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyCurrencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyCurrencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyCurrencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyCurrencyPayload>[]
          }
          upsert: {
            args: Prisma.CompanyCurrencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyCurrencyPayload>
          }
          aggregate: {
            args: Prisma.CompanyCurrencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyCurrency>
          }
          groupBy: {
            args: Prisma.CompanyCurrencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyCurrencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCurrencyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCurrencyCountAggregateOutputType> | number
          }
        }
      }
      TaxSetting: {
        payload: Prisma.$TaxSettingPayload<ExtArgs>
        fields: Prisma.TaxSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaxSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaxSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSettingPayload>
          }
          findFirst: {
            args: Prisma.TaxSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaxSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSettingPayload>
          }
          findMany: {
            args: Prisma.TaxSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSettingPayload>[]
          }
          create: {
            args: Prisma.TaxSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSettingPayload>
          }
          createMany: {
            args: Prisma.TaxSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaxSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSettingPayload>[]
          }
          delete: {
            args: Prisma.TaxSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSettingPayload>
          }
          update: {
            args: Prisma.TaxSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSettingPayload>
          }
          deleteMany: {
            args: Prisma.TaxSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaxSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaxSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSettingPayload>[]
          }
          upsert: {
            args: Prisma.TaxSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSettingPayload>
          }
          aggregate: {
            args: Prisma.TaxSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaxSetting>
          }
          groupBy: {
            args: Prisma.TaxSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaxSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaxSettingCountArgs<ExtArgs>
            result: $Utils.Optional<TaxSettingCountAggregateOutputType> | number
          }
        }
      }
      SystemSetting: {
        payload: Prisma.$SystemSettingPayload<ExtArgs>
        fields: Prisma.SystemSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findMany: {
            args: Prisma.SystemSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          create: {
            args: Prisma.SystemSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          createMany: {
            args: Prisma.SystemSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          delete: {
            args: Prisma.SystemSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          update: {
            args: Prisma.SystemSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          upsert: {
            args: Prisma.SystemSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSetting>
          }
          groupBy: {
            args: Prisma.SystemSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Vendor: {
        payload: Prisma.$VendorPayload<ExtArgs>
        fields: Prisma.VendorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findFirst: {
            args: Prisma.VendorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findMany: {
            args: Prisma.VendorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          create: {
            args: Prisma.VendorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          createMany: {
            args: Prisma.VendorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          delete: {
            args: Prisma.VendorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          update: {
            args: Prisma.VendorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          deleteMany: {
            args: Prisma.VendorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          upsert: {
            args: Prisma.VendorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          aggregate: {
            args: Prisma.VendorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendor>
          }
          groupBy: {
            args: Prisma.VendorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorCountArgs<ExtArgs>
            result: $Utils.Optional<VendorCountAggregateOutputType> | number
          }
        }
      }
      Job: {
        payload: Prisma.$JobPayload<ExtArgs>
        fields: Prisma.JobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          findFirst: {
            args: Prisma.JobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          findMany: {
            args: Prisma.JobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          create: {
            args: Prisma.JobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          createMany: {
            args: Prisma.JobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          delete: {
            args: Prisma.JobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          update: {
            args: Prisma.JobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          deleteMany: {
            args: Prisma.JobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          upsert: {
            args: Prisma.JobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          aggregate: {
            args: Prisma.JobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob>
          }
          groupBy: {
            args: Prisma.JobGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobCountArgs<ExtArgs>
            result: $Utils.Optional<JobCountAggregateOutputType> | number
          }
        }
      }
      ExpenseMaster: {
        payload: Prisma.$ExpenseMasterPayload<ExtArgs>
        fields: Prisma.ExpenseMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseMasterPayload>
          }
          findFirst: {
            args: Prisma.ExpenseMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseMasterPayload>
          }
          findMany: {
            args: Prisma.ExpenseMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseMasterPayload>[]
          }
          create: {
            args: Prisma.ExpenseMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseMasterPayload>
          }
          createMany: {
            args: Prisma.ExpenseMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseMasterPayload>[]
          }
          delete: {
            args: Prisma.ExpenseMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseMasterPayload>
          }
          update: {
            args: Prisma.ExpenseMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseMasterPayload>
          }
          deleteMany: {
            args: Prisma.ExpenseMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpenseMasterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseMasterPayload>[]
          }
          upsert: {
            args: Prisma.ExpenseMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseMasterPayload>
          }
          aggregate: {
            args: Prisma.ExpenseMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpenseMaster>
          }
          groupBy: {
            args: Prisma.ExpenseMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseMasterCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseMasterCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          createMany: {
            args: Prisma.ExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpenseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      ServiceInvoice: {
        payload: Prisma.$ServiceInvoicePayload<ExtArgs>
        fields: Prisma.ServiceInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInvoicePayload>
          }
          findFirst: {
            args: Prisma.ServiceInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInvoicePayload>
          }
          findMany: {
            args: Prisma.ServiceInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInvoicePayload>[]
          }
          create: {
            args: Prisma.ServiceInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInvoicePayload>
          }
          createMany: {
            args: Prisma.ServiceInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceInvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInvoicePayload>[]
          }
          delete: {
            args: Prisma.ServiceInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInvoicePayload>
          }
          update: {
            args: Prisma.ServiceInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInvoicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceInvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInvoicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInvoicePayload>
          }
          aggregate: {
            args: Prisma.ServiceInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceInvoice>
          }
          groupBy: {
            args: Prisma.ServiceInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceInvoiceCountAggregateOutputType> | number
          }
        }
      }
      ServiceInvoiceItem: {
        payload: Prisma.$ServiceInvoiceItemPayload<ExtArgs>
        fields: Prisma.ServiceInvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceInvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceInvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.ServiceInvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceInvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInvoiceItemPayload>
          }
          findMany: {
            args: Prisma.ServiceInvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInvoiceItemPayload>[]
          }
          create: {
            args: Prisma.ServiceInvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInvoiceItemPayload>
          }
          createMany: {
            args: Prisma.ServiceInvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceInvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.ServiceInvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInvoiceItemPayload>
          }
          update: {
            args: Prisma.ServiceInvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.ServiceInvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceInvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceInvoiceItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInvoiceItemPayload>[]
          }
          upsert: {
            args: Prisma.ServiceInvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.ServiceInvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceInvoiceItem>
          }
          groupBy: {
            args: Prisma.ServiceInvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceInvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceInvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceInvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      FreightInvoice: {
        payload: Prisma.$FreightInvoicePayload<ExtArgs>
        fields: Prisma.FreightInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FreightInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreightInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FreightInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreightInvoicePayload>
          }
          findFirst: {
            args: Prisma.FreightInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreightInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FreightInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreightInvoicePayload>
          }
          findMany: {
            args: Prisma.FreightInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreightInvoicePayload>[]
          }
          create: {
            args: Prisma.FreightInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreightInvoicePayload>
          }
          createMany: {
            args: Prisma.FreightInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FreightInvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreightInvoicePayload>[]
          }
          delete: {
            args: Prisma.FreightInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreightInvoicePayload>
          }
          update: {
            args: Prisma.FreightInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreightInvoicePayload>
          }
          deleteMany: {
            args: Prisma.FreightInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FreightInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FreightInvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreightInvoicePayload>[]
          }
          upsert: {
            args: Prisma.FreightInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreightInvoicePayload>
          }
          aggregate: {
            args: Prisma.FreightInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFreightInvoice>
          }
          groupBy: {
            args: Prisma.FreightInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<FreightInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.FreightInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<FreightInvoiceCountAggregateOutputType> | number
          }
        }
      }
      FreightInvoiceItem: {
        payload: Prisma.$FreightInvoiceItemPayload<ExtArgs>
        fields: Prisma.FreightInvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FreightInvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreightInvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FreightInvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreightInvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.FreightInvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreightInvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FreightInvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreightInvoiceItemPayload>
          }
          findMany: {
            args: Prisma.FreightInvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreightInvoiceItemPayload>[]
          }
          create: {
            args: Prisma.FreightInvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreightInvoiceItemPayload>
          }
          createMany: {
            args: Prisma.FreightInvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FreightInvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreightInvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.FreightInvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreightInvoiceItemPayload>
          }
          update: {
            args: Prisma.FreightInvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreightInvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.FreightInvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FreightInvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FreightInvoiceItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreightInvoiceItemPayload>[]
          }
          upsert: {
            args: Prisma.FreightInvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreightInvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.FreightInvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFreightInvoiceItem>
          }
          groupBy: {
            args: Prisma.FreightInvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<FreightInvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.FreightInvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<FreightInvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      ProductCategory: {
        payload: Prisma.$ProductCategoryPayload<ExtArgs>
        fields: Prisma.ProductCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findFirst: {
            args: Prisma.ProductCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findMany: {
            args: Prisma.ProductCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          create: {
            args: Prisma.ProductCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          createMany: {
            args: Prisma.ProductCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          delete: {
            args: Prisma.ProductCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          update: {
            args: Prisma.ProductCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ProductCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          aggregate: {
            args: Prisma.ProductCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductCategory>
          }
          groupBy: {
            args: Prisma.ProductCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Warehouse: {
        payload: Prisma.$WarehousePayload<ExtArgs>
        fields: Prisma.WarehouseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehouseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehouseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          findFirst: {
            args: Prisma.WarehouseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehouseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          findMany: {
            args: Prisma.WarehouseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          create: {
            args: Prisma.WarehouseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          createMany: {
            args: Prisma.WarehouseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WarehouseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          delete: {
            args: Prisma.WarehouseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          update: {
            args: Prisma.WarehouseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          deleteMany: {
            args: Prisma.WarehouseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarehouseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WarehouseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          upsert: {
            args: Prisma.WarehouseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          aggregate: {
            args: Prisma.WarehouseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarehouse>
          }
          groupBy: {
            args: Prisma.WarehouseGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarehouseGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehouseCountArgs<ExtArgs>
            result: $Utils.Optional<WarehouseCountAggregateOutputType> | number
          }
        }
      }
      StockMovement: {
        payload: Prisma.$StockMovementPayload<ExtArgs>
        fields: Prisma.StockMovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockMovementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockMovementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          findFirst: {
            args: Prisma.StockMovementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockMovementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          findMany: {
            args: Prisma.StockMovementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>[]
          }
          create: {
            args: Prisma.StockMovementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          createMany: {
            args: Prisma.StockMovementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockMovementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>[]
          }
          delete: {
            args: Prisma.StockMovementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          update: {
            args: Prisma.StockMovementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          deleteMany: {
            args: Prisma.StockMovementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockMovementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockMovementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>[]
          }
          upsert: {
            args: Prisma.StockMovementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          aggregate: {
            args: Prisma.StockMovementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockMovement>
          }
          groupBy: {
            args: Prisma.StockMovementGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockMovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockMovementCountArgs<ExtArgs>
            result: $Utils.Optional<StockMovementCountAggregateOutputType> | number
          }
        }
      }
      PurchaseInvoice: {
        payload: Prisma.$PurchaseInvoicePayload<ExtArgs>
        fields: Prisma.PurchaseInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          findFirst: {
            args: Prisma.PurchaseInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          findMany: {
            args: Prisma.PurchaseInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>[]
          }
          create: {
            args: Prisma.PurchaseInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          createMany: {
            args: Prisma.PurchaseInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseInvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>[]
          }
          delete: {
            args: Prisma.PurchaseInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          update: {
            args: Prisma.PurchaseInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseInvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>[]
          }
          upsert: {
            args: Prisma.PurchaseInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          aggregate: {
            args: Prisma.PurchaseInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseInvoice>
          }
          groupBy: {
            args: Prisma.PurchaseInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseInvoiceCountAggregateOutputType> | number
          }
        }
      }
      PurchaseInvoiceItem: {
        payload: Prisma.$PurchaseInvoiceItemPayload<ExtArgs>
        fields: Prisma.PurchaseInvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseInvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseInvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.PurchaseInvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseInvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>
          }
          findMany: {
            args: Prisma.PurchaseInvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>[]
          }
          create: {
            args: Prisma.PurchaseInvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>
          }
          createMany: {
            args: Prisma.PurchaseInvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseInvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.PurchaseInvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>
          }
          update: {
            args: Prisma.PurchaseInvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseInvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseInvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseInvoiceItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseInvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.PurchaseInvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseInvoiceItem>
          }
          groupBy: {
            args: Prisma.PurchaseInvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseInvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseInvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseInvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      AccountEntry: {
        payload: Prisma.$AccountEntryPayload<ExtArgs>
        fields: Prisma.AccountEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountEntryPayload>
          }
          findFirst: {
            args: Prisma.AccountEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountEntryPayload>
          }
          findMany: {
            args: Prisma.AccountEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountEntryPayload>[]
          }
          create: {
            args: Prisma.AccountEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountEntryPayload>
          }
          createMany: {
            args: Prisma.AccountEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountEntryPayload>[]
          }
          delete: {
            args: Prisma.AccountEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountEntryPayload>
          }
          update: {
            args: Prisma.AccountEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountEntryPayload>
          }
          deleteMany: {
            args: Prisma.AccountEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountEntryPayload>[]
          }
          upsert: {
            args: Prisma.AccountEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountEntryPayload>
          }
          aggregate: {
            args: Prisma.AccountEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountEntry>
          }
          groupBy: {
            args: Prisma.AccountEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountEntryCountArgs<ExtArgs>
            result: $Utils.Optional<AccountEntryCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      FinancialPeriod: {
        payload: Prisma.$FinancialPeriodPayload<ExtArgs>
        fields: Prisma.FinancialPeriodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinancialPeriodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialPeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinancialPeriodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialPeriodPayload>
          }
          findFirst: {
            args: Prisma.FinancialPeriodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialPeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinancialPeriodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialPeriodPayload>
          }
          findMany: {
            args: Prisma.FinancialPeriodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialPeriodPayload>[]
          }
          create: {
            args: Prisma.FinancialPeriodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialPeriodPayload>
          }
          createMany: {
            args: Prisma.FinancialPeriodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinancialPeriodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialPeriodPayload>[]
          }
          delete: {
            args: Prisma.FinancialPeriodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialPeriodPayload>
          }
          update: {
            args: Prisma.FinancialPeriodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialPeriodPayload>
          }
          deleteMany: {
            args: Prisma.FinancialPeriodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinancialPeriodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FinancialPeriodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialPeriodPayload>[]
          }
          upsert: {
            args: Prisma.FinancialPeriodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialPeriodPayload>
          }
          aggregate: {
            args: Prisma.FinancialPeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinancialPeriod>
          }
          groupBy: {
            args: Prisma.FinancialPeriodGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinancialPeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinancialPeriodCountArgs<ExtArgs>
            result: $Utils.Optional<FinancialPeriodCountAggregateOutputType> | number
          }
        }
      }
      Port: {
        payload: Prisma.$PortPayload<ExtArgs>
        fields: Prisma.PortFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PortFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PortFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortPayload>
          }
          findFirst: {
            args: Prisma.PortFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PortFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortPayload>
          }
          findMany: {
            args: Prisma.PortFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortPayload>[]
          }
          create: {
            args: Prisma.PortCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortPayload>
          }
          createMany: {
            args: Prisma.PortCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PortCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortPayload>[]
          }
          delete: {
            args: Prisma.PortDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortPayload>
          }
          update: {
            args: Prisma.PortUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortPayload>
          }
          deleteMany: {
            args: Prisma.PortDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PortUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PortUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortPayload>[]
          }
          upsert: {
            args: Prisma.PortUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortPayload>
          }
          aggregate: {
            args: Prisma.PortAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePort>
          }
          groupBy: {
            args: Prisma.PortGroupByArgs<ExtArgs>
            result: $Utils.Optional<PortGroupByOutputType>[]
          }
          count: {
            args: Prisma.PortCountArgs<ExtArgs>
            result: $Utils.Optional<PortCountAggregateOutputType> | number
          }
        }
      }
      Voucher: {
        payload: Prisma.$VoucherPayload<ExtArgs>
        fields: Prisma.VoucherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoucherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoucherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          findFirst: {
            args: Prisma.VoucherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoucherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          findMany: {
            args: Prisma.VoucherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>[]
          }
          create: {
            args: Prisma.VoucherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          createMany: {
            args: Prisma.VoucherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoucherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>[]
          }
          delete: {
            args: Prisma.VoucherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          update: {
            args: Prisma.VoucherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          deleteMany: {
            args: Prisma.VoucherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoucherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VoucherUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>[]
          }
          upsert: {
            args: Prisma.VoucherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          aggregate: {
            args: Prisma.VoucherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoucher>
          }
          groupBy: {
            args: Prisma.VoucherGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoucherGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoucherCountArgs<ExtArgs>
            result: $Utils.Optional<VoucherCountAggregateOutputType> | number
          }
        }
      }
      VoucherEntry: {
        payload: Prisma.$VoucherEntryPayload<ExtArgs>
        fields: Prisma.VoucherEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoucherEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoucherEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherEntryPayload>
          }
          findFirst: {
            args: Prisma.VoucherEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoucherEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherEntryPayload>
          }
          findMany: {
            args: Prisma.VoucherEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherEntryPayload>[]
          }
          create: {
            args: Prisma.VoucherEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherEntryPayload>
          }
          createMany: {
            args: Prisma.VoucherEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoucherEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherEntryPayload>[]
          }
          delete: {
            args: Prisma.VoucherEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherEntryPayload>
          }
          update: {
            args: Prisma.VoucherEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherEntryPayload>
          }
          deleteMany: {
            args: Prisma.VoucherEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoucherEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VoucherEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherEntryPayload>[]
          }
          upsert: {
            args: Prisma.VoucherEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherEntryPayload>
          }
          aggregate: {
            args: Prisma.VoucherEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoucherEntry>
          }
          groupBy: {
            args: Prisma.VoucherEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoucherEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoucherEntryCountArgs<ExtArgs>
            result: $Utils.Optional<VoucherEntryCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    company?: CompanyOmit
    branch?: BranchOmit
    currency?: CurrencyOmit
    companyCurrency?: CompanyCurrencyOmit
    taxSetting?: TaxSettingOmit
    systemSetting?: SystemSettingOmit
    user?: UserOmit
    customer?: CustomerOmit
    vendor?: VendorOmit
    job?: JobOmit
    expenseMaster?: ExpenseMasterOmit
    expense?: ExpenseOmit
    serviceInvoice?: ServiceInvoiceOmit
    serviceInvoiceItem?: ServiceInvoiceItemOmit
    freightInvoice?: FreightInvoiceOmit
    freightInvoiceItem?: FreightInvoiceItemOmit
    productCategory?: ProductCategoryOmit
    product?: ProductOmit
    warehouse?: WarehouseOmit
    stockMovement?: StockMovementOmit
    purchaseInvoice?: PurchaseInvoiceOmit
    purchaseInvoiceItem?: PurchaseInvoiceItemOmit
    account?: AccountOmit
    transaction?: TransactionOmit
    accountEntry?: AccountEntryOmit
    payment?: PaymentOmit
    auditLog?: AuditLogOmit
    financialPeriod?: FinancialPeriodOmit
    port?: PortOmit
    voucher?: VoucherOmit
    voucherEntry?: VoucherEntryOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    accounts: number
    auditLogs: number
    branches: number
    currencies: number
    customers: number
    expenses: number
    expensesMaster: number
    financialPeriods: number
    serviceInvoices: number
    freightInvoices: number
    jobs: number
    payments: number
    ports: number
    products: number
    productCategories: number
    purchaseInvoices: number
    stockMovements: number
    systemSettings: number
    taxSettings: number
    transactions: number
    users: number
    vendors: number
    vouchers: number
    warehouses: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | CompanyCountOutputTypeCountAccountsArgs
    auditLogs?: boolean | CompanyCountOutputTypeCountAuditLogsArgs
    branches?: boolean | CompanyCountOutputTypeCountBranchesArgs
    currencies?: boolean | CompanyCountOutputTypeCountCurrenciesArgs
    customers?: boolean | CompanyCountOutputTypeCountCustomersArgs
    expenses?: boolean | CompanyCountOutputTypeCountExpensesArgs
    expensesMaster?: boolean | CompanyCountOutputTypeCountExpensesMasterArgs
    financialPeriods?: boolean | CompanyCountOutputTypeCountFinancialPeriodsArgs
    serviceInvoices?: boolean | CompanyCountOutputTypeCountServiceInvoicesArgs
    freightInvoices?: boolean | CompanyCountOutputTypeCountFreightInvoicesArgs
    jobs?: boolean | CompanyCountOutputTypeCountJobsArgs
    payments?: boolean | CompanyCountOutputTypeCountPaymentsArgs
    ports?: boolean | CompanyCountOutputTypeCountPortsArgs
    products?: boolean | CompanyCountOutputTypeCountProductsArgs
    productCategories?: boolean | CompanyCountOutputTypeCountProductCategoriesArgs
    purchaseInvoices?: boolean | CompanyCountOutputTypeCountPurchaseInvoicesArgs
    stockMovements?: boolean | CompanyCountOutputTypeCountStockMovementsArgs
    systemSettings?: boolean | CompanyCountOutputTypeCountSystemSettingsArgs
    taxSettings?: boolean | CompanyCountOutputTypeCountTaxSettingsArgs
    transactions?: boolean | CompanyCountOutputTypeCountTransactionsArgs
    users?: boolean | CompanyCountOutputTypeCountUsersArgs
    vendors?: boolean | CompanyCountOutputTypeCountVendorsArgs
    vouchers?: boolean | CompanyCountOutputTypeCountVouchersArgs
    warehouses?: boolean | CompanyCountOutputTypeCountWarehousesArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCurrenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyCurrencyWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountExpensesMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseMasterWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountFinancialPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialPeriodWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountServiceInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceInvoiceWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountFreightInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FreightInvoiceWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPortsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountProductCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPurchaseInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountStockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountSystemSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountTaxSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxSettingWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountVendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountWarehousesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseWhereInput
  }


  /**
   * Count Type BranchCountOutputType
   */

  export type BranchCountOutputType = {
    jobs: number
    taxSettings: number
  }

  export type BranchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | BranchCountOutputTypeCountJobsArgs
    taxSettings?: boolean | BranchCountOutputTypeCountTaxSettingsArgs
  }

  // Custom InputTypes
  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchCountOutputType
     */
    select?: BranchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountTaxSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxSettingWhereInput
  }


  /**
   * Count Type CurrencyCountOutputType
   */

  export type CurrencyCountOutputType = {
    companies: number
  }

  export type CurrencyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | CurrencyCountOutputTypeCountCompaniesArgs
  }

  // Custom InputTypes
  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyCountOutputType
     */
    select?: CurrencyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyCurrencyWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    auditLogs: number
    postedVouchers: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    postedVouchers?: boolean | UserCountOutputTypeCountPostedVouchersArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostedVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    serviceInvoices: number
    freightInvoices: number
    jobs: number
    payments: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceInvoices?: boolean | CustomerCountOutputTypeCountServiceInvoicesArgs
    freightInvoices?: boolean | CustomerCountOutputTypeCountFreightInvoicesArgs
    jobs?: boolean | CustomerCountOutputTypeCountJobsArgs
    payments?: boolean | CustomerCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountServiceInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceInvoiceWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountFreightInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FreightInvoiceWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type VendorCountOutputType
   */

  export type VendorCountOutputType = {
    expenses: number
    payments: number
    purchaseInvoices: number
    freightItems: number
  }

  export type VendorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expenses?: boolean | VendorCountOutputTypeCountExpensesArgs
    payments?: boolean | VendorCountOutputTypeCountPaymentsArgs
    purchaseInvoices?: boolean | VendorCountOutputTypeCountPurchaseInvoicesArgs
    freightItems?: boolean | VendorCountOutputTypeCountFreightItemsArgs
  }

  // Custom InputTypes
  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCountOutputType
     */
    select?: VendorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountPurchaseInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountFreightItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FreightInvoiceItemWhereInput
  }


  /**
   * Count Type JobCountOutputType
   */

  export type JobCountOutputType = {
    expenses: number
  }

  export type JobCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expenses?: boolean | JobCountOutputTypeCountExpensesArgs
  }

  // Custom InputTypes
  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobCountOutputType
     */
    select?: JobCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }


  /**
   * Count Type ServiceInvoiceCountOutputType
   */

  export type ServiceInvoiceCountOutputType = {
    items: number
  }

  export type ServiceInvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ServiceInvoiceCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * ServiceInvoiceCountOutputType without action
   */
  export type ServiceInvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoiceCountOutputType
     */
    select?: ServiceInvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceInvoiceCountOutputType without action
   */
  export type ServiceInvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceInvoiceItemWhereInput
  }


  /**
   * Count Type FreightInvoiceCountOutputType
   */

  export type FreightInvoiceCountOutputType = {
    items: number
  }

  export type FreightInvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | FreightInvoiceCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * FreightInvoiceCountOutputType without action
   */
  export type FreightInvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoiceCountOutputType
     */
    select?: FreightInvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FreightInvoiceCountOutputType without action
   */
  export type FreightInvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FreightInvoiceItemWhereInput
  }


  /**
   * Count Type ProductCategoryCountOutputType
   */

  export type ProductCategoryCountOutputType = {
    products: number
  }

  export type ProductCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | ProductCategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategoryCountOutputType
     */
    select?: ProductCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    serviceItems: number
    purchaseItems: number
    movements: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceItems?: boolean | ProductCountOutputTypeCountServiceItemsArgs
    purchaseItems?: boolean | ProductCountOutputTypeCountPurchaseItemsArgs
    movements?: boolean | ProductCountOutputTypeCountMovementsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountServiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceInvoiceItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPurchaseItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
  }


  /**
   * Count Type WarehouseCountOutputType
   */

  export type WarehouseCountOutputType = {
    stockMovements: number
  }

  export type WarehouseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockMovements?: boolean | WarehouseCountOutputTypeCountStockMovementsArgs
  }

  // Custom InputTypes
  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseCountOutputType
     */
    select?: WarehouseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountStockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
  }


  /**
   * Count Type PurchaseInvoiceCountOutputType
   */

  export type PurchaseInvoiceCountOutputType = {
    items: number
  }

  export type PurchaseInvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PurchaseInvoiceCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseInvoiceCountOutputType without action
   */
  export type PurchaseInvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceCountOutputType
     */
    select?: PurchaseInvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseInvoiceCountOutputType without action
   */
  export type PurchaseInvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceItemWhereInput
  }


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    children: number
    entries: number
    voucherEntries: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | AccountCountOutputTypeCountChildrenArgs
    entries?: boolean | AccountCountOutputTypeCountEntriesArgs
    voucherEntries?: boolean | AccountCountOutputTypeCountVoucherEntriesArgs
  }

  // Custom InputTypes
  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountEntryWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountVoucherEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherEntryWhereInput
  }


  /**
   * Count Type TransactionCountOutputType
   */

  export type TransactionCountOutputType = {
    entries: number
  }

  export type TransactionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | TransactionCountOutputTypeCountEntriesArgs
  }

  // Custom InputTypes
  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCountOutputType
     */
    select?: TransactionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountEntryWhereInput
  }


  /**
   * Count Type PortCountOutputType
   */

  export type PortCountOutputType = {
    jobs: number
  }

  export type PortCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | PortCountOutputTypeCountJobsArgs
  }

  // Custom InputTypes
  /**
   * PortCountOutputType without action
   */
  export type PortCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortCountOutputType
     */
    select?: PortCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PortCountOutputType without action
   */
  export type PortCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
  }


  /**
   * Count Type VoucherCountOutputType
   */

  export type VoucherCountOutputType = {
    entries: number
  }

  export type VoucherCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | VoucherCountOutputTypeCountEntriesArgs
  }

  // Custom InputTypes
  /**
   * VoucherCountOutputType without action
   */
  export type VoucherCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherCountOutputType
     */
    select?: VoucherCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VoucherCountOutputType without action
   */
  export type VoucherCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherEntryWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    id: number | null
  }

  export type CompanySumAggregateOutputType = {
    id: number | null
  }

  export type CompanyMinAggregateOutputType = {
    id: number | null
    name: string | null
    uniqueId: string | null
    address: string | null
    phone: string | null
    email: string | null
    industry: string | null
    logo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    city: string | null
    country: string | null
    fiscalYearEnd: Date | null
    fiscalYearStart: Date | null
    postalCode: string | null
    registrationNo: string | null
    state: string | null
    tagline: string | null
    taxNumber: string | null
    website: string | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: number | null
    name: string | null
    uniqueId: string | null
    address: string | null
    phone: string | null
    email: string | null
    industry: string | null
    logo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    city: string | null
    country: string | null
    fiscalYearEnd: Date | null
    fiscalYearStart: Date | null
    postalCode: string | null
    registrationNo: string | null
    state: string | null
    tagline: string | null
    taxNumber: string | null
    website: string | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    uniqueId: number
    address: number
    phone: number
    email: number
    industry: number
    logo: number
    themeConfig: number
    createdAt: number
    updatedAt: number
    city: number
    country: number
    fiscalYearEnd: number
    fiscalYearStart: number
    postalCode: number
    registrationNo: number
    state: number
    tagline: number
    taxNumber: number
    website: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    id?: true
  }

  export type CompanySumAggregateInputType = {
    id?: true
  }

  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    uniqueId?: true
    address?: true
    phone?: true
    email?: true
    industry?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
    city?: true
    country?: true
    fiscalYearEnd?: true
    fiscalYearStart?: true
    postalCode?: true
    registrationNo?: true
    state?: true
    tagline?: true
    taxNumber?: true
    website?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    uniqueId?: true
    address?: true
    phone?: true
    email?: true
    industry?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
    city?: true
    country?: true
    fiscalYearEnd?: true
    fiscalYearStart?: true
    postalCode?: true
    registrationNo?: true
    state?: true
    tagline?: true
    taxNumber?: true
    website?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    uniqueId?: true
    address?: true
    phone?: true
    email?: true
    industry?: true
    logo?: true
    themeConfig?: true
    createdAt?: true
    updatedAt?: true
    city?: true
    country?: true
    fiscalYearEnd?: true
    fiscalYearStart?: true
    postalCode?: true
    registrationNo?: true
    state?: true
    tagline?: true
    taxNumber?: true
    website?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: number
    name: string
    uniqueId: string
    address: string | null
    phone: string | null
    email: string | null
    industry: string | null
    logo: string | null
    themeConfig: JsonValue | null
    createdAt: Date
    updatedAt: Date
    city: string | null
    country: string | null
    fiscalYearEnd: Date | null
    fiscalYearStart: Date | null
    postalCode: string | null
    registrationNo: string | null
    state: string | null
    tagline: string | null
    taxNumber: string | null
    website: string | null
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    uniqueId?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    industry?: boolean
    logo?: boolean
    themeConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean
    country?: boolean
    fiscalYearEnd?: boolean
    fiscalYearStart?: boolean
    postalCode?: boolean
    registrationNo?: boolean
    state?: boolean
    tagline?: boolean
    taxNumber?: boolean
    website?: boolean
    accounts?: boolean | Company$accountsArgs<ExtArgs>
    auditLogs?: boolean | Company$auditLogsArgs<ExtArgs>
    branches?: boolean | Company$branchesArgs<ExtArgs>
    currencies?: boolean | Company$currenciesArgs<ExtArgs>
    customers?: boolean | Company$customersArgs<ExtArgs>
    expenses?: boolean | Company$expensesArgs<ExtArgs>
    expensesMaster?: boolean | Company$expensesMasterArgs<ExtArgs>
    financialPeriods?: boolean | Company$financialPeriodsArgs<ExtArgs>
    serviceInvoices?: boolean | Company$serviceInvoicesArgs<ExtArgs>
    freightInvoices?: boolean | Company$freightInvoicesArgs<ExtArgs>
    jobs?: boolean | Company$jobsArgs<ExtArgs>
    payments?: boolean | Company$paymentsArgs<ExtArgs>
    ports?: boolean | Company$portsArgs<ExtArgs>
    products?: boolean | Company$productsArgs<ExtArgs>
    productCategories?: boolean | Company$productCategoriesArgs<ExtArgs>
    purchaseInvoices?: boolean | Company$purchaseInvoicesArgs<ExtArgs>
    stockMovements?: boolean | Company$stockMovementsArgs<ExtArgs>
    systemSettings?: boolean | Company$systemSettingsArgs<ExtArgs>
    taxSettings?: boolean | Company$taxSettingsArgs<ExtArgs>
    transactions?: boolean | Company$transactionsArgs<ExtArgs>
    users?: boolean | Company$usersArgs<ExtArgs>
    vendors?: boolean | Company$vendorsArgs<ExtArgs>
    vouchers?: boolean | Company$vouchersArgs<ExtArgs>
    warehouses?: boolean | Company$warehousesArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    uniqueId?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    industry?: boolean
    logo?: boolean
    themeConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean
    country?: boolean
    fiscalYearEnd?: boolean
    fiscalYearStart?: boolean
    postalCode?: boolean
    registrationNo?: boolean
    state?: boolean
    tagline?: boolean
    taxNumber?: boolean
    website?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    uniqueId?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    industry?: boolean
    logo?: boolean
    themeConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean
    country?: boolean
    fiscalYearEnd?: boolean
    fiscalYearStart?: boolean
    postalCode?: boolean
    registrationNo?: boolean
    state?: boolean
    tagline?: boolean
    taxNumber?: boolean
    website?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    uniqueId?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    industry?: boolean
    logo?: boolean
    themeConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean
    country?: boolean
    fiscalYearEnd?: boolean
    fiscalYearStart?: boolean
    postalCode?: boolean
    registrationNo?: boolean
    state?: boolean
    tagline?: boolean
    taxNumber?: boolean
    website?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "uniqueId" | "address" | "phone" | "email" | "industry" | "logo" | "themeConfig" | "createdAt" | "updatedAt" | "city" | "country" | "fiscalYearEnd" | "fiscalYearStart" | "postalCode" | "registrationNo" | "state" | "tagline" | "taxNumber" | "website", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | Company$accountsArgs<ExtArgs>
    auditLogs?: boolean | Company$auditLogsArgs<ExtArgs>
    branches?: boolean | Company$branchesArgs<ExtArgs>
    currencies?: boolean | Company$currenciesArgs<ExtArgs>
    customers?: boolean | Company$customersArgs<ExtArgs>
    expenses?: boolean | Company$expensesArgs<ExtArgs>
    expensesMaster?: boolean | Company$expensesMasterArgs<ExtArgs>
    financialPeriods?: boolean | Company$financialPeriodsArgs<ExtArgs>
    serviceInvoices?: boolean | Company$serviceInvoicesArgs<ExtArgs>
    freightInvoices?: boolean | Company$freightInvoicesArgs<ExtArgs>
    jobs?: boolean | Company$jobsArgs<ExtArgs>
    payments?: boolean | Company$paymentsArgs<ExtArgs>
    ports?: boolean | Company$portsArgs<ExtArgs>
    products?: boolean | Company$productsArgs<ExtArgs>
    productCategories?: boolean | Company$productCategoriesArgs<ExtArgs>
    purchaseInvoices?: boolean | Company$purchaseInvoicesArgs<ExtArgs>
    stockMovements?: boolean | Company$stockMovementsArgs<ExtArgs>
    systemSettings?: boolean | Company$systemSettingsArgs<ExtArgs>
    taxSettings?: boolean | Company$taxSettingsArgs<ExtArgs>
    transactions?: boolean | Company$transactionsArgs<ExtArgs>
    users?: boolean | Company$usersArgs<ExtArgs>
    vendors?: boolean | Company$vendorsArgs<ExtArgs>
    vouchers?: boolean | Company$vouchersArgs<ExtArgs>
    warehouses?: boolean | Company$warehousesArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      branches: Prisma.$BranchPayload<ExtArgs>[]
      currencies: Prisma.$CompanyCurrencyPayload<ExtArgs>[]
      customers: Prisma.$CustomerPayload<ExtArgs>[]
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      expensesMaster: Prisma.$ExpenseMasterPayload<ExtArgs>[]
      financialPeriods: Prisma.$FinancialPeriodPayload<ExtArgs>[]
      serviceInvoices: Prisma.$ServiceInvoicePayload<ExtArgs>[]
      freightInvoices: Prisma.$FreightInvoicePayload<ExtArgs>[]
      jobs: Prisma.$JobPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      ports: Prisma.$PortPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      productCategories: Prisma.$ProductCategoryPayload<ExtArgs>[]
      purchaseInvoices: Prisma.$PurchaseInvoicePayload<ExtArgs>[]
      stockMovements: Prisma.$StockMovementPayload<ExtArgs>[]
      systemSettings: Prisma.$SystemSettingPayload<ExtArgs>[]
      taxSettings: Prisma.$TaxSettingPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      vendors: Prisma.$VendorPayload<ExtArgs>[]
      vouchers: Prisma.$VoucherPayload<ExtArgs>[]
      warehouses: Prisma.$WarehousePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      uniqueId: string
      address: string | null
      phone: string | null
      email: string | null
      industry: string | null
      logo: string | null
      themeConfig: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      city: string | null
      country: string | null
      fiscalYearEnd: Date | null
      fiscalYearStart: Date | null
      postalCode: string | null
      registrationNo: string | null
      state: string | null
      tagline: string | null
      taxNumber: string | null
      website: string | null
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends Company$accountsArgs<ExtArgs> = {}>(args?: Subset<T, Company$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends Company$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Company$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    branches<T extends Company$branchesArgs<ExtArgs> = {}>(args?: Subset<T, Company$branchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    currencies<T extends Company$currenciesArgs<ExtArgs> = {}>(args?: Subset<T, Company$currenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyCurrencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customers<T extends Company$customersArgs<ExtArgs> = {}>(args?: Subset<T, Company$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    expenses<T extends Company$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Company$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    expensesMaster<T extends Company$expensesMasterArgs<ExtArgs> = {}>(args?: Subset<T, Company$expensesMasterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseMasterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    financialPeriods<T extends Company$financialPeriodsArgs<ExtArgs> = {}>(args?: Subset<T, Company$financialPeriodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceInvoices<T extends Company$serviceInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Company$serviceInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    freightInvoices<T extends Company$freightInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Company$freightInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreightInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jobs<T extends Company$jobsArgs<ExtArgs> = {}>(args?: Subset<T, Company$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Company$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Company$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ports<T extends Company$portsArgs<ExtArgs> = {}>(args?: Subset<T, Company$portsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends Company$productsArgs<ExtArgs> = {}>(args?: Subset<T, Company$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productCategories<T extends Company$productCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Company$productCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseInvoices<T extends Company$purchaseInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Company$purchaseInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockMovements<T extends Company$stockMovementsArgs<ExtArgs> = {}>(args?: Subset<T, Company$stockMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    systemSettings<T extends Company$systemSettingsArgs<ExtArgs> = {}>(args?: Subset<T, Company$systemSettingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taxSettings<T extends Company$taxSettingsArgs<ExtArgs> = {}>(args?: Subset<T, Company$taxSettingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends Company$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Company$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Company$usersArgs<ExtArgs> = {}>(args?: Subset<T, Company$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vendors<T extends Company$vendorsArgs<ExtArgs> = {}>(args?: Subset<T, Company$vendorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vouchers<T extends Company$vouchersArgs<ExtArgs> = {}>(args?: Subset<T, Company$vouchersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    warehouses<T extends Company$warehousesArgs<ExtArgs> = {}>(args?: Subset<T, Company$warehousesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'Int'>
    readonly name: FieldRef<"Company", 'String'>
    readonly uniqueId: FieldRef<"Company", 'String'>
    readonly address: FieldRef<"Company", 'String'>
    readonly phone: FieldRef<"Company", 'String'>
    readonly email: FieldRef<"Company", 'String'>
    readonly industry: FieldRef<"Company", 'String'>
    readonly logo: FieldRef<"Company", 'String'>
    readonly themeConfig: FieldRef<"Company", 'Json'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
    readonly city: FieldRef<"Company", 'String'>
    readonly country: FieldRef<"Company", 'String'>
    readonly fiscalYearEnd: FieldRef<"Company", 'DateTime'>
    readonly fiscalYearStart: FieldRef<"Company", 'DateTime'>
    readonly postalCode: FieldRef<"Company", 'String'>
    readonly registrationNo: FieldRef<"Company", 'String'>
    readonly state: FieldRef<"Company", 'String'>
    readonly tagline: FieldRef<"Company", 'String'>
    readonly taxNumber: FieldRef<"Company", 'String'>
    readonly website: FieldRef<"Company", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company.accounts
   */
  export type Company$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Company.auditLogs
   */
  export type Company$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Company.branches
   */
  export type Company$branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    cursor?: BranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Company.currencies
   */
  export type Company$currenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCurrency
     */
    select?: CompanyCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCurrency
     */
    omit?: CompanyCurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCurrencyInclude<ExtArgs> | null
    where?: CompanyCurrencyWhereInput
    orderBy?: CompanyCurrencyOrderByWithRelationInput | CompanyCurrencyOrderByWithRelationInput[]
    cursor?: CompanyCurrencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyCurrencyScalarFieldEnum | CompanyCurrencyScalarFieldEnum[]
  }

  /**
   * Company.customers
   */
  export type Company$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Company.expenses
   */
  export type Company$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Company.expensesMaster
   */
  export type Company$expensesMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseMaster
     */
    select?: ExpenseMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseMaster
     */
    omit?: ExpenseMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseMasterInclude<ExtArgs> | null
    where?: ExpenseMasterWhereInput
    orderBy?: ExpenseMasterOrderByWithRelationInput | ExpenseMasterOrderByWithRelationInput[]
    cursor?: ExpenseMasterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseMasterScalarFieldEnum | ExpenseMasterScalarFieldEnum[]
  }

  /**
   * Company.financialPeriods
   */
  export type Company$financialPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialPeriod
     */
    omit?: FinancialPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodInclude<ExtArgs> | null
    where?: FinancialPeriodWhereInput
    orderBy?: FinancialPeriodOrderByWithRelationInput | FinancialPeriodOrderByWithRelationInput[]
    cursor?: FinancialPeriodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancialPeriodScalarFieldEnum | FinancialPeriodScalarFieldEnum[]
  }

  /**
   * Company.serviceInvoices
   */
  export type Company$serviceInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoice
     */
    select?: ServiceInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoice
     */
    omit?: ServiceInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceInclude<ExtArgs> | null
    where?: ServiceInvoiceWhereInput
    orderBy?: ServiceInvoiceOrderByWithRelationInput | ServiceInvoiceOrderByWithRelationInput[]
    cursor?: ServiceInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceInvoiceScalarFieldEnum | ServiceInvoiceScalarFieldEnum[]
  }

  /**
   * Company.freightInvoices
   */
  export type Company$freightInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoice
     */
    select?: FreightInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoice
     */
    omit?: FreightInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceInclude<ExtArgs> | null
    where?: FreightInvoiceWhereInput
    orderBy?: FreightInvoiceOrderByWithRelationInput | FreightInvoiceOrderByWithRelationInput[]
    cursor?: FreightInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FreightInvoiceScalarFieldEnum | FreightInvoiceScalarFieldEnum[]
  }

  /**
   * Company.jobs
   */
  export type Company$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    cursor?: JobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Company.payments
   */
  export type Company$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Company.ports
   */
  export type Company$portsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Port
     */
    omit?: PortOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortInclude<ExtArgs> | null
    where?: PortWhereInput
    orderBy?: PortOrderByWithRelationInput | PortOrderByWithRelationInput[]
    cursor?: PortWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortScalarFieldEnum | PortScalarFieldEnum[]
  }

  /**
   * Company.products
   */
  export type Company$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Company.productCategories
   */
  export type Company$productCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    cursor?: ProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * Company.purchaseInvoices
   */
  export type Company$purchaseInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    where?: PurchaseInvoiceWhereInput
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    cursor?: PurchaseInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseInvoiceScalarFieldEnum | PurchaseInvoiceScalarFieldEnum[]
  }

  /**
   * Company.stockMovements
   */
  export type Company$stockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    cursor?: StockMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * Company.systemSettings
   */
  export type Company$systemSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    where?: SystemSettingWhereInput
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    cursor?: SystemSettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * Company.taxSettings
   */
  export type Company$taxSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSetting
     */
    select?: TaxSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSetting
     */
    omit?: TaxSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSettingInclude<ExtArgs> | null
    where?: TaxSettingWhereInput
    orderBy?: TaxSettingOrderByWithRelationInput | TaxSettingOrderByWithRelationInput[]
    cursor?: TaxSettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaxSettingScalarFieldEnum | TaxSettingScalarFieldEnum[]
  }

  /**
   * Company.transactions
   */
  export type Company$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Company.users
   */
  export type Company$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Company.vendors
   */
  export type Company$vendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    cursor?: VendorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Company.vouchers
   */
  export type Company$vouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    where?: VoucherWhereInput
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    cursor?: VoucherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Company.warehouses
   */
  export type Company$warehousesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    where?: WarehouseWhereInput
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    cursor?: WarehouseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model Branch
   */

  export type AggregateBranch = {
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  export type BranchAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type BranchSumAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type BranchMinAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchMaxAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchCountAggregateOutputType = {
    id: number
    name: number
    location: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BranchAvgAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type BranchSumAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type BranchMinAggregateInputType = {
    id?: true
    name?: true
    location?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchMaxAggregateInputType = {
    id?: true
    name?: true
    location?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchCountAggregateInputType = {
    id?: true
    name?: true
    location?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branch to aggregate.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Branches
    **/
    _count?: true | BranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchMaxAggregateInputType
  }

  export type GetBranchAggregateType<T extends BranchAggregateArgs> = {
        [P in keyof T & keyof AggregateBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranch[P]>
      : GetScalarType<T[P], AggregateBranch[P]>
  }




  export type BranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithAggregationInput | BranchOrderByWithAggregationInput[]
    by: BranchScalarFieldEnum[] | BranchScalarFieldEnum
    having?: BranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchCountAggregateInputType | true
    _avg?: BranchAvgAggregateInputType
    _sum?: BranchSumAggregateInputType
    _min?: BranchMinAggregateInputType
    _max?: BranchMaxAggregateInputType
  }

  export type BranchGroupByOutputType = {
    id: number
    name: string
    location: string | null
    companyId: number
    createdAt: Date
    updatedAt: Date
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  type GetBranchGroupByPayload<T extends BranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchGroupByOutputType[P]>
            : GetScalarType<T[P], BranchGroupByOutputType[P]>
        }
      >
    >


  export type BranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    jobs?: boolean | Branch$jobsArgs<ExtArgs>
    taxSettings?: boolean | Branch$taxSettingsArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectScalar = {
    id?: boolean
    name?: boolean
    location?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BranchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "location" | "companyId" | "createdAt" | "updatedAt", ExtArgs["result"]["branch"]>
  export type BranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    jobs?: boolean | Branch$jobsArgs<ExtArgs>
    taxSettings?: boolean | Branch$taxSettingsArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type BranchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $BranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Branch"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      jobs: Prisma.$JobPayload<ExtArgs>[]
      taxSettings: Prisma.$TaxSettingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      location: string | null
      companyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["branch"]>
    composites: {}
  }

  type BranchGetPayload<S extends boolean | null | undefined | BranchDefaultArgs> = $Result.GetResult<Prisma.$BranchPayload, S>

  type BranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BranchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BranchCountAggregateInputType | true
    }

  export interface BranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Branch'], meta: { name: 'Branch' } }
    /**
     * Find zero or one Branch that matches the filter.
     * @param {BranchFindUniqueArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BranchFindUniqueArgs>(args: SelectSubset<T, BranchFindUniqueArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Branch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BranchFindUniqueOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BranchFindUniqueOrThrowArgs>(args: SelectSubset<T, BranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BranchFindFirstArgs>(args?: SelectSubset<T, BranchFindFirstArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BranchFindFirstOrThrowArgs>(args?: SelectSubset<T, BranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branch.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchWithIdOnly = await prisma.branch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BranchFindManyArgs>(args?: SelectSubset<T, BranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Branch.
     * @param {BranchCreateArgs} args - Arguments to create a Branch.
     * @example
     * // Create one Branch
     * const Branch = await prisma.branch.create({
     *   data: {
     *     // ... data to create a Branch
     *   }
     * })
     * 
     */
    create<T extends BranchCreateArgs>(args: SelectSubset<T, BranchCreateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Branches.
     * @param {BranchCreateManyArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BranchCreateManyArgs>(args?: SelectSubset<T, BranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Branches and returns the data saved in the database.
     * @param {BranchCreateManyAndReturnArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BranchCreateManyAndReturnArgs>(args?: SelectSubset<T, BranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Branch.
     * @param {BranchDeleteArgs} args - Arguments to delete one Branch.
     * @example
     * // Delete one Branch
     * const Branch = await prisma.branch.delete({
     *   where: {
     *     // ... filter to delete one Branch
     *   }
     * })
     * 
     */
    delete<T extends BranchDeleteArgs>(args: SelectSubset<T, BranchDeleteArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Branch.
     * @param {BranchUpdateArgs} args - Arguments to update one Branch.
     * @example
     * // Update one Branch
     * const branch = await prisma.branch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BranchUpdateArgs>(args: SelectSubset<T, BranchUpdateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Branches.
     * @param {BranchDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BranchDeleteManyArgs>(args?: SelectSubset<T, BranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BranchUpdateManyArgs>(args: SelectSubset<T, BranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches and returns the data updated in the database.
     * @param {BranchUpdateManyAndReturnArgs} args - Arguments to update many Branches.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BranchUpdateManyAndReturnArgs>(args: SelectSubset<T, BranchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Branch.
     * @param {BranchUpsertArgs} args - Arguments to update or create a Branch.
     * @example
     * // Update or create a Branch
     * const branch = await prisma.branch.upsert({
     *   create: {
     *     // ... data to create a Branch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branch we want to update
     *   }
     * })
     */
    upsert<T extends BranchUpsertArgs>(args: SelectSubset<T, BranchUpsertArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branch.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends BranchCountArgs>(
      args?: Subset<T, BranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchAggregateArgs>(args: Subset<T, BranchAggregateArgs>): Prisma.PrismaPromise<GetBranchAggregateType<T>>

    /**
     * Group by Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchGroupByArgs['orderBy'] }
        : { orderBy?: BranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Branch model
   */
  readonly fields: BranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Branch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    jobs<T extends Branch$jobsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taxSettings<T extends Branch$taxSettingsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$taxSettingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Branch model
   */
  interface BranchFieldRefs {
    readonly id: FieldRef<"Branch", 'Int'>
    readonly name: FieldRef<"Branch", 'String'>
    readonly location: FieldRef<"Branch", 'String'>
    readonly companyId: FieldRef<"Branch", 'Int'>
    readonly createdAt: FieldRef<"Branch", 'DateTime'>
    readonly updatedAt: FieldRef<"Branch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Branch findUnique
   */
  export type BranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findUniqueOrThrow
   */
  export type BranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findFirst
   */
  export type BranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findFirstOrThrow
   */
  export type BranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findMany
   */
  export type BranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branches to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch create
   */
  export type BranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to create a Branch.
     */
    data: XOR<BranchCreateInput, BranchUncheckedCreateInput>
  }

  /**
   * Branch createMany
   */
  export type BranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch createManyAndReturn
   */
  export type BranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Branch update
   */
  export type BranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to update a Branch.
     */
    data: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
    /**
     * Choose, which Branch to update.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch updateMany
   */
  export type BranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to update.
     */
    limit?: number
  }

  /**
   * Branch updateManyAndReturn
   */
  export type BranchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Branch upsert
   */
  export type BranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The filter to search for the Branch to update in case it exists.
     */
    where: BranchWhereUniqueInput
    /**
     * In case the Branch found by the `where` argument doesn't exist, create a new Branch with this data.
     */
    create: XOR<BranchCreateInput, BranchUncheckedCreateInput>
    /**
     * In case the Branch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
  }

  /**
   * Branch delete
   */
  export type BranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter which Branch to delete.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch deleteMany
   */
  export type BranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branches to delete
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to delete.
     */
    limit?: number
  }

  /**
   * Branch.jobs
   */
  export type Branch$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    cursor?: JobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Branch.taxSettings
   */
  export type Branch$taxSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSetting
     */
    select?: TaxSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSetting
     */
    omit?: TaxSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSettingInclude<ExtArgs> | null
    where?: TaxSettingWhereInput
    orderBy?: TaxSettingOrderByWithRelationInput | TaxSettingOrderByWithRelationInput[]
    cursor?: TaxSettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaxSettingScalarFieldEnum | TaxSettingScalarFieldEnum[]
  }

  /**
   * Branch without action
   */
  export type BranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
  }


  /**
   * Model Currency
   */

  export type AggregateCurrency = {
    _count: CurrencyCountAggregateOutputType | null
    _avg: CurrencyAvgAggregateOutputType | null
    _sum: CurrencySumAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  export type CurrencyAvgAggregateOutputType = {
    id: number | null
  }

  export type CurrencySumAggregateOutputType = {
    id: number | null
  }

  export type CurrencyMinAggregateOutputType = {
    id: number | null
    code: string | null
    symbol: string | null
    name: string | null
  }

  export type CurrencyMaxAggregateOutputType = {
    id: number | null
    code: string | null
    symbol: string | null
    name: string | null
  }

  export type CurrencyCountAggregateOutputType = {
    id: number
    code: number
    symbol: number
    name: number
    _all: number
  }


  export type CurrencyAvgAggregateInputType = {
    id?: true
  }

  export type CurrencySumAggregateInputType = {
    id?: true
  }

  export type CurrencyMinAggregateInputType = {
    id?: true
    code?: true
    symbol?: true
    name?: true
  }

  export type CurrencyMaxAggregateInputType = {
    id?: true
    code?: true
    symbol?: true
    name?: true
  }

  export type CurrencyCountAggregateInputType = {
    id?: true
    code?: true
    symbol?: true
    name?: true
    _all?: true
  }

  export type CurrencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Currency to aggregate.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Currencies
    **/
    _count?: true | CurrencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CurrencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CurrencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CurrencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CurrencyMaxAggregateInputType
  }

  export type GetCurrencyAggregateType<T extends CurrencyAggregateArgs> = {
        [P in keyof T & keyof AggregateCurrency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurrency[P]>
      : GetScalarType<T[P], AggregateCurrency[P]>
  }




  export type CurrencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurrencyWhereInput
    orderBy?: CurrencyOrderByWithAggregationInput | CurrencyOrderByWithAggregationInput[]
    by: CurrencyScalarFieldEnum[] | CurrencyScalarFieldEnum
    having?: CurrencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CurrencyCountAggregateInputType | true
    _avg?: CurrencyAvgAggregateInputType
    _sum?: CurrencySumAggregateInputType
    _min?: CurrencyMinAggregateInputType
    _max?: CurrencyMaxAggregateInputType
  }

  export type CurrencyGroupByOutputType = {
    id: number
    code: string
    symbol: string
    name: string
    _count: CurrencyCountAggregateOutputType | null
    _avg: CurrencyAvgAggregateOutputType | null
    _sum: CurrencySumAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  type GetCurrencyGroupByPayload<T extends CurrencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CurrencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CurrencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
            : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
        }
      >
    >


  export type CurrencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    symbol?: boolean
    name?: boolean
    companies?: boolean | Currency$companiesArgs<ExtArgs>
    _count?: boolean | CurrencyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    symbol?: boolean
    name?: boolean
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    symbol?: boolean
    name?: boolean
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectScalar = {
    id?: boolean
    code?: boolean
    symbol?: boolean
    name?: boolean
  }

  export type CurrencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "symbol" | "name", ExtArgs["result"]["currency"]>
  export type CurrencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | Currency$companiesArgs<ExtArgs>
    _count?: boolean | CurrencyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CurrencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CurrencyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CurrencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Currency"
    objects: {
      companies: Prisma.$CompanyCurrencyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      symbol: string
      name: string
    }, ExtArgs["result"]["currency"]>
    composites: {}
  }

  type CurrencyGetPayload<S extends boolean | null | undefined | CurrencyDefaultArgs> = $Result.GetResult<Prisma.$CurrencyPayload, S>

  type CurrencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CurrencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CurrencyCountAggregateInputType | true
    }

  export interface CurrencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Currency'], meta: { name: 'Currency' } }
    /**
     * Find zero or one Currency that matches the filter.
     * @param {CurrencyFindUniqueArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CurrencyFindUniqueArgs>(args: SelectSubset<T, CurrencyFindUniqueArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Currency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CurrencyFindUniqueOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CurrencyFindUniqueOrThrowArgs>(args: SelectSubset<T, CurrencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Currency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindFirstArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CurrencyFindFirstArgs>(args?: SelectSubset<T, CurrencyFindFirstArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Currency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindFirstOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CurrencyFindFirstOrThrowArgs>(args?: SelectSubset<T, CurrencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Currencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Currencies
     * const currencies = await prisma.currency.findMany()
     * 
     * // Get first 10 Currencies
     * const currencies = await prisma.currency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const currencyWithIdOnly = await prisma.currency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CurrencyFindManyArgs>(args?: SelectSubset<T, CurrencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Currency.
     * @param {CurrencyCreateArgs} args - Arguments to create a Currency.
     * @example
     * // Create one Currency
     * const Currency = await prisma.currency.create({
     *   data: {
     *     // ... data to create a Currency
     *   }
     * })
     * 
     */
    create<T extends CurrencyCreateArgs>(args: SelectSubset<T, CurrencyCreateArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Currencies.
     * @param {CurrencyCreateManyArgs} args - Arguments to create many Currencies.
     * @example
     * // Create many Currencies
     * const currency = await prisma.currency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CurrencyCreateManyArgs>(args?: SelectSubset<T, CurrencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Currencies and returns the data saved in the database.
     * @param {CurrencyCreateManyAndReturnArgs} args - Arguments to create many Currencies.
     * @example
     * // Create many Currencies
     * const currency = await prisma.currency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Currencies and only return the `id`
     * const currencyWithIdOnly = await prisma.currency.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CurrencyCreateManyAndReturnArgs>(args?: SelectSubset<T, CurrencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Currency.
     * @param {CurrencyDeleteArgs} args - Arguments to delete one Currency.
     * @example
     * // Delete one Currency
     * const Currency = await prisma.currency.delete({
     *   where: {
     *     // ... filter to delete one Currency
     *   }
     * })
     * 
     */
    delete<T extends CurrencyDeleteArgs>(args: SelectSubset<T, CurrencyDeleteArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Currency.
     * @param {CurrencyUpdateArgs} args - Arguments to update one Currency.
     * @example
     * // Update one Currency
     * const currency = await prisma.currency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CurrencyUpdateArgs>(args: SelectSubset<T, CurrencyUpdateArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Currencies.
     * @param {CurrencyDeleteManyArgs} args - Arguments to filter Currencies to delete.
     * @example
     * // Delete a few Currencies
     * const { count } = await prisma.currency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CurrencyDeleteManyArgs>(args?: SelectSubset<T, CurrencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Currencies
     * const currency = await prisma.currency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CurrencyUpdateManyArgs>(args: SelectSubset<T, CurrencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currencies and returns the data updated in the database.
     * @param {CurrencyUpdateManyAndReturnArgs} args - Arguments to update many Currencies.
     * @example
     * // Update many Currencies
     * const currency = await prisma.currency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Currencies and only return the `id`
     * const currencyWithIdOnly = await prisma.currency.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CurrencyUpdateManyAndReturnArgs>(args: SelectSubset<T, CurrencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Currency.
     * @param {CurrencyUpsertArgs} args - Arguments to update or create a Currency.
     * @example
     * // Update or create a Currency
     * const currency = await prisma.currency.upsert({
     *   create: {
     *     // ... data to create a Currency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Currency we want to update
     *   }
     * })
     */
    upsert<T extends CurrencyUpsertArgs>(args: SelectSubset<T, CurrencyUpsertArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyCountArgs} args - Arguments to filter Currencies to count.
     * @example
     * // Count the number of Currencies
     * const count = await prisma.currency.count({
     *   where: {
     *     // ... the filter for the Currencies we want to count
     *   }
     * })
    **/
    count<T extends CurrencyCountArgs>(
      args?: Subset<T, CurrencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurrencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurrencyAggregateArgs>(args: Subset<T, CurrencyAggregateArgs>): Prisma.PrismaPromise<GetCurrencyAggregateType<T>>

    /**
     * Group by Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CurrencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CurrencyGroupByArgs['orderBy'] }
        : { orderBy?: CurrencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CurrencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurrencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Currency model
   */
  readonly fields: CurrencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Currency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CurrencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends Currency$companiesArgs<ExtArgs> = {}>(args?: Subset<T, Currency$companiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyCurrencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Currency model
   */
  interface CurrencyFieldRefs {
    readonly id: FieldRef<"Currency", 'Int'>
    readonly code: FieldRef<"Currency", 'String'>
    readonly symbol: FieldRef<"Currency", 'String'>
    readonly name: FieldRef<"Currency", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Currency findUnique
   */
  export type CurrencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency findUniqueOrThrow
   */
  export type CurrencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency findFirst
   */
  export type CurrencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Currencies.
     */
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency findFirstOrThrow
   */
  export type CurrencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Currencies.
     */
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency findMany
   */
  export type CurrencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currencies to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency create
   */
  export type CurrencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Currency.
     */
    data: XOR<CurrencyCreateInput, CurrencyUncheckedCreateInput>
  }

  /**
   * Currency createMany
   */
  export type CurrencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Currencies.
     */
    data: CurrencyCreateManyInput | CurrencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Currency createManyAndReturn
   */
  export type CurrencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * The data used to create many Currencies.
     */
    data: CurrencyCreateManyInput | CurrencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Currency update
   */
  export type CurrencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Currency.
     */
    data: XOR<CurrencyUpdateInput, CurrencyUncheckedUpdateInput>
    /**
     * Choose, which Currency to update.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency updateMany
   */
  export type CurrencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Currencies.
     */
    data: XOR<CurrencyUpdateManyMutationInput, CurrencyUncheckedUpdateManyInput>
    /**
     * Filter which Currencies to update
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to update.
     */
    limit?: number
  }

  /**
   * Currency updateManyAndReturn
   */
  export type CurrencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * The data used to update Currencies.
     */
    data: XOR<CurrencyUpdateManyMutationInput, CurrencyUncheckedUpdateManyInput>
    /**
     * Filter which Currencies to update
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to update.
     */
    limit?: number
  }

  /**
   * Currency upsert
   */
  export type CurrencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Currency to update in case it exists.
     */
    where: CurrencyWhereUniqueInput
    /**
     * In case the Currency found by the `where` argument doesn't exist, create a new Currency with this data.
     */
    create: XOR<CurrencyCreateInput, CurrencyUncheckedCreateInput>
    /**
     * In case the Currency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CurrencyUpdateInput, CurrencyUncheckedUpdateInput>
  }

  /**
   * Currency delete
   */
  export type CurrencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter which Currency to delete.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency deleteMany
   */
  export type CurrencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Currencies to delete
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to delete.
     */
    limit?: number
  }

  /**
   * Currency.companies
   */
  export type Currency$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCurrency
     */
    select?: CompanyCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCurrency
     */
    omit?: CompanyCurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCurrencyInclude<ExtArgs> | null
    where?: CompanyCurrencyWhereInput
    orderBy?: CompanyCurrencyOrderByWithRelationInput | CompanyCurrencyOrderByWithRelationInput[]
    cursor?: CompanyCurrencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyCurrencyScalarFieldEnum | CompanyCurrencyScalarFieldEnum[]
  }

  /**
   * Currency without action
   */
  export type CurrencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
  }


  /**
   * Model CompanyCurrency
   */

  export type AggregateCompanyCurrency = {
    _count: CompanyCurrencyCountAggregateOutputType | null
    _avg: CompanyCurrencyAvgAggregateOutputType | null
    _sum: CompanyCurrencySumAggregateOutputType | null
    _min: CompanyCurrencyMinAggregateOutputType | null
    _max: CompanyCurrencyMaxAggregateOutputType | null
  }

  export type CompanyCurrencyAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
    currencyId: number | null
    exchangeRate: number | null
  }

  export type CompanyCurrencySumAggregateOutputType = {
    id: number | null
    companyId: number | null
    currencyId: number | null
    exchangeRate: number | null
  }

  export type CompanyCurrencyMinAggregateOutputType = {
    id: number | null
    companyId: number | null
    currencyId: number | null
    exchangeRate: number | null
    isDefault: boolean | null
  }

  export type CompanyCurrencyMaxAggregateOutputType = {
    id: number | null
    companyId: number | null
    currencyId: number | null
    exchangeRate: number | null
    isDefault: boolean | null
  }

  export type CompanyCurrencyCountAggregateOutputType = {
    id: number
    companyId: number
    currencyId: number
    exchangeRate: number
    isDefault: number
    _all: number
  }


  export type CompanyCurrencyAvgAggregateInputType = {
    id?: true
    companyId?: true
    currencyId?: true
    exchangeRate?: true
  }

  export type CompanyCurrencySumAggregateInputType = {
    id?: true
    companyId?: true
    currencyId?: true
    exchangeRate?: true
  }

  export type CompanyCurrencyMinAggregateInputType = {
    id?: true
    companyId?: true
    currencyId?: true
    exchangeRate?: true
    isDefault?: true
  }

  export type CompanyCurrencyMaxAggregateInputType = {
    id?: true
    companyId?: true
    currencyId?: true
    exchangeRate?: true
    isDefault?: true
  }

  export type CompanyCurrencyCountAggregateInputType = {
    id?: true
    companyId?: true
    currencyId?: true
    exchangeRate?: true
    isDefault?: true
    _all?: true
  }

  export type CompanyCurrencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyCurrency to aggregate.
     */
    where?: CompanyCurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyCurrencies to fetch.
     */
    orderBy?: CompanyCurrencyOrderByWithRelationInput | CompanyCurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyCurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyCurrencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyCurrencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyCurrencies
    **/
    _count?: true | CompanyCurrencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyCurrencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyCurrencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyCurrencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyCurrencyMaxAggregateInputType
  }

  export type GetCompanyCurrencyAggregateType<T extends CompanyCurrencyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyCurrency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyCurrency[P]>
      : GetScalarType<T[P], AggregateCompanyCurrency[P]>
  }




  export type CompanyCurrencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyCurrencyWhereInput
    orderBy?: CompanyCurrencyOrderByWithAggregationInput | CompanyCurrencyOrderByWithAggregationInput[]
    by: CompanyCurrencyScalarFieldEnum[] | CompanyCurrencyScalarFieldEnum
    having?: CompanyCurrencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCurrencyCountAggregateInputType | true
    _avg?: CompanyCurrencyAvgAggregateInputType
    _sum?: CompanyCurrencySumAggregateInputType
    _min?: CompanyCurrencyMinAggregateInputType
    _max?: CompanyCurrencyMaxAggregateInputType
  }

  export type CompanyCurrencyGroupByOutputType = {
    id: number
    companyId: number
    currencyId: number
    exchangeRate: number
    isDefault: boolean
    _count: CompanyCurrencyCountAggregateOutputType | null
    _avg: CompanyCurrencyAvgAggregateOutputType | null
    _sum: CompanyCurrencySumAggregateOutputType | null
    _min: CompanyCurrencyMinAggregateOutputType | null
    _max: CompanyCurrencyMaxAggregateOutputType | null
  }

  type GetCompanyCurrencyGroupByPayload<T extends CompanyCurrencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyCurrencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyCurrencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyCurrencyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyCurrencyGroupByOutputType[P]>
        }
      >
    >


  export type CompanyCurrencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    currencyId?: boolean
    exchangeRate?: boolean
    isDefault?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyCurrency"]>

  export type CompanyCurrencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    currencyId?: boolean
    exchangeRate?: boolean
    isDefault?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyCurrency"]>

  export type CompanyCurrencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    currencyId?: boolean
    exchangeRate?: boolean
    isDefault?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyCurrency"]>

  export type CompanyCurrencySelectScalar = {
    id?: boolean
    companyId?: boolean
    currencyId?: boolean
    exchangeRate?: boolean
    isDefault?: boolean
  }

  export type CompanyCurrencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "currencyId" | "exchangeRate" | "isDefault", ExtArgs["result"]["companyCurrency"]>
  export type CompanyCurrencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }
  export type CompanyCurrencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }
  export type CompanyCurrencyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }

  export type $CompanyCurrencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyCurrency"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      currency: Prisma.$CurrencyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      companyId: number
      currencyId: number
      exchangeRate: number
      isDefault: boolean
    }, ExtArgs["result"]["companyCurrency"]>
    composites: {}
  }

  type CompanyCurrencyGetPayload<S extends boolean | null | undefined | CompanyCurrencyDefaultArgs> = $Result.GetResult<Prisma.$CompanyCurrencyPayload, S>

  type CompanyCurrencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyCurrencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCurrencyCountAggregateInputType | true
    }

  export interface CompanyCurrencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyCurrency'], meta: { name: 'CompanyCurrency' } }
    /**
     * Find zero or one CompanyCurrency that matches the filter.
     * @param {CompanyCurrencyFindUniqueArgs} args - Arguments to find a CompanyCurrency
     * @example
     * // Get one CompanyCurrency
     * const companyCurrency = await prisma.companyCurrency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyCurrencyFindUniqueArgs>(args: SelectSubset<T, CompanyCurrencyFindUniqueArgs<ExtArgs>>): Prisma__CompanyCurrencyClient<$Result.GetResult<Prisma.$CompanyCurrencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyCurrency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyCurrencyFindUniqueOrThrowArgs} args - Arguments to find a CompanyCurrency
     * @example
     * // Get one CompanyCurrency
     * const companyCurrency = await prisma.companyCurrency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyCurrencyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyCurrencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyCurrencyClient<$Result.GetResult<Prisma.$CompanyCurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyCurrency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCurrencyFindFirstArgs} args - Arguments to find a CompanyCurrency
     * @example
     * // Get one CompanyCurrency
     * const companyCurrency = await prisma.companyCurrency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyCurrencyFindFirstArgs>(args?: SelectSubset<T, CompanyCurrencyFindFirstArgs<ExtArgs>>): Prisma__CompanyCurrencyClient<$Result.GetResult<Prisma.$CompanyCurrencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyCurrency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCurrencyFindFirstOrThrowArgs} args - Arguments to find a CompanyCurrency
     * @example
     * // Get one CompanyCurrency
     * const companyCurrency = await prisma.companyCurrency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyCurrencyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyCurrencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyCurrencyClient<$Result.GetResult<Prisma.$CompanyCurrencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyCurrencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCurrencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyCurrencies
     * const companyCurrencies = await prisma.companyCurrency.findMany()
     * 
     * // Get first 10 CompanyCurrencies
     * const companyCurrencies = await prisma.companyCurrency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyCurrencyWithIdOnly = await prisma.companyCurrency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyCurrencyFindManyArgs>(args?: SelectSubset<T, CompanyCurrencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyCurrencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyCurrency.
     * @param {CompanyCurrencyCreateArgs} args - Arguments to create a CompanyCurrency.
     * @example
     * // Create one CompanyCurrency
     * const CompanyCurrency = await prisma.companyCurrency.create({
     *   data: {
     *     // ... data to create a CompanyCurrency
     *   }
     * })
     * 
     */
    create<T extends CompanyCurrencyCreateArgs>(args: SelectSubset<T, CompanyCurrencyCreateArgs<ExtArgs>>): Prisma__CompanyCurrencyClient<$Result.GetResult<Prisma.$CompanyCurrencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyCurrencies.
     * @param {CompanyCurrencyCreateManyArgs} args - Arguments to create many CompanyCurrencies.
     * @example
     * // Create many CompanyCurrencies
     * const companyCurrency = await prisma.companyCurrency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCurrencyCreateManyArgs>(args?: SelectSubset<T, CompanyCurrencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyCurrencies and returns the data saved in the database.
     * @param {CompanyCurrencyCreateManyAndReturnArgs} args - Arguments to create many CompanyCurrencies.
     * @example
     * // Create many CompanyCurrencies
     * const companyCurrency = await prisma.companyCurrency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyCurrencies and only return the `id`
     * const companyCurrencyWithIdOnly = await prisma.companyCurrency.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCurrencyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCurrencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyCurrencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompanyCurrency.
     * @param {CompanyCurrencyDeleteArgs} args - Arguments to delete one CompanyCurrency.
     * @example
     * // Delete one CompanyCurrency
     * const CompanyCurrency = await prisma.companyCurrency.delete({
     *   where: {
     *     // ... filter to delete one CompanyCurrency
     *   }
     * })
     * 
     */
    delete<T extends CompanyCurrencyDeleteArgs>(args: SelectSubset<T, CompanyCurrencyDeleteArgs<ExtArgs>>): Prisma__CompanyCurrencyClient<$Result.GetResult<Prisma.$CompanyCurrencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyCurrency.
     * @param {CompanyCurrencyUpdateArgs} args - Arguments to update one CompanyCurrency.
     * @example
     * // Update one CompanyCurrency
     * const companyCurrency = await prisma.companyCurrency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyCurrencyUpdateArgs>(args: SelectSubset<T, CompanyCurrencyUpdateArgs<ExtArgs>>): Prisma__CompanyCurrencyClient<$Result.GetResult<Prisma.$CompanyCurrencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyCurrencies.
     * @param {CompanyCurrencyDeleteManyArgs} args - Arguments to filter CompanyCurrencies to delete.
     * @example
     * // Delete a few CompanyCurrencies
     * const { count } = await prisma.companyCurrency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyCurrencyDeleteManyArgs>(args?: SelectSubset<T, CompanyCurrencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyCurrencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCurrencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyCurrencies
     * const companyCurrency = await prisma.companyCurrency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyCurrencyUpdateManyArgs>(args: SelectSubset<T, CompanyCurrencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyCurrencies and returns the data updated in the database.
     * @param {CompanyCurrencyUpdateManyAndReturnArgs} args - Arguments to update many CompanyCurrencies.
     * @example
     * // Update many CompanyCurrencies
     * const companyCurrency = await prisma.companyCurrency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompanyCurrencies and only return the `id`
     * const companyCurrencyWithIdOnly = await prisma.companyCurrency.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyCurrencyUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyCurrencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyCurrencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompanyCurrency.
     * @param {CompanyCurrencyUpsertArgs} args - Arguments to update or create a CompanyCurrency.
     * @example
     * // Update or create a CompanyCurrency
     * const companyCurrency = await prisma.companyCurrency.upsert({
     *   create: {
     *     // ... data to create a CompanyCurrency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyCurrency we want to update
     *   }
     * })
     */
    upsert<T extends CompanyCurrencyUpsertArgs>(args: SelectSubset<T, CompanyCurrencyUpsertArgs<ExtArgs>>): Prisma__CompanyCurrencyClient<$Result.GetResult<Prisma.$CompanyCurrencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyCurrencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCurrencyCountArgs} args - Arguments to filter CompanyCurrencies to count.
     * @example
     * // Count the number of CompanyCurrencies
     * const count = await prisma.companyCurrency.count({
     *   where: {
     *     // ... the filter for the CompanyCurrencies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCurrencyCountArgs>(
      args?: Subset<T, CompanyCurrencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCurrencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyCurrency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCurrencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyCurrencyAggregateArgs>(args: Subset<T, CompanyCurrencyAggregateArgs>): Prisma.PrismaPromise<GetCompanyCurrencyAggregateType<T>>

    /**
     * Group by CompanyCurrency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCurrencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyCurrencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyCurrencyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyCurrencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyCurrencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyCurrencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyCurrency model
   */
  readonly fields: CompanyCurrencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyCurrency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyCurrencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    currency<T extends CurrencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CurrencyDefaultArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyCurrency model
   */
  interface CompanyCurrencyFieldRefs {
    readonly id: FieldRef<"CompanyCurrency", 'Int'>
    readonly companyId: FieldRef<"CompanyCurrency", 'Int'>
    readonly currencyId: FieldRef<"CompanyCurrency", 'Int'>
    readonly exchangeRate: FieldRef<"CompanyCurrency", 'Float'>
    readonly isDefault: FieldRef<"CompanyCurrency", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * CompanyCurrency findUnique
   */
  export type CompanyCurrencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCurrency
     */
    select?: CompanyCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCurrency
     */
    omit?: CompanyCurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCurrencyInclude<ExtArgs> | null
    /**
     * Filter, which CompanyCurrency to fetch.
     */
    where: CompanyCurrencyWhereUniqueInput
  }

  /**
   * CompanyCurrency findUniqueOrThrow
   */
  export type CompanyCurrencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCurrency
     */
    select?: CompanyCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCurrency
     */
    omit?: CompanyCurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCurrencyInclude<ExtArgs> | null
    /**
     * Filter, which CompanyCurrency to fetch.
     */
    where: CompanyCurrencyWhereUniqueInput
  }

  /**
   * CompanyCurrency findFirst
   */
  export type CompanyCurrencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCurrency
     */
    select?: CompanyCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCurrency
     */
    omit?: CompanyCurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCurrencyInclude<ExtArgs> | null
    /**
     * Filter, which CompanyCurrency to fetch.
     */
    where?: CompanyCurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyCurrencies to fetch.
     */
    orderBy?: CompanyCurrencyOrderByWithRelationInput | CompanyCurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyCurrencies.
     */
    cursor?: CompanyCurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyCurrencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyCurrencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyCurrencies.
     */
    distinct?: CompanyCurrencyScalarFieldEnum | CompanyCurrencyScalarFieldEnum[]
  }

  /**
   * CompanyCurrency findFirstOrThrow
   */
  export type CompanyCurrencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCurrency
     */
    select?: CompanyCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCurrency
     */
    omit?: CompanyCurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCurrencyInclude<ExtArgs> | null
    /**
     * Filter, which CompanyCurrency to fetch.
     */
    where?: CompanyCurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyCurrencies to fetch.
     */
    orderBy?: CompanyCurrencyOrderByWithRelationInput | CompanyCurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyCurrencies.
     */
    cursor?: CompanyCurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyCurrencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyCurrencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyCurrencies.
     */
    distinct?: CompanyCurrencyScalarFieldEnum | CompanyCurrencyScalarFieldEnum[]
  }

  /**
   * CompanyCurrency findMany
   */
  export type CompanyCurrencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCurrency
     */
    select?: CompanyCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCurrency
     */
    omit?: CompanyCurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCurrencyInclude<ExtArgs> | null
    /**
     * Filter, which CompanyCurrencies to fetch.
     */
    where?: CompanyCurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyCurrencies to fetch.
     */
    orderBy?: CompanyCurrencyOrderByWithRelationInput | CompanyCurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyCurrencies.
     */
    cursor?: CompanyCurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyCurrencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyCurrencies.
     */
    skip?: number
    distinct?: CompanyCurrencyScalarFieldEnum | CompanyCurrencyScalarFieldEnum[]
  }

  /**
   * CompanyCurrency create
   */
  export type CompanyCurrencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCurrency
     */
    select?: CompanyCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCurrency
     */
    omit?: CompanyCurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCurrencyInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyCurrency.
     */
    data: XOR<CompanyCurrencyCreateInput, CompanyCurrencyUncheckedCreateInput>
  }

  /**
   * CompanyCurrency createMany
   */
  export type CompanyCurrencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyCurrencies.
     */
    data: CompanyCurrencyCreateManyInput | CompanyCurrencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyCurrency createManyAndReturn
   */
  export type CompanyCurrencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCurrency
     */
    select?: CompanyCurrencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCurrency
     */
    omit?: CompanyCurrencyOmit<ExtArgs> | null
    /**
     * The data used to create many CompanyCurrencies.
     */
    data: CompanyCurrencyCreateManyInput | CompanyCurrencyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCurrencyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyCurrency update
   */
  export type CompanyCurrencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCurrency
     */
    select?: CompanyCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCurrency
     */
    omit?: CompanyCurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCurrencyInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyCurrency.
     */
    data: XOR<CompanyCurrencyUpdateInput, CompanyCurrencyUncheckedUpdateInput>
    /**
     * Choose, which CompanyCurrency to update.
     */
    where: CompanyCurrencyWhereUniqueInput
  }

  /**
   * CompanyCurrency updateMany
   */
  export type CompanyCurrencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyCurrencies.
     */
    data: XOR<CompanyCurrencyUpdateManyMutationInput, CompanyCurrencyUncheckedUpdateManyInput>
    /**
     * Filter which CompanyCurrencies to update
     */
    where?: CompanyCurrencyWhereInput
    /**
     * Limit how many CompanyCurrencies to update.
     */
    limit?: number
  }

  /**
   * CompanyCurrency updateManyAndReturn
   */
  export type CompanyCurrencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCurrency
     */
    select?: CompanyCurrencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCurrency
     */
    omit?: CompanyCurrencyOmit<ExtArgs> | null
    /**
     * The data used to update CompanyCurrencies.
     */
    data: XOR<CompanyCurrencyUpdateManyMutationInput, CompanyCurrencyUncheckedUpdateManyInput>
    /**
     * Filter which CompanyCurrencies to update
     */
    where?: CompanyCurrencyWhereInput
    /**
     * Limit how many CompanyCurrencies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCurrencyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyCurrency upsert
   */
  export type CompanyCurrencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCurrency
     */
    select?: CompanyCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCurrency
     */
    omit?: CompanyCurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCurrencyInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyCurrency to update in case it exists.
     */
    where: CompanyCurrencyWhereUniqueInput
    /**
     * In case the CompanyCurrency found by the `where` argument doesn't exist, create a new CompanyCurrency with this data.
     */
    create: XOR<CompanyCurrencyCreateInput, CompanyCurrencyUncheckedCreateInput>
    /**
     * In case the CompanyCurrency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyCurrencyUpdateInput, CompanyCurrencyUncheckedUpdateInput>
  }

  /**
   * CompanyCurrency delete
   */
  export type CompanyCurrencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCurrency
     */
    select?: CompanyCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCurrency
     */
    omit?: CompanyCurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCurrencyInclude<ExtArgs> | null
    /**
     * Filter which CompanyCurrency to delete.
     */
    where: CompanyCurrencyWhereUniqueInput
  }

  /**
   * CompanyCurrency deleteMany
   */
  export type CompanyCurrencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyCurrencies to delete
     */
    where?: CompanyCurrencyWhereInput
    /**
     * Limit how many CompanyCurrencies to delete.
     */
    limit?: number
  }

  /**
   * CompanyCurrency without action
   */
  export type CompanyCurrencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCurrency
     */
    select?: CompanyCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCurrency
     */
    omit?: CompanyCurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCurrencyInclude<ExtArgs> | null
  }


  /**
   * Model TaxSetting
   */

  export type AggregateTaxSetting = {
    _count: TaxSettingCountAggregateOutputType | null
    _avg: TaxSettingAvgAggregateOutputType | null
    _sum: TaxSettingSumAggregateOutputType | null
    _min: TaxSettingMinAggregateOutputType | null
    _max: TaxSettingMaxAggregateOutputType | null
  }

  export type TaxSettingAvgAggregateOutputType = {
    id: number | null
    percentage: number | null
    companyId: number | null
    branchId: number | null
  }

  export type TaxSettingSumAggregateOutputType = {
    id: number | null
    percentage: number | null
    companyId: number | null
    branchId: number | null
  }

  export type TaxSettingMinAggregateOutputType = {
    id: number | null
    name: string | null
    percentage: number | null
    type: string | null
    companyId: number | null
    branchId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxSettingMaxAggregateOutputType = {
    id: number | null
    name: string | null
    percentage: number | null
    type: string | null
    companyId: number | null
    branchId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxSettingCountAggregateOutputType = {
    id: number
    name: number
    percentage: number
    type: number
    companyId: number
    branchId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaxSettingAvgAggregateInputType = {
    id?: true
    percentage?: true
    companyId?: true
    branchId?: true
  }

  export type TaxSettingSumAggregateInputType = {
    id?: true
    percentage?: true
    companyId?: true
    branchId?: true
  }

  export type TaxSettingMinAggregateInputType = {
    id?: true
    name?: true
    percentage?: true
    type?: true
    companyId?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxSettingMaxAggregateInputType = {
    id?: true
    name?: true
    percentage?: true
    type?: true
    companyId?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxSettingCountAggregateInputType = {
    id?: true
    name?: true
    percentage?: true
    type?: true
    companyId?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaxSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxSetting to aggregate.
     */
    where?: TaxSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxSettings to fetch.
     */
    orderBy?: TaxSettingOrderByWithRelationInput | TaxSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaxSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaxSettings
    **/
    _count?: true | TaxSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaxSettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaxSettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaxSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaxSettingMaxAggregateInputType
  }

  export type GetTaxSettingAggregateType<T extends TaxSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateTaxSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaxSetting[P]>
      : GetScalarType<T[P], AggregateTaxSetting[P]>
  }




  export type TaxSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxSettingWhereInput
    orderBy?: TaxSettingOrderByWithAggregationInput | TaxSettingOrderByWithAggregationInput[]
    by: TaxSettingScalarFieldEnum[] | TaxSettingScalarFieldEnum
    having?: TaxSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaxSettingCountAggregateInputType | true
    _avg?: TaxSettingAvgAggregateInputType
    _sum?: TaxSettingSumAggregateInputType
    _min?: TaxSettingMinAggregateInputType
    _max?: TaxSettingMaxAggregateInputType
  }

  export type TaxSettingGroupByOutputType = {
    id: number
    name: string
    percentage: number
    type: string
    companyId: number
    branchId: number | null
    createdAt: Date
    updatedAt: Date
    _count: TaxSettingCountAggregateOutputType | null
    _avg: TaxSettingAvgAggregateOutputType | null
    _sum: TaxSettingSumAggregateOutputType | null
    _min: TaxSettingMinAggregateOutputType | null
    _max: TaxSettingMaxAggregateOutputType | null
  }

  type GetTaxSettingGroupByPayload<T extends TaxSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaxSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaxSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxSettingGroupByOutputType[P]>
            : GetScalarType<T[P], TaxSettingGroupByOutputType[P]>
        }
      >
    >


  export type TaxSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    percentage?: boolean
    type?: boolean
    companyId?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | TaxSetting$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxSetting"]>

  export type TaxSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    percentage?: boolean
    type?: boolean
    companyId?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | TaxSetting$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxSetting"]>

  export type TaxSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    percentage?: boolean
    type?: boolean
    companyId?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | TaxSetting$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxSetting"]>

  export type TaxSettingSelectScalar = {
    id?: boolean
    name?: boolean
    percentage?: boolean
    type?: boolean
    companyId?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaxSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "percentage" | "type" | "companyId" | "branchId" | "createdAt" | "updatedAt", ExtArgs["result"]["taxSetting"]>
  export type TaxSettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | TaxSetting$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type TaxSettingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | TaxSetting$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type TaxSettingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | TaxSetting$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $TaxSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaxSetting"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      percentage: number
      type: string
      companyId: number
      branchId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["taxSetting"]>
    composites: {}
  }

  type TaxSettingGetPayload<S extends boolean | null | undefined | TaxSettingDefaultArgs> = $Result.GetResult<Prisma.$TaxSettingPayload, S>

  type TaxSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaxSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaxSettingCountAggregateInputType | true
    }

  export interface TaxSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaxSetting'], meta: { name: 'TaxSetting' } }
    /**
     * Find zero or one TaxSetting that matches the filter.
     * @param {TaxSettingFindUniqueArgs} args - Arguments to find a TaxSetting
     * @example
     * // Get one TaxSetting
     * const taxSetting = await prisma.taxSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaxSettingFindUniqueArgs>(args: SelectSubset<T, TaxSettingFindUniqueArgs<ExtArgs>>): Prisma__TaxSettingClient<$Result.GetResult<Prisma.$TaxSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaxSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaxSettingFindUniqueOrThrowArgs} args - Arguments to find a TaxSetting
     * @example
     * // Get one TaxSetting
     * const taxSetting = await prisma.taxSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaxSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, TaxSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaxSettingClient<$Result.GetResult<Prisma.$TaxSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxSettingFindFirstArgs} args - Arguments to find a TaxSetting
     * @example
     * // Get one TaxSetting
     * const taxSetting = await prisma.taxSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaxSettingFindFirstArgs>(args?: SelectSubset<T, TaxSettingFindFirstArgs<ExtArgs>>): Prisma__TaxSettingClient<$Result.GetResult<Prisma.$TaxSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxSettingFindFirstOrThrowArgs} args - Arguments to find a TaxSetting
     * @example
     * // Get one TaxSetting
     * const taxSetting = await prisma.taxSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaxSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, TaxSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaxSettingClient<$Result.GetResult<Prisma.$TaxSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaxSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaxSettings
     * const taxSettings = await prisma.taxSetting.findMany()
     * 
     * // Get first 10 TaxSettings
     * const taxSettings = await prisma.taxSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taxSettingWithIdOnly = await prisma.taxSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaxSettingFindManyArgs>(args?: SelectSubset<T, TaxSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaxSetting.
     * @param {TaxSettingCreateArgs} args - Arguments to create a TaxSetting.
     * @example
     * // Create one TaxSetting
     * const TaxSetting = await prisma.taxSetting.create({
     *   data: {
     *     // ... data to create a TaxSetting
     *   }
     * })
     * 
     */
    create<T extends TaxSettingCreateArgs>(args: SelectSubset<T, TaxSettingCreateArgs<ExtArgs>>): Prisma__TaxSettingClient<$Result.GetResult<Prisma.$TaxSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaxSettings.
     * @param {TaxSettingCreateManyArgs} args - Arguments to create many TaxSettings.
     * @example
     * // Create many TaxSettings
     * const taxSetting = await prisma.taxSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaxSettingCreateManyArgs>(args?: SelectSubset<T, TaxSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaxSettings and returns the data saved in the database.
     * @param {TaxSettingCreateManyAndReturnArgs} args - Arguments to create many TaxSettings.
     * @example
     * // Create many TaxSettings
     * const taxSetting = await prisma.taxSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaxSettings and only return the `id`
     * const taxSettingWithIdOnly = await prisma.taxSetting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaxSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, TaxSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaxSetting.
     * @param {TaxSettingDeleteArgs} args - Arguments to delete one TaxSetting.
     * @example
     * // Delete one TaxSetting
     * const TaxSetting = await prisma.taxSetting.delete({
     *   where: {
     *     // ... filter to delete one TaxSetting
     *   }
     * })
     * 
     */
    delete<T extends TaxSettingDeleteArgs>(args: SelectSubset<T, TaxSettingDeleteArgs<ExtArgs>>): Prisma__TaxSettingClient<$Result.GetResult<Prisma.$TaxSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaxSetting.
     * @param {TaxSettingUpdateArgs} args - Arguments to update one TaxSetting.
     * @example
     * // Update one TaxSetting
     * const taxSetting = await prisma.taxSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaxSettingUpdateArgs>(args: SelectSubset<T, TaxSettingUpdateArgs<ExtArgs>>): Prisma__TaxSettingClient<$Result.GetResult<Prisma.$TaxSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaxSettings.
     * @param {TaxSettingDeleteManyArgs} args - Arguments to filter TaxSettings to delete.
     * @example
     * // Delete a few TaxSettings
     * const { count } = await prisma.taxSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaxSettingDeleteManyArgs>(args?: SelectSubset<T, TaxSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaxSettings
     * const taxSetting = await prisma.taxSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaxSettingUpdateManyArgs>(args: SelectSubset<T, TaxSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxSettings and returns the data updated in the database.
     * @param {TaxSettingUpdateManyAndReturnArgs} args - Arguments to update many TaxSettings.
     * @example
     * // Update many TaxSettings
     * const taxSetting = await prisma.taxSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaxSettings and only return the `id`
     * const taxSettingWithIdOnly = await prisma.taxSetting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaxSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, TaxSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaxSetting.
     * @param {TaxSettingUpsertArgs} args - Arguments to update or create a TaxSetting.
     * @example
     * // Update or create a TaxSetting
     * const taxSetting = await prisma.taxSetting.upsert({
     *   create: {
     *     // ... data to create a TaxSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaxSetting we want to update
     *   }
     * })
     */
    upsert<T extends TaxSettingUpsertArgs>(args: SelectSubset<T, TaxSettingUpsertArgs<ExtArgs>>): Prisma__TaxSettingClient<$Result.GetResult<Prisma.$TaxSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaxSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxSettingCountArgs} args - Arguments to filter TaxSettings to count.
     * @example
     * // Count the number of TaxSettings
     * const count = await prisma.taxSetting.count({
     *   where: {
     *     // ... the filter for the TaxSettings we want to count
     *   }
     * })
    **/
    count<T extends TaxSettingCountArgs>(
      args?: Subset<T, TaxSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaxSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaxSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaxSettingAggregateArgs>(args: Subset<T, TaxSettingAggregateArgs>): Prisma.PrismaPromise<GetTaxSettingAggregateType<T>>

    /**
     * Group by TaxSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaxSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaxSettingGroupByArgs['orderBy'] }
        : { orderBy?: TaxSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaxSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaxSetting model
   */
  readonly fields: TaxSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaxSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaxSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends TaxSetting$branchArgs<ExtArgs> = {}>(args?: Subset<T, TaxSetting$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaxSetting model
   */
  interface TaxSettingFieldRefs {
    readonly id: FieldRef<"TaxSetting", 'Int'>
    readonly name: FieldRef<"TaxSetting", 'String'>
    readonly percentage: FieldRef<"TaxSetting", 'Float'>
    readonly type: FieldRef<"TaxSetting", 'String'>
    readonly companyId: FieldRef<"TaxSetting", 'Int'>
    readonly branchId: FieldRef<"TaxSetting", 'Int'>
    readonly createdAt: FieldRef<"TaxSetting", 'DateTime'>
    readonly updatedAt: FieldRef<"TaxSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaxSetting findUnique
   */
  export type TaxSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSetting
     */
    select?: TaxSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSetting
     */
    omit?: TaxSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSettingInclude<ExtArgs> | null
    /**
     * Filter, which TaxSetting to fetch.
     */
    where: TaxSettingWhereUniqueInput
  }

  /**
   * TaxSetting findUniqueOrThrow
   */
  export type TaxSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSetting
     */
    select?: TaxSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSetting
     */
    omit?: TaxSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSettingInclude<ExtArgs> | null
    /**
     * Filter, which TaxSetting to fetch.
     */
    where: TaxSettingWhereUniqueInput
  }

  /**
   * TaxSetting findFirst
   */
  export type TaxSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSetting
     */
    select?: TaxSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSetting
     */
    omit?: TaxSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSettingInclude<ExtArgs> | null
    /**
     * Filter, which TaxSetting to fetch.
     */
    where?: TaxSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxSettings to fetch.
     */
    orderBy?: TaxSettingOrderByWithRelationInput | TaxSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxSettings.
     */
    cursor?: TaxSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxSettings.
     */
    distinct?: TaxSettingScalarFieldEnum | TaxSettingScalarFieldEnum[]
  }

  /**
   * TaxSetting findFirstOrThrow
   */
  export type TaxSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSetting
     */
    select?: TaxSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSetting
     */
    omit?: TaxSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSettingInclude<ExtArgs> | null
    /**
     * Filter, which TaxSetting to fetch.
     */
    where?: TaxSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxSettings to fetch.
     */
    orderBy?: TaxSettingOrderByWithRelationInput | TaxSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxSettings.
     */
    cursor?: TaxSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxSettings.
     */
    distinct?: TaxSettingScalarFieldEnum | TaxSettingScalarFieldEnum[]
  }

  /**
   * TaxSetting findMany
   */
  export type TaxSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSetting
     */
    select?: TaxSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSetting
     */
    omit?: TaxSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSettingInclude<ExtArgs> | null
    /**
     * Filter, which TaxSettings to fetch.
     */
    where?: TaxSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxSettings to fetch.
     */
    orderBy?: TaxSettingOrderByWithRelationInput | TaxSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaxSettings.
     */
    cursor?: TaxSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxSettings.
     */
    skip?: number
    distinct?: TaxSettingScalarFieldEnum | TaxSettingScalarFieldEnum[]
  }

  /**
   * TaxSetting create
   */
  export type TaxSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSetting
     */
    select?: TaxSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSetting
     */
    omit?: TaxSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSettingInclude<ExtArgs> | null
    /**
     * The data needed to create a TaxSetting.
     */
    data: XOR<TaxSettingCreateInput, TaxSettingUncheckedCreateInput>
  }

  /**
   * TaxSetting createMany
   */
  export type TaxSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaxSettings.
     */
    data: TaxSettingCreateManyInput | TaxSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaxSetting createManyAndReturn
   */
  export type TaxSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSetting
     */
    select?: TaxSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSetting
     */
    omit?: TaxSettingOmit<ExtArgs> | null
    /**
     * The data used to create many TaxSettings.
     */
    data: TaxSettingCreateManyInput | TaxSettingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSettingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaxSetting update
   */
  export type TaxSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSetting
     */
    select?: TaxSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSetting
     */
    omit?: TaxSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSettingInclude<ExtArgs> | null
    /**
     * The data needed to update a TaxSetting.
     */
    data: XOR<TaxSettingUpdateInput, TaxSettingUncheckedUpdateInput>
    /**
     * Choose, which TaxSetting to update.
     */
    where: TaxSettingWhereUniqueInput
  }

  /**
   * TaxSetting updateMany
   */
  export type TaxSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaxSettings.
     */
    data: XOR<TaxSettingUpdateManyMutationInput, TaxSettingUncheckedUpdateManyInput>
    /**
     * Filter which TaxSettings to update
     */
    where?: TaxSettingWhereInput
    /**
     * Limit how many TaxSettings to update.
     */
    limit?: number
  }

  /**
   * TaxSetting updateManyAndReturn
   */
  export type TaxSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSetting
     */
    select?: TaxSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSetting
     */
    omit?: TaxSettingOmit<ExtArgs> | null
    /**
     * The data used to update TaxSettings.
     */
    data: XOR<TaxSettingUpdateManyMutationInput, TaxSettingUncheckedUpdateManyInput>
    /**
     * Filter which TaxSettings to update
     */
    where?: TaxSettingWhereInput
    /**
     * Limit how many TaxSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSettingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaxSetting upsert
   */
  export type TaxSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSetting
     */
    select?: TaxSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSetting
     */
    omit?: TaxSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSettingInclude<ExtArgs> | null
    /**
     * The filter to search for the TaxSetting to update in case it exists.
     */
    where: TaxSettingWhereUniqueInput
    /**
     * In case the TaxSetting found by the `where` argument doesn't exist, create a new TaxSetting with this data.
     */
    create: XOR<TaxSettingCreateInput, TaxSettingUncheckedCreateInput>
    /**
     * In case the TaxSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaxSettingUpdateInput, TaxSettingUncheckedUpdateInput>
  }

  /**
   * TaxSetting delete
   */
  export type TaxSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSetting
     */
    select?: TaxSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSetting
     */
    omit?: TaxSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSettingInclude<ExtArgs> | null
    /**
     * Filter which TaxSetting to delete.
     */
    where: TaxSettingWhereUniqueInput
  }

  /**
   * TaxSetting deleteMany
   */
  export type TaxSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxSettings to delete
     */
    where?: TaxSettingWhereInput
    /**
     * Limit how many TaxSettings to delete.
     */
    limit?: number
  }

  /**
   * TaxSetting.branch
   */
  export type TaxSetting$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * TaxSetting without action
   */
  export type TaxSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSetting
     */
    select?: TaxSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSetting
     */
    omit?: TaxSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSettingInclude<ExtArgs> | null
  }


  /**
   * Model SystemSetting
   */

  export type AggregateSystemSetting = {
    _count: SystemSettingCountAggregateOutputType | null
    _avg: SystemSettingAvgAggregateOutputType | null
    _sum: SystemSettingSumAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  export type SystemSettingAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type SystemSettingSumAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type SystemSettingMinAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
    type: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSettingMaxAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
    type: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    type: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemSettingAvgAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type SystemSettingSumAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type SystemSettingMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSettingMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSetting to aggregate.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemSettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemSettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingMaxAggregateInputType
  }

  export type GetSystemSettingAggregateType<T extends SystemSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSetting[P]>
      : GetScalarType<T[P], AggregateSystemSetting[P]>
  }




  export type SystemSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingWhereInput
    orderBy?: SystemSettingOrderByWithAggregationInput | SystemSettingOrderByWithAggregationInput[]
    by: SystemSettingScalarFieldEnum[] | SystemSettingScalarFieldEnum
    having?: SystemSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingCountAggregateInputType | true
    _avg?: SystemSettingAvgAggregateInputType
    _sum?: SystemSettingSumAggregateInputType
    _min?: SystemSettingMinAggregateInputType
    _max?: SystemSettingMaxAggregateInputType
  }

  export type SystemSettingGroupByOutputType = {
    id: number
    key: string
    value: string
    type: string
    companyId: number
    createdAt: Date
    updatedAt: Date
    _count: SystemSettingCountAggregateOutputType | null
    _avg: SystemSettingAvgAggregateOutputType | null
    _sum: SystemSettingSumAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  type GetSystemSettingGroupByPayload<T extends SystemSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SystemSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "type" | "companyId" | "createdAt" | "updatedAt", ExtArgs["result"]["systemSetting"]>
  export type SystemSettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type SystemSettingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type SystemSettingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $SystemSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSetting"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      key: string
      value: string
      type: string
      companyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemSetting"]>
    composites: {}
  }

  type SystemSettingGetPayload<S extends boolean | null | undefined | SystemSettingDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingPayload, S>

  type SystemSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemSettingCountAggregateInputType | true
    }

  export interface SystemSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSetting'], meta: { name: 'SystemSetting' } }
    /**
     * Find zero or one SystemSetting that matches the filter.
     * @param {SystemSettingFindUniqueArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingFindUniqueArgs>(args: SelectSubset<T, SystemSettingFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemSettingFindUniqueOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingFindFirstArgs>(args?: SelectSubset<T, SystemSettingFindFirstArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingFindManyArgs>(args?: SelectSubset<T, SystemSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemSetting.
     * @param {SystemSettingCreateArgs} args - Arguments to create a SystemSetting.
     * @example
     * // Create one SystemSetting
     * const SystemSetting = await prisma.systemSetting.create({
     *   data: {
     *     // ... data to create a SystemSetting
     *   }
     * })
     * 
     */
    create<T extends SystemSettingCreateArgs>(args: SelectSubset<T, SystemSettingCreateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingCreateManyArgs>(args?: SelectSubset<T, SystemSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemSettings and returns the data saved in the database.
     * @param {SystemSettingCreateManyAndReturnArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemSettings and only return the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemSetting.
     * @param {SystemSettingDeleteArgs} args - Arguments to delete one SystemSetting.
     * @example
     * // Delete one SystemSetting
     * const SystemSetting = await prisma.systemSetting.delete({
     *   where: {
     *     // ... filter to delete one SystemSetting
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingDeleteArgs>(args: SelectSubset<T, SystemSettingDeleteArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemSetting.
     * @param {SystemSettingUpdateArgs} args - Arguments to update one SystemSetting.
     * @example
     * // Update one SystemSetting
     * const systemSetting = await prisma.systemSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingUpdateArgs>(args: SelectSubset<T, SystemSettingUpdateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingDeleteManyArgs>(args?: SelectSubset<T, SystemSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingUpdateManyArgs>(args: SelectSubset<T, SystemSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings and returns the data updated in the database.
     * @param {SystemSettingUpdateManyAndReturnArgs} args - Arguments to update many SystemSettings.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemSettings and only return the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemSetting.
     * @param {SystemSettingUpsertArgs} args - Arguments to update or create a SystemSetting.
     * @example
     * // Update or create a SystemSetting
     * const systemSetting = await prisma.systemSetting.upsert({
     *   create: {
     *     // ... data to create a SystemSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSetting we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingUpsertArgs>(args: SelectSubset<T, SystemSettingUpsertArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSetting.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingCountArgs>(
      args?: Subset<T, SystemSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingAggregateArgs>(args: Subset<T, SystemSettingAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingAggregateType<T>>

    /**
     * Group by SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSetting model
   */
  readonly fields: SystemSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSetting model
   */
  interface SystemSettingFieldRefs {
    readonly id: FieldRef<"SystemSetting", 'Int'>
    readonly key: FieldRef<"SystemSetting", 'String'>
    readonly value: FieldRef<"SystemSetting", 'String'>
    readonly type: FieldRef<"SystemSetting", 'String'>
    readonly companyId: FieldRef<"SystemSetting", 'Int'>
    readonly createdAt: FieldRef<"SystemSetting", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemSetting findUnique
   */
  export type SystemSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findUniqueOrThrow
   */
  export type SystemSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findFirst
   */
  export type SystemSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findFirstOrThrow
   */
  export type SystemSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findMany
   */
  export type SystemSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting create
   */
  export type SystemSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * The data needed to create a SystemSetting.
     */
    data: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
  }

  /**
   * SystemSetting createMany
   */
  export type SystemSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting createManyAndReturn
   */
  export type SystemSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SystemSetting update
   */
  export type SystemSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * The data needed to update a SystemSetting.
     */
    data: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
    /**
     * Choose, which SystemSetting to update.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting updateMany
   */
  export type SystemSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSetting updateManyAndReturn
   */
  export type SystemSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SystemSetting upsert
   */
  export type SystemSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * The filter to search for the SystemSetting to update in case it exists.
     */
    where: SystemSettingWhereUniqueInput
    /**
     * In case the SystemSetting found by the `where` argument doesn't exist, create a new SystemSetting with this data.
     */
    create: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
    /**
     * In case the SystemSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
  }

  /**
   * SystemSetting delete
   */
  export type SystemSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * Filter which SystemSetting to delete.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting deleteMany
   */
  export type SystemSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to delete.
     */
    limit?: number
  }

  /**
   * SystemSetting without action
   */
  export type SystemSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    password: string | null
    role: $Enums.Role | null
    companyId: number | null
    branch: string | null
    department: string | null
    region: string | null
    division: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    password: string | null
    role: $Enums.Role | null
    companyId: number | null
    branch: string | null
    department: string | null
    region: string | null
    division: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    role: number
    companyId: number
    branch: number
    department: number
    region: number
    division: number
    resetToken: number
    resetTokenExpiry: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    companyId?: true
    branch?: true
    department?: true
    region?: true
    division?: true
    resetToken?: true
    resetTokenExpiry?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    companyId?: true
    branch?: true
    department?: true
    region?: true
    division?: true
    resetToken?: true
    resetTokenExpiry?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    companyId?: true
    branch?: true
    department?: true
    region?: true
    division?: true
    resetToken?: true
    resetTokenExpiry?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    name: string | null
    password: string
    role: $Enums.Role
    companyId: number | null
    branch: string | null
    department: string | null
    region: string | null
    division: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    companyId?: boolean
    branch?: boolean
    department?: boolean
    region?: boolean
    division?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    company?: boolean | User$companyArgs<ExtArgs>
    postedVouchers?: boolean | User$postedVouchersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    companyId?: boolean
    branch?: boolean
    department?: boolean
    region?: boolean
    division?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | User$companyArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    companyId?: boolean
    branch?: boolean
    department?: boolean
    region?: boolean
    division?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | User$companyArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    companyId?: boolean
    branch?: boolean
    department?: boolean
    region?: boolean
    division?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "password" | "role" | "companyId" | "branch" | "department" | "region" | "division" | "resetToken" | "resetTokenExpiry" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    company?: boolean | User$companyArgs<ExtArgs>
    postedVouchers?: boolean | User$postedVouchersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | User$companyArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | User$companyArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs> | null
      postedVouchers: Prisma.$VoucherPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      name: string | null
      password: string
      role: $Enums.Role
      companyId: number | null
      branch: string | null
      department: string | null
      region: string | null
      division: string | null
      resetToken: string | null
      resetTokenExpiry: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    company<T extends User$companyArgs<ExtArgs> = {}>(args?: Subset<T, User$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    postedVouchers<T extends User$postedVouchersArgs<ExtArgs> = {}>(args?: Subset<T, User$postedVouchersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly companyId: FieldRef<"User", 'Int'>
    readonly branch: FieldRef<"User", 'String'>
    readonly department: FieldRef<"User", 'String'>
    readonly region: FieldRef<"User", 'String'>
    readonly division: FieldRef<"User", 'String'>
    readonly resetToken: FieldRef<"User", 'String'>
    readonly resetTokenExpiry: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.company
   */
  export type User$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * User.postedVouchers
   */
  export type User$postedVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    where?: VoucherWhereInput
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    cursor?: VoucherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    id: number | null
    accountId: number | null
    companyId: number | null
  }

  export type CustomerSumAggregateOutputType = {
    id: number | null
    accountId: number | null
    companyId: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    address: string | null
    phone: string | null
    email: string | null
    taxNumber: string | null
    accountId: number | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    division: string | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    address: string | null
    phone: string | null
    email: string | null
    taxNumber: string | null
    accountId: number | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    division: string | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    code: number
    address: number
    phone: number
    email: number
    taxNumber: number
    accountId: number
    companyId: number
    createdAt: number
    updatedAt: number
    division: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    id?: true
    accountId?: true
    companyId?: true
  }

  export type CustomerSumAggregateInputType = {
    id?: true
    accountId?: true
    companyId?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    address?: true
    phone?: true
    email?: true
    taxNumber?: true
    accountId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    division?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    address?: true
    phone?: true
    email?: true
    taxNumber?: true
    accountId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    division?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    address?: true
    phone?: true
    email?: true
    taxNumber?: true
    accountId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    division?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: number
    name: string
    code: string
    address: string | null
    phone: string | null
    email: string | null
    taxNumber: string | null
    accountId: number | null
    companyId: number
    createdAt: Date
    updatedAt: Date
    division: string | null
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    taxNumber?: boolean
    accountId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    division?: boolean
    account?: boolean | Customer$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    serviceInvoices?: boolean | Customer$serviceInvoicesArgs<ExtArgs>
    freightInvoices?: boolean | Customer$freightInvoicesArgs<ExtArgs>
    jobs?: boolean | Customer$jobsArgs<ExtArgs>
    payments?: boolean | Customer$paymentsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    taxNumber?: boolean
    accountId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    division?: boolean
    account?: boolean | Customer$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    taxNumber?: boolean
    accountId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    division?: boolean
    account?: boolean | Customer$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    taxNumber?: boolean
    accountId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    division?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "address" | "phone" | "email" | "taxNumber" | "accountId" | "companyId" | "createdAt" | "updatedAt" | "division", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | Customer$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    serviceInvoices?: boolean | Customer$serviceInvoicesArgs<ExtArgs>
    freightInvoices?: boolean | Customer$freightInvoicesArgs<ExtArgs>
    jobs?: boolean | Customer$jobsArgs<ExtArgs>
    payments?: boolean | Customer$paymentsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | Customer$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | Customer$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
      serviceInvoices: Prisma.$ServiceInvoicePayload<ExtArgs>[]
      freightInvoices: Prisma.$FreightInvoicePayload<ExtArgs>[]
      jobs: Prisma.$JobPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      code: string
      address: string | null
      phone: string | null
      email: string | null
      taxNumber: string | null
      accountId: number | null
      companyId: number
      createdAt: Date
      updatedAt: Date
      division: string | null
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends Customer$accountArgs<ExtArgs> = {}>(args?: Subset<T, Customer$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceInvoices<T extends Customer$serviceInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$serviceInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    freightInvoices<T extends Customer$freightInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$freightInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreightInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jobs<T extends Customer$jobsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Customer$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'Int'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly code: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly taxNumber: FieldRef<"Customer", 'String'>
    readonly accountId: FieldRef<"Customer", 'Int'>
    readonly companyId: FieldRef<"Customer", 'Int'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
    readonly division: FieldRef<"Customer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.account
   */
  export type Customer$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Customer.serviceInvoices
   */
  export type Customer$serviceInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoice
     */
    select?: ServiceInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoice
     */
    omit?: ServiceInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceInclude<ExtArgs> | null
    where?: ServiceInvoiceWhereInput
    orderBy?: ServiceInvoiceOrderByWithRelationInput | ServiceInvoiceOrderByWithRelationInput[]
    cursor?: ServiceInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceInvoiceScalarFieldEnum | ServiceInvoiceScalarFieldEnum[]
  }

  /**
   * Customer.freightInvoices
   */
  export type Customer$freightInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoice
     */
    select?: FreightInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoice
     */
    omit?: FreightInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceInclude<ExtArgs> | null
    where?: FreightInvoiceWhereInput
    orderBy?: FreightInvoiceOrderByWithRelationInput | FreightInvoiceOrderByWithRelationInput[]
    cursor?: FreightInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FreightInvoiceScalarFieldEnum | FreightInvoiceScalarFieldEnum[]
  }

  /**
   * Customer.jobs
   */
  export type Customer$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    cursor?: JobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Customer.payments
   */
  export type Customer$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Vendor
   */

  export type AggregateVendor = {
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  export type VendorAvgAggregateOutputType = {
    id: number | null
    accountId: number | null
    companyId: number | null
  }

  export type VendorSumAggregateOutputType = {
    id: number | null
    accountId: number | null
    companyId: number | null
  }

  export type VendorMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    type: string | null
    address: string | null
    phone: string | null
    email: string | null
    taxNumber: string | null
    accountId: number | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    division: string | null
  }

  export type VendorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    type: string | null
    address: string | null
    phone: string | null
    email: string | null
    taxNumber: string | null
    accountId: number | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    division: string | null
  }

  export type VendorCountAggregateOutputType = {
    id: number
    name: number
    code: number
    type: number
    address: number
    phone: number
    email: number
    taxNumber: number
    accountId: number
    companyId: number
    createdAt: number
    updatedAt: number
    division: number
    _all: number
  }


  export type VendorAvgAggregateInputType = {
    id?: true
    accountId?: true
    companyId?: true
  }

  export type VendorSumAggregateInputType = {
    id?: true
    accountId?: true
    companyId?: true
  }

  export type VendorMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    type?: true
    address?: true
    phone?: true
    email?: true
    taxNumber?: true
    accountId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    division?: true
  }

  export type VendorMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    type?: true
    address?: true
    phone?: true
    email?: true
    taxNumber?: true
    accountId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    division?: true
  }

  export type VendorCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    type?: true
    address?: true
    phone?: true
    email?: true
    taxNumber?: true
    accountId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    division?: true
    _all?: true
  }

  export type VendorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendor to aggregate.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendors
    **/
    _count?: true | VendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorMaxAggregateInputType
  }

  export type GetVendorAggregateType<T extends VendorAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor[P]>
      : GetScalarType<T[P], AggregateVendor[P]>
  }




  export type VendorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithAggregationInput | VendorOrderByWithAggregationInput[]
    by: VendorScalarFieldEnum[] | VendorScalarFieldEnum
    having?: VendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorCountAggregateInputType | true
    _avg?: VendorAvgAggregateInputType
    _sum?: VendorSumAggregateInputType
    _min?: VendorMinAggregateInputType
    _max?: VendorMaxAggregateInputType
  }

  export type VendorGroupByOutputType = {
    id: number
    name: string
    code: string
    type: string | null
    address: string | null
    phone: string | null
    email: string | null
    taxNumber: string | null
    accountId: number | null
    companyId: number
    createdAt: Date
    updatedAt: Date
    division: string | null
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  type GetVendorGroupByPayload<T extends VendorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorGroupByOutputType[P]>
            : GetScalarType<T[P], VendorGroupByOutputType[P]>
        }
      >
    >


  export type VendorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    type?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    taxNumber?: boolean
    accountId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    division?: boolean
    expenses?: boolean | Vendor$expensesArgs<ExtArgs>
    payments?: boolean | Vendor$paymentsArgs<ExtArgs>
    purchaseInvoices?: boolean | Vendor$purchaseInvoicesArgs<ExtArgs>
    account?: boolean | Vendor$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    freightItems?: boolean | Vendor$freightItemsArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    type?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    taxNumber?: boolean
    accountId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    division?: boolean
    account?: boolean | Vendor$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    type?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    taxNumber?: boolean
    accountId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    division?: boolean
    account?: boolean | Vendor$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    type?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    taxNumber?: boolean
    accountId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    division?: boolean
  }

  export type VendorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "type" | "address" | "phone" | "email" | "taxNumber" | "accountId" | "companyId" | "createdAt" | "updatedAt" | "division", ExtArgs["result"]["vendor"]>
  export type VendorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expenses?: boolean | Vendor$expensesArgs<ExtArgs>
    payments?: boolean | Vendor$paymentsArgs<ExtArgs>
    purchaseInvoices?: boolean | Vendor$purchaseInvoicesArgs<ExtArgs>
    account?: boolean | Vendor$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    freightItems?: boolean | Vendor$freightItemsArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VendorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | Vendor$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type VendorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | Vendor$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $VendorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vendor"
    objects: {
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      purchaseInvoices: Prisma.$PurchaseInvoicePayload<ExtArgs>[]
      account: Prisma.$AccountPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
      freightItems: Prisma.$FreightInvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      code: string
      type: string | null
      address: string | null
      phone: string | null
      email: string | null
      taxNumber: string | null
      accountId: number | null
      companyId: number
      createdAt: Date
      updatedAt: Date
      division: string | null
    }, ExtArgs["result"]["vendor"]>
    composites: {}
  }

  type VendorGetPayload<S extends boolean | null | undefined | VendorDefaultArgs> = $Result.GetResult<Prisma.$VendorPayload, S>

  type VendorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorCountAggregateInputType | true
    }

  export interface VendorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vendor'], meta: { name: 'Vendor' } }
    /**
     * Find zero or one Vendor that matches the filter.
     * @param {VendorFindUniqueArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorFindUniqueArgs>(args: SelectSubset<T, VendorFindUniqueArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vendor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorFindUniqueOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorFindFirstArgs>(args?: SelectSubset<T, VendorFindFirstArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendor.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorWithIdOnly = await prisma.vendor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorFindManyArgs>(args?: SelectSubset<T, VendorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vendor.
     * @param {VendorCreateArgs} args - Arguments to create a Vendor.
     * @example
     * // Create one Vendor
     * const Vendor = await prisma.vendor.create({
     *   data: {
     *     // ... data to create a Vendor
     *   }
     * })
     * 
     */
    create<T extends VendorCreateArgs>(args: SelectSubset<T, VendorCreateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vendors.
     * @param {VendorCreateManyArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorCreateManyArgs>(args?: SelectSubset<T, VendorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vendors and returns the data saved in the database.
     * @param {VendorCreateManyAndReturnArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vendors and only return the `id`
     * const vendorWithIdOnly = await prisma.vendor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vendor.
     * @param {VendorDeleteArgs} args - Arguments to delete one Vendor.
     * @example
     * // Delete one Vendor
     * const Vendor = await prisma.vendor.delete({
     *   where: {
     *     // ... filter to delete one Vendor
     *   }
     * })
     * 
     */
    delete<T extends VendorDeleteArgs>(args: SelectSubset<T, VendorDeleteArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vendor.
     * @param {VendorUpdateArgs} args - Arguments to update one Vendor.
     * @example
     * // Update one Vendor
     * const vendor = await prisma.vendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorUpdateArgs>(args: SelectSubset<T, VendorUpdateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vendors.
     * @param {VendorDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorDeleteManyArgs>(args?: SelectSubset<T, VendorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorUpdateManyArgs>(args: SelectSubset<T, VendorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors and returns the data updated in the database.
     * @param {VendorUpdateManyAndReturnArgs} args - Arguments to update many Vendors.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vendors and only return the `id`
     * const vendorWithIdOnly = await prisma.vendor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vendor.
     * @param {VendorUpsertArgs} args - Arguments to update or create a Vendor.
     * @example
     * // Update or create a Vendor
     * const vendor = await prisma.vendor.upsert({
     *   create: {
     *     // ... data to create a Vendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor we want to update
     *   }
     * })
     */
    upsert<T extends VendorUpsertArgs>(args: SelectSubset<T, VendorUpsertArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendor.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends VendorCountArgs>(
      args?: Subset<T, VendorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAggregateArgs>(args: Subset<T, VendorAggregateArgs>): Prisma.PrismaPromise<GetVendorAggregateType<T>>

    /**
     * Group by Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorGroupByArgs['orderBy'] }
        : { orderBy?: VendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vendor model
   */
  readonly fields: VendorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    expenses<T extends Vendor$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Vendor$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseInvoices<T extends Vendor$purchaseInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$purchaseInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    account<T extends Vendor$accountArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    freightItems<T extends Vendor$freightItemsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$freightItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreightInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vendor model
   */
  interface VendorFieldRefs {
    readonly id: FieldRef<"Vendor", 'Int'>
    readonly name: FieldRef<"Vendor", 'String'>
    readonly code: FieldRef<"Vendor", 'String'>
    readonly type: FieldRef<"Vendor", 'String'>
    readonly address: FieldRef<"Vendor", 'String'>
    readonly phone: FieldRef<"Vendor", 'String'>
    readonly email: FieldRef<"Vendor", 'String'>
    readonly taxNumber: FieldRef<"Vendor", 'String'>
    readonly accountId: FieldRef<"Vendor", 'Int'>
    readonly companyId: FieldRef<"Vendor", 'Int'>
    readonly createdAt: FieldRef<"Vendor", 'DateTime'>
    readonly updatedAt: FieldRef<"Vendor", 'DateTime'>
    readonly division: FieldRef<"Vendor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Vendor findUnique
   */
  export type VendorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findUniqueOrThrow
   */
  export type VendorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findFirst
   */
  export type VendorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findFirstOrThrow
   */
  export type VendorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findMany
   */
  export type VendorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendors to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor create
   */
  export type VendorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to create a Vendor.
     */
    data: XOR<VendorCreateInput, VendorUncheckedCreateInput>
  }

  /**
   * Vendor createMany
   */
  export type VendorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vendor createManyAndReturn
   */
  export type VendorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vendor update
   */
  export type VendorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to update a Vendor.
     */
    data: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
    /**
     * Choose, which Vendor to update.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor updateMany
   */
  export type VendorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to update.
     */
    limit?: number
  }

  /**
   * Vendor updateManyAndReturn
   */
  export type VendorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vendor upsert
   */
  export type VendorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The filter to search for the Vendor to update in case it exists.
     */
    where: VendorWhereUniqueInput
    /**
     * In case the Vendor found by the `where` argument doesn't exist, create a new Vendor with this data.
     */
    create: XOR<VendorCreateInput, VendorUncheckedCreateInput>
    /**
     * In case the Vendor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
  }

  /**
   * Vendor delete
   */
  export type VendorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter which Vendor to delete.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor deleteMany
   */
  export type VendorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendors to delete
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to delete.
     */
    limit?: number
  }

  /**
   * Vendor.expenses
   */
  export type Vendor$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Vendor.payments
   */
  export type Vendor$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Vendor.purchaseInvoices
   */
  export type Vendor$purchaseInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    where?: PurchaseInvoiceWhereInput
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    cursor?: PurchaseInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseInvoiceScalarFieldEnum | PurchaseInvoiceScalarFieldEnum[]
  }

  /**
   * Vendor.account
   */
  export type Vendor$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Vendor.freightItems
   */
  export type Vendor$freightItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoiceItem
     */
    select?: FreightInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoiceItem
     */
    omit?: FreightInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceItemInclude<ExtArgs> | null
    where?: FreightInvoiceItemWhereInput
    orderBy?: FreightInvoiceItemOrderByWithRelationInput | FreightInvoiceItemOrderByWithRelationInput[]
    cursor?: FreightInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FreightInvoiceItemScalarFieldEnum | FreightInvoiceItemScalarFieldEnum[]
  }

  /**
   * Vendor without action
   */
  export type VendorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
  }


  /**
   * Model Job
   */

  export type AggregateJob = {
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  export type JobAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    podId: number | null
    packages: number | null
    weight: number | null
    companyId: number | null
    branchId: number | null
  }

  export type JobSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    podId: number | null
    packages: number | null
    weight: number | null
    companyId: number | null
    branchId: number | null
  }

  export type JobMinAggregateOutputType = {
    id: number | null
    jobNumber: string | null
    date: Date | null
    jobDate: Date | null
    jobType: $Enums.JobType | null
    status: $Enums.JobStatus | null
    customerId: number | null
    vessel: string | null
    place: string | null
    shipperRef: string | null
    gdNo: string | null
    gdDate: Date | null
    formE: string | null
    formEDate: Date | null
    commodity: string | null
    volume: string | null
    containerNo: string | null
    podId: number | null
    packages: number | null
    weight: number | null
    hawbBl: string | null
    handledBy: string | null
    salesPerson: string | null
    companyId: number | null
    branchId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    division: string | null
  }

  export type JobMaxAggregateOutputType = {
    id: number | null
    jobNumber: string | null
    date: Date | null
    jobDate: Date | null
    jobType: $Enums.JobType | null
    status: $Enums.JobStatus | null
    customerId: number | null
    vessel: string | null
    place: string | null
    shipperRef: string | null
    gdNo: string | null
    gdDate: Date | null
    formE: string | null
    formEDate: Date | null
    commodity: string | null
    volume: string | null
    containerNo: string | null
    podId: number | null
    packages: number | null
    weight: number | null
    hawbBl: string | null
    handledBy: string | null
    salesPerson: string | null
    companyId: number | null
    branchId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    division: string | null
  }

  export type JobCountAggregateOutputType = {
    id: number
    jobNumber: number
    date: number
    jobDate: number
    jobType: number
    status: number
    customerId: number
    vessel: number
    place: number
    shipperRef: number
    gdNo: number
    gdDate: number
    formE: number
    formEDate: number
    commodity: number
    volume: number
    containerNo: number
    podId: number
    packages: number
    weight: number
    hawbBl: number
    handledBy: number
    salesPerson: number
    companyId: number
    branchId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    division: number
    _all: number
  }


  export type JobAvgAggregateInputType = {
    id?: true
    customerId?: true
    podId?: true
    packages?: true
    weight?: true
    companyId?: true
    branchId?: true
  }

  export type JobSumAggregateInputType = {
    id?: true
    customerId?: true
    podId?: true
    packages?: true
    weight?: true
    companyId?: true
    branchId?: true
  }

  export type JobMinAggregateInputType = {
    id?: true
    jobNumber?: true
    date?: true
    jobDate?: true
    jobType?: true
    status?: true
    customerId?: true
    vessel?: true
    place?: true
    shipperRef?: true
    gdNo?: true
    gdDate?: true
    formE?: true
    formEDate?: true
    commodity?: true
    volume?: true
    containerNo?: true
    podId?: true
    packages?: true
    weight?: true
    hawbBl?: true
    handledBy?: true
    salesPerson?: true
    companyId?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    division?: true
  }

  export type JobMaxAggregateInputType = {
    id?: true
    jobNumber?: true
    date?: true
    jobDate?: true
    jobType?: true
    status?: true
    customerId?: true
    vessel?: true
    place?: true
    shipperRef?: true
    gdNo?: true
    gdDate?: true
    formE?: true
    formEDate?: true
    commodity?: true
    volume?: true
    containerNo?: true
    podId?: true
    packages?: true
    weight?: true
    hawbBl?: true
    handledBy?: true
    salesPerson?: true
    companyId?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    division?: true
  }

  export type JobCountAggregateInputType = {
    id?: true
    jobNumber?: true
    date?: true
    jobDate?: true
    jobType?: true
    status?: true
    customerId?: true
    vessel?: true
    place?: true
    shipperRef?: true
    gdNo?: true
    gdDate?: true
    formE?: true
    formEDate?: true
    commodity?: true
    volume?: true
    containerNo?: true
    podId?: true
    packages?: true
    weight?: true
    hawbBl?: true
    handledBy?: true
    salesPerson?: true
    companyId?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    division?: true
    _all?: true
  }

  export type JobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Job to aggregate.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Jobs
    **/
    _count?: true | JobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobMaxAggregateInputType
  }

  export type GetJobAggregateType<T extends JobAggregateArgs> = {
        [P in keyof T & keyof AggregateJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob[P]>
      : GetScalarType<T[P], AggregateJob[P]>
  }




  export type JobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
    orderBy?: JobOrderByWithAggregationInput | JobOrderByWithAggregationInput[]
    by: JobScalarFieldEnum[] | JobScalarFieldEnum
    having?: JobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobCountAggregateInputType | true
    _avg?: JobAvgAggregateInputType
    _sum?: JobSumAggregateInputType
    _min?: JobMinAggregateInputType
    _max?: JobMaxAggregateInputType
  }

  export type JobGroupByOutputType = {
    id: number
    jobNumber: string
    date: Date
    jobDate: Date
    jobType: $Enums.JobType
    status: $Enums.JobStatus
    customerId: number
    vessel: string | null
    place: string | null
    shipperRef: string | null
    gdNo: string | null
    gdDate: Date | null
    formE: string | null
    formEDate: Date | null
    commodity: string | null
    volume: string | null
    containerNo: string | null
    podId: number | null
    packages: number | null
    weight: number | null
    hawbBl: string | null
    handledBy: string | null
    salesPerson: string | null
    companyId: number
    branchId: number | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    division: string | null
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  type GetJobGroupByPayload<T extends JobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobGroupByOutputType[P]>
            : GetScalarType<T[P], JobGroupByOutputType[P]>
        }
      >
    >


  export type JobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobNumber?: boolean
    date?: boolean
    jobDate?: boolean
    jobType?: boolean
    status?: boolean
    customerId?: boolean
    vessel?: boolean
    place?: boolean
    shipperRef?: boolean
    gdNo?: boolean
    gdDate?: boolean
    formE?: boolean
    formEDate?: boolean
    commodity?: boolean
    volume?: boolean
    containerNo?: boolean
    podId?: boolean
    packages?: boolean
    weight?: boolean
    hawbBl?: boolean
    handledBy?: boolean
    salesPerson?: boolean
    companyId?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    division?: boolean
    expenses?: boolean | Job$expensesArgs<ExtArgs>
    serviceInvoice?: boolean | Job$serviceInvoiceArgs<ExtArgs>
    freightInvoice?: boolean | Job$freightInvoiceArgs<ExtArgs>
    branch?: boolean | Job$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    pod?: boolean | Job$podArgs<ExtArgs>
    _count?: boolean | JobCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type JobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobNumber?: boolean
    date?: boolean
    jobDate?: boolean
    jobType?: boolean
    status?: boolean
    customerId?: boolean
    vessel?: boolean
    place?: boolean
    shipperRef?: boolean
    gdNo?: boolean
    gdDate?: boolean
    formE?: boolean
    formEDate?: boolean
    commodity?: boolean
    volume?: boolean
    containerNo?: boolean
    podId?: boolean
    packages?: boolean
    weight?: boolean
    hawbBl?: boolean
    handledBy?: boolean
    salesPerson?: boolean
    companyId?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    division?: boolean
    branch?: boolean | Job$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    pod?: boolean | Job$podArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type JobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobNumber?: boolean
    date?: boolean
    jobDate?: boolean
    jobType?: boolean
    status?: boolean
    customerId?: boolean
    vessel?: boolean
    place?: boolean
    shipperRef?: boolean
    gdNo?: boolean
    gdDate?: boolean
    formE?: boolean
    formEDate?: boolean
    commodity?: boolean
    volume?: boolean
    containerNo?: boolean
    podId?: boolean
    packages?: boolean
    weight?: boolean
    hawbBl?: boolean
    handledBy?: boolean
    salesPerson?: boolean
    companyId?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    division?: boolean
    branch?: boolean | Job$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    pod?: boolean | Job$podArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type JobSelectScalar = {
    id?: boolean
    jobNumber?: boolean
    date?: boolean
    jobDate?: boolean
    jobType?: boolean
    status?: boolean
    customerId?: boolean
    vessel?: boolean
    place?: boolean
    shipperRef?: boolean
    gdNo?: boolean
    gdDate?: boolean
    formE?: boolean
    formEDate?: boolean
    commodity?: boolean
    volume?: boolean
    containerNo?: boolean
    podId?: boolean
    packages?: boolean
    weight?: boolean
    hawbBl?: boolean
    handledBy?: boolean
    salesPerson?: boolean
    companyId?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    division?: boolean
  }

  export type JobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobNumber" | "date" | "jobDate" | "jobType" | "status" | "customerId" | "vessel" | "place" | "shipperRef" | "gdNo" | "gdDate" | "formE" | "formEDate" | "commodity" | "volume" | "containerNo" | "podId" | "packages" | "weight" | "hawbBl" | "handledBy" | "salesPerson" | "companyId" | "branchId" | "createdAt" | "updatedAt" | "deletedAt" | "division", ExtArgs["result"]["job"]>
  export type JobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expenses?: boolean | Job$expensesArgs<ExtArgs>
    serviceInvoice?: boolean | Job$serviceInvoiceArgs<ExtArgs>
    freightInvoice?: boolean | Job$freightInvoiceArgs<ExtArgs>
    branch?: boolean | Job$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    pod?: boolean | Job$podArgs<ExtArgs>
    _count?: boolean | JobCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Job$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    pod?: boolean | Job$podArgs<ExtArgs>
  }
  export type JobIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Job$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    pod?: boolean | Job$podArgs<ExtArgs>
  }

  export type $JobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Job"
    objects: {
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      serviceInvoice: Prisma.$ServiceInvoicePayload<ExtArgs> | null
      freightInvoice: Prisma.$FreightInvoicePayload<ExtArgs> | null
      branch: Prisma.$BranchPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs>
      pod: Prisma.$PortPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      jobNumber: string
      date: Date
      jobDate: Date
      jobType: $Enums.JobType
      status: $Enums.JobStatus
      customerId: number
      vessel: string | null
      place: string | null
      shipperRef: string | null
      gdNo: string | null
      gdDate: Date | null
      formE: string | null
      formEDate: Date | null
      commodity: string | null
      volume: string | null
      containerNo: string | null
      podId: number | null
      packages: number | null
      weight: number | null
      hawbBl: string | null
      handledBy: string | null
      salesPerson: string | null
      companyId: number
      branchId: number | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      division: string | null
    }, ExtArgs["result"]["job"]>
    composites: {}
  }

  type JobGetPayload<S extends boolean | null | undefined | JobDefaultArgs> = $Result.GetResult<Prisma.$JobPayload, S>

  type JobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobCountAggregateInputType | true
    }

  export interface JobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Job'], meta: { name: 'Job' } }
    /**
     * Find zero or one Job that matches the filter.
     * @param {JobFindUniqueArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobFindUniqueArgs>(args: SelectSubset<T, JobFindUniqueArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobFindUniqueOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobFindUniqueOrThrowArgs>(args: SelectSubset<T, JobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindFirstArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobFindFirstArgs>(args?: SelectSubset<T, JobFindFirstArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindFirstOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobFindFirstOrThrowArgs>(args?: SelectSubset<T, JobFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.job.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.job.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobWithIdOnly = await prisma.job.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobFindManyArgs>(args?: SelectSubset<T, JobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job.
     * @param {JobCreateArgs} args - Arguments to create a Job.
     * @example
     * // Create one Job
     * const Job = await prisma.job.create({
     *   data: {
     *     // ... data to create a Job
     *   }
     * })
     * 
     */
    create<T extends JobCreateArgs>(args: SelectSubset<T, JobCreateArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Jobs.
     * @param {JobCreateManyArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const job = await prisma.job.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobCreateManyArgs>(args?: SelectSubset<T, JobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Jobs and returns the data saved in the database.
     * @param {JobCreateManyAndReturnArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const job = await prisma.job.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Jobs and only return the `id`
     * const jobWithIdOnly = await prisma.job.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobCreateManyAndReturnArgs>(args?: SelectSubset<T, JobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Job.
     * @param {JobDeleteArgs} args - Arguments to delete one Job.
     * @example
     * // Delete one Job
     * const Job = await prisma.job.delete({
     *   where: {
     *     // ... filter to delete one Job
     *   }
     * })
     * 
     */
    delete<T extends JobDeleteArgs>(args: SelectSubset<T, JobDeleteArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job.
     * @param {JobUpdateArgs} args - Arguments to update one Job.
     * @example
     * // Update one Job
     * const job = await prisma.job.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobUpdateArgs>(args: SelectSubset<T, JobUpdateArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Jobs.
     * @param {JobDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.job.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobDeleteManyArgs>(args?: SelectSubset<T, JobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const job = await prisma.job.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobUpdateManyArgs>(args: SelectSubset<T, JobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs and returns the data updated in the database.
     * @param {JobUpdateManyAndReturnArgs} args - Arguments to update many Jobs.
     * @example
     * // Update many Jobs
     * const job = await prisma.job.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Jobs and only return the `id`
     * const jobWithIdOnly = await prisma.job.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobUpdateManyAndReturnArgs>(args: SelectSubset<T, JobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Job.
     * @param {JobUpsertArgs} args - Arguments to update or create a Job.
     * @example
     * // Update or create a Job
     * const job = await prisma.job.upsert({
     *   create: {
     *     // ... data to create a Job
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job we want to update
     *   }
     * })
     */
    upsert<T extends JobUpsertArgs>(args: SelectSubset<T, JobUpsertArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.job.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends JobCountArgs>(
      args?: Subset<T, JobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobAggregateArgs>(args: Subset<T, JobAggregateArgs>): Prisma.PrismaPromise<GetJobAggregateType<T>>

    /**
     * Group by Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobGroupByArgs['orderBy'] }
        : { orderBy?: JobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Job model
   */
  readonly fields: JobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Job.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    expenses<T extends Job$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Job$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceInvoice<T extends Job$serviceInvoiceArgs<ExtArgs> = {}>(args?: Subset<T, Job$serviceInvoiceArgs<ExtArgs>>): Prisma__ServiceInvoiceClient<$Result.GetResult<Prisma.$ServiceInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    freightInvoice<T extends Job$freightInvoiceArgs<ExtArgs> = {}>(args?: Subset<T, Job$freightInvoiceArgs<ExtArgs>>): Prisma__FreightInvoiceClient<$Result.GetResult<Prisma.$FreightInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    branch<T extends Job$branchArgs<ExtArgs> = {}>(args?: Subset<T, Job$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pod<T extends Job$podArgs<ExtArgs> = {}>(args?: Subset<T, Job$podArgs<ExtArgs>>): Prisma__PortClient<$Result.GetResult<Prisma.$PortPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Job model
   */
  interface JobFieldRefs {
    readonly id: FieldRef<"Job", 'Int'>
    readonly jobNumber: FieldRef<"Job", 'String'>
    readonly date: FieldRef<"Job", 'DateTime'>
    readonly jobDate: FieldRef<"Job", 'DateTime'>
    readonly jobType: FieldRef<"Job", 'JobType'>
    readonly status: FieldRef<"Job", 'JobStatus'>
    readonly customerId: FieldRef<"Job", 'Int'>
    readonly vessel: FieldRef<"Job", 'String'>
    readonly place: FieldRef<"Job", 'String'>
    readonly shipperRef: FieldRef<"Job", 'String'>
    readonly gdNo: FieldRef<"Job", 'String'>
    readonly gdDate: FieldRef<"Job", 'DateTime'>
    readonly formE: FieldRef<"Job", 'String'>
    readonly formEDate: FieldRef<"Job", 'DateTime'>
    readonly commodity: FieldRef<"Job", 'String'>
    readonly volume: FieldRef<"Job", 'String'>
    readonly containerNo: FieldRef<"Job", 'String'>
    readonly podId: FieldRef<"Job", 'Int'>
    readonly packages: FieldRef<"Job", 'Int'>
    readonly weight: FieldRef<"Job", 'Float'>
    readonly hawbBl: FieldRef<"Job", 'String'>
    readonly handledBy: FieldRef<"Job", 'String'>
    readonly salesPerson: FieldRef<"Job", 'String'>
    readonly companyId: FieldRef<"Job", 'Int'>
    readonly branchId: FieldRef<"Job", 'Int'>
    readonly createdAt: FieldRef<"Job", 'DateTime'>
    readonly updatedAt: FieldRef<"Job", 'DateTime'>
    readonly deletedAt: FieldRef<"Job", 'DateTime'>
    readonly division: FieldRef<"Job", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Job findUnique
   */
  export type JobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job findUniqueOrThrow
   */
  export type JobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job findFirst
   */
  export type JobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job findFirstOrThrow
   */
  export type JobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job findMany
   */
  export type JobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job create
   */
  export type JobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The data needed to create a Job.
     */
    data: XOR<JobCreateInput, JobUncheckedCreateInput>
  }

  /**
   * Job createMany
   */
  export type JobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Jobs.
     */
    data: JobCreateManyInput | JobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Job createManyAndReturn
   */
  export type JobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * The data used to create many Jobs.
     */
    data: JobCreateManyInput | JobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Job update
   */
  export type JobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The data needed to update a Job.
     */
    data: XOR<JobUpdateInput, JobUncheckedUpdateInput>
    /**
     * Choose, which Job to update.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job updateMany
   */
  export type JobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Jobs.
     */
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     */
    where?: JobWhereInput
    /**
     * Limit how many Jobs to update.
     */
    limit?: number
  }

  /**
   * Job updateManyAndReturn
   */
  export type JobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * The data used to update Jobs.
     */
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     */
    where?: JobWhereInput
    /**
     * Limit how many Jobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Job upsert
   */
  export type JobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The filter to search for the Job to update in case it exists.
     */
    where: JobWhereUniqueInput
    /**
     * In case the Job found by the `where` argument doesn't exist, create a new Job with this data.
     */
    create: XOR<JobCreateInput, JobUncheckedCreateInput>
    /**
     * In case the Job was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobUpdateInput, JobUncheckedUpdateInput>
  }

  /**
   * Job delete
   */
  export type JobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter which Job to delete.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job deleteMany
   */
  export type JobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobs to delete
     */
    where?: JobWhereInput
    /**
     * Limit how many Jobs to delete.
     */
    limit?: number
  }

  /**
   * Job.expenses
   */
  export type Job$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Job.serviceInvoice
   */
  export type Job$serviceInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoice
     */
    select?: ServiceInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoice
     */
    omit?: ServiceInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceInclude<ExtArgs> | null
    where?: ServiceInvoiceWhereInput
  }

  /**
   * Job.freightInvoice
   */
  export type Job$freightInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoice
     */
    select?: FreightInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoice
     */
    omit?: FreightInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceInclude<ExtArgs> | null
    where?: FreightInvoiceWhereInput
  }

  /**
   * Job.branch
   */
  export type Job$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Job.pod
   */
  export type Job$podArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Port
     */
    omit?: PortOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortInclude<ExtArgs> | null
    where?: PortWhereInput
  }

  /**
   * Job without action
   */
  export type JobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
  }


  /**
   * Model ExpenseMaster
   */

  export type AggregateExpenseMaster = {
    _count: ExpenseMasterCountAggregateOutputType | null
    _avg: ExpenseMasterAvgAggregateOutputType | null
    _sum: ExpenseMasterSumAggregateOutputType | null
    _min: ExpenseMasterMinAggregateOutputType | null
    _max: ExpenseMasterMaxAggregateOutputType | null
  }

  export type ExpenseMasterAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type ExpenseMasterSumAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type ExpenseMasterMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseMasterMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseMasterCountAggregateOutputType = {
    id: number
    code: number
    name: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExpenseMasterAvgAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type ExpenseMasterSumAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type ExpenseMasterMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseMasterMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseMasterCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExpenseMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseMaster to aggregate.
     */
    where?: ExpenseMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseMasters to fetch.
     */
    orderBy?: ExpenseMasterOrderByWithRelationInput | ExpenseMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExpenseMasters
    **/
    _count?: true | ExpenseMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseMasterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseMasterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMasterMaxAggregateInputType
  }

  export type GetExpenseMasterAggregateType<T extends ExpenseMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateExpenseMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpenseMaster[P]>
      : GetScalarType<T[P], AggregateExpenseMaster[P]>
  }




  export type ExpenseMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseMasterWhereInput
    orderBy?: ExpenseMasterOrderByWithAggregationInput | ExpenseMasterOrderByWithAggregationInput[]
    by: ExpenseMasterScalarFieldEnum[] | ExpenseMasterScalarFieldEnum
    having?: ExpenseMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseMasterCountAggregateInputType | true
    _avg?: ExpenseMasterAvgAggregateInputType
    _sum?: ExpenseMasterSumAggregateInputType
    _min?: ExpenseMasterMinAggregateInputType
    _max?: ExpenseMasterMaxAggregateInputType
  }

  export type ExpenseMasterGroupByOutputType = {
    id: number
    code: string
    name: string
    companyId: number
    createdAt: Date
    updatedAt: Date
    _count: ExpenseMasterCountAggregateOutputType | null
    _avg: ExpenseMasterAvgAggregateOutputType | null
    _sum: ExpenseMasterSumAggregateOutputType | null
    _min: ExpenseMasterMinAggregateOutputType | null
    _max: ExpenseMasterMaxAggregateOutputType | null
  }

  type GetExpenseMasterGroupByPayload<T extends ExpenseMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseMasterGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseMasterGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseMaster"]>

  export type ExpenseMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseMaster"]>

  export type ExpenseMasterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseMaster"]>

  export type ExpenseMasterSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExpenseMasterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "companyId" | "createdAt" | "updatedAt", ExtArgs["result"]["expenseMaster"]>
  export type ExpenseMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type ExpenseMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type ExpenseMasterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $ExpenseMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExpenseMaster"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      companyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["expenseMaster"]>
    composites: {}
  }

  type ExpenseMasterGetPayload<S extends boolean | null | undefined | ExpenseMasterDefaultArgs> = $Result.GetResult<Prisma.$ExpenseMasterPayload, S>

  type ExpenseMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseMasterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseMasterCountAggregateInputType | true
    }

  export interface ExpenseMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExpenseMaster'], meta: { name: 'ExpenseMaster' } }
    /**
     * Find zero or one ExpenseMaster that matches the filter.
     * @param {ExpenseMasterFindUniqueArgs} args - Arguments to find a ExpenseMaster
     * @example
     * // Get one ExpenseMaster
     * const expenseMaster = await prisma.expenseMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseMasterFindUniqueArgs>(args: SelectSubset<T, ExpenseMasterFindUniqueArgs<ExtArgs>>): Prisma__ExpenseMasterClient<$Result.GetResult<Prisma.$ExpenseMasterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExpenseMaster that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseMasterFindUniqueOrThrowArgs} args - Arguments to find a ExpenseMaster
     * @example
     * // Get one ExpenseMaster
     * const expenseMaster = await prisma.expenseMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseMasterClient<$Result.GetResult<Prisma.$ExpenseMasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseMasterFindFirstArgs} args - Arguments to find a ExpenseMaster
     * @example
     * // Get one ExpenseMaster
     * const expenseMaster = await prisma.expenseMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseMasterFindFirstArgs>(args?: SelectSubset<T, ExpenseMasterFindFirstArgs<ExtArgs>>): Prisma__ExpenseMasterClient<$Result.GetResult<Prisma.$ExpenseMasterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseMasterFindFirstOrThrowArgs} args - Arguments to find a ExpenseMaster
     * @example
     * // Get one ExpenseMaster
     * const expenseMaster = await prisma.expenseMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseMasterClient<$Result.GetResult<Prisma.$ExpenseMasterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExpenseMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExpenseMasters
     * const expenseMasters = await prisma.expenseMaster.findMany()
     * 
     * // Get first 10 ExpenseMasters
     * const expenseMasters = await prisma.expenseMaster.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseMasterWithIdOnly = await prisma.expenseMaster.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseMasterFindManyArgs>(args?: SelectSubset<T, ExpenseMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseMasterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExpenseMaster.
     * @param {ExpenseMasterCreateArgs} args - Arguments to create a ExpenseMaster.
     * @example
     * // Create one ExpenseMaster
     * const ExpenseMaster = await prisma.expenseMaster.create({
     *   data: {
     *     // ... data to create a ExpenseMaster
     *   }
     * })
     * 
     */
    create<T extends ExpenseMasterCreateArgs>(args: SelectSubset<T, ExpenseMasterCreateArgs<ExtArgs>>): Prisma__ExpenseMasterClient<$Result.GetResult<Prisma.$ExpenseMasterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExpenseMasters.
     * @param {ExpenseMasterCreateManyArgs} args - Arguments to create many ExpenseMasters.
     * @example
     * // Create many ExpenseMasters
     * const expenseMaster = await prisma.expenseMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseMasterCreateManyArgs>(args?: SelectSubset<T, ExpenseMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExpenseMasters and returns the data saved in the database.
     * @param {ExpenseMasterCreateManyAndReturnArgs} args - Arguments to create many ExpenseMasters.
     * @example
     * // Create many ExpenseMasters
     * const expenseMaster = await prisma.expenseMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExpenseMasters and only return the `id`
     * const expenseMasterWithIdOnly = await prisma.expenseMaster.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseMasterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExpenseMaster.
     * @param {ExpenseMasterDeleteArgs} args - Arguments to delete one ExpenseMaster.
     * @example
     * // Delete one ExpenseMaster
     * const ExpenseMaster = await prisma.expenseMaster.delete({
     *   where: {
     *     // ... filter to delete one ExpenseMaster
     *   }
     * })
     * 
     */
    delete<T extends ExpenseMasterDeleteArgs>(args: SelectSubset<T, ExpenseMasterDeleteArgs<ExtArgs>>): Prisma__ExpenseMasterClient<$Result.GetResult<Prisma.$ExpenseMasterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExpenseMaster.
     * @param {ExpenseMasterUpdateArgs} args - Arguments to update one ExpenseMaster.
     * @example
     * // Update one ExpenseMaster
     * const expenseMaster = await prisma.expenseMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseMasterUpdateArgs>(args: SelectSubset<T, ExpenseMasterUpdateArgs<ExtArgs>>): Prisma__ExpenseMasterClient<$Result.GetResult<Prisma.$ExpenseMasterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExpenseMasters.
     * @param {ExpenseMasterDeleteManyArgs} args - Arguments to filter ExpenseMasters to delete.
     * @example
     * // Delete a few ExpenseMasters
     * const { count } = await prisma.expenseMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseMasterDeleteManyArgs>(args?: SelectSubset<T, ExpenseMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExpenseMasters
     * const expenseMaster = await prisma.expenseMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseMasterUpdateManyArgs>(args: SelectSubset<T, ExpenseMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseMasters and returns the data updated in the database.
     * @param {ExpenseMasterUpdateManyAndReturnArgs} args - Arguments to update many ExpenseMasters.
     * @example
     * // Update many ExpenseMasters
     * const expenseMaster = await prisma.expenseMaster.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExpenseMasters and only return the `id`
     * const expenseMasterWithIdOnly = await prisma.expenseMaster.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpenseMasterUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpenseMasterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseMasterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExpenseMaster.
     * @param {ExpenseMasterUpsertArgs} args - Arguments to update or create a ExpenseMaster.
     * @example
     * // Update or create a ExpenseMaster
     * const expenseMaster = await prisma.expenseMaster.upsert({
     *   create: {
     *     // ... data to create a ExpenseMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExpenseMaster we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseMasterUpsertArgs>(args: SelectSubset<T, ExpenseMasterUpsertArgs<ExtArgs>>): Prisma__ExpenseMasterClient<$Result.GetResult<Prisma.$ExpenseMasterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExpenseMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseMasterCountArgs} args - Arguments to filter ExpenseMasters to count.
     * @example
     * // Count the number of ExpenseMasters
     * const count = await prisma.expenseMaster.count({
     *   where: {
     *     // ... the filter for the ExpenseMasters we want to count
     *   }
     * })
    **/
    count<T extends ExpenseMasterCountArgs>(
      args?: Subset<T, ExpenseMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExpenseMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseMasterAggregateArgs>(args: Subset<T, ExpenseMasterAggregateArgs>): Prisma.PrismaPromise<GetExpenseMasterAggregateType<T>>

    /**
     * Group by ExpenseMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseMasterGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExpenseMaster model
   */
  readonly fields: ExpenseMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExpenseMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExpenseMaster model
   */
  interface ExpenseMasterFieldRefs {
    readonly id: FieldRef<"ExpenseMaster", 'Int'>
    readonly code: FieldRef<"ExpenseMaster", 'String'>
    readonly name: FieldRef<"ExpenseMaster", 'String'>
    readonly companyId: FieldRef<"ExpenseMaster", 'Int'>
    readonly createdAt: FieldRef<"ExpenseMaster", 'DateTime'>
    readonly updatedAt: FieldRef<"ExpenseMaster", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExpenseMaster findUnique
   */
  export type ExpenseMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseMaster
     */
    select?: ExpenseMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseMaster
     */
    omit?: ExpenseMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseMasterInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseMaster to fetch.
     */
    where: ExpenseMasterWhereUniqueInput
  }

  /**
   * ExpenseMaster findUniqueOrThrow
   */
  export type ExpenseMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseMaster
     */
    select?: ExpenseMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseMaster
     */
    omit?: ExpenseMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseMasterInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseMaster to fetch.
     */
    where: ExpenseMasterWhereUniqueInput
  }

  /**
   * ExpenseMaster findFirst
   */
  export type ExpenseMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseMaster
     */
    select?: ExpenseMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseMaster
     */
    omit?: ExpenseMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseMasterInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseMaster to fetch.
     */
    where?: ExpenseMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseMasters to fetch.
     */
    orderBy?: ExpenseMasterOrderByWithRelationInput | ExpenseMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseMasters.
     */
    cursor?: ExpenseMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseMasters.
     */
    distinct?: ExpenseMasterScalarFieldEnum | ExpenseMasterScalarFieldEnum[]
  }

  /**
   * ExpenseMaster findFirstOrThrow
   */
  export type ExpenseMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseMaster
     */
    select?: ExpenseMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseMaster
     */
    omit?: ExpenseMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseMasterInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseMaster to fetch.
     */
    where?: ExpenseMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseMasters to fetch.
     */
    orderBy?: ExpenseMasterOrderByWithRelationInput | ExpenseMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseMasters.
     */
    cursor?: ExpenseMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseMasters.
     */
    distinct?: ExpenseMasterScalarFieldEnum | ExpenseMasterScalarFieldEnum[]
  }

  /**
   * ExpenseMaster findMany
   */
  export type ExpenseMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseMaster
     */
    select?: ExpenseMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseMaster
     */
    omit?: ExpenseMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseMasterInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseMasters to fetch.
     */
    where?: ExpenseMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseMasters to fetch.
     */
    orderBy?: ExpenseMasterOrderByWithRelationInput | ExpenseMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExpenseMasters.
     */
    cursor?: ExpenseMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseMasters.
     */
    skip?: number
    distinct?: ExpenseMasterScalarFieldEnum | ExpenseMasterScalarFieldEnum[]
  }

  /**
   * ExpenseMaster create
   */
  export type ExpenseMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseMaster
     */
    select?: ExpenseMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseMaster
     */
    omit?: ExpenseMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a ExpenseMaster.
     */
    data: XOR<ExpenseMasterCreateInput, ExpenseMasterUncheckedCreateInput>
  }

  /**
   * ExpenseMaster createMany
   */
  export type ExpenseMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExpenseMasters.
     */
    data: ExpenseMasterCreateManyInput | ExpenseMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExpenseMaster createManyAndReturn
   */
  export type ExpenseMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseMaster
     */
    select?: ExpenseMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseMaster
     */
    omit?: ExpenseMasterOmit<ExtArgs> | null
    /**
     * The data used to create many ExpenseMasters.
     */
    data: ExpenseMasterCreateManyInput | ExpenseMasterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseMasterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpenseMaster update
   */
  export type ExpenseMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseMaster
     */
    select?: ExpenseMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseMaster
     */
    omit?: ExpenseMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a ExpenseMaster.
     */
    data: XOR<ExpenseMasterUpdateInput, ExpenseMasterUncheckedUpdateInput>
    /**
     * Choose, which ExpenseMaster to update.
     */
    where: ExpenseMasterWhereUniqueInput
  }

  /**
   * ExpenseMaster updateMany
   */
  export type ExpenseMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExpenseMasters.
     */
    data: XOR<ExpenseMasterUpdateManyMutationInput, ExpenseMasterUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseMasters to update
     */
    where?: ExpenseMasterWhereInput
    /**
     * Limit how many ExpenseMasters to update.
     */
    limit?: number
  }

  /**
   * ExpenseMaster updateManyAndReturn
   */
  export type ExpenseMasterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseMaster
     */
    select?: ExpenseMasterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseMaster
     */
    omit?: ExpenseMasterOmit<ExtArgs> | null
    /**
     * The data used to update ExpenseMasters.
     */
    data: XOR<ExpenseMasterUpdateManyMutationInput, ExpenseMasterUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseMasters to update
     */
    where?: ExpenseMasterWhereInput
    /**
     * Limit how many ExpenseMasters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseMasterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpenseMaster upsert
   */
  export type ExpenseMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseMaster
     */
    select?: ExpenseMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseMaster
     */
    omit?: ExpenseMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the ExpenseMaster to update in case it exists.
     */
    where: ExpenseMasterWhereUniqueInput
    /**
     * In case the ExpenseMaster found by the `where` argument doesn't exist, create a new ExpenseMaster with this data.
     */
    create: XOR<ExpenseMasterCreateInput, ExpenseMasterUncheckedCreateInput>
    /**
     * In case the ExpenseMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseMasterUpdateInput, ExpenseMasterUncheckedUpdateInput>
  }

  /**
   * ExpenseMaster delete
   */
  export type ExpenseMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseMaster
     */
    select?: ExpenseMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseMaster
     */
    omit?: ExpenseMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseMasterInclude<ExtArgs> | null
    /**
     * Filter which ExpenseMaster to delete.
     */
    where: ExpenseMasterWhereUniqueInput
  }

  /**
   * ExpenseMaster deleteMany
   */
  export type ExpenseMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseMasters to delete
     */
    where?: ExpenseMasterWhereInput
    /**
     * Limit how many ExpenseMasters to delete.
     */
    limit?: number
  }

  /**
   * ExpenseMaster without action
   */
  export type ExpenseMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseMaster
     */
    select?: ExpenseMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseMaster
     */
    omit?: ExpenseMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseMasterInclude<ExtArgs> | null
  }


  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    id: number | null
    jobId: number | null
    vendorId: number | null
    costPrice: number | null
    sellingPrice: number | null
    exchangeRate: number | null
    companyId: number | null
  }

  export type ExpenseSumAggregateOutputType = {
    id: number | null
    jobId: number | null
    vendorId: number | null
    costPrice: number | null
    sellingPrice: number | null
    exchangeRate: number | null
    companyId: number | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: number | null
    jobId: number | null
    vendorId: number | null
    description: string | null
    costPrice: number | null
    sellingPrice: number | null
    currencyCode: string | null
    exchangeRate: number | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: number | null
    jobId: number | null
    vendorId: number | null
    description: string | null
    costPrice: number | null
    sellingPrice: number | null
    currencyCode: string | null
    exchangeRate: number | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    jobId: number
    vendorId: number
    description: number
    costPrice: number
    sellingPrice: number
    currencyCode: number
    exchangeRate: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    id?: true
    jobId?: true
    vendorId?: true
    costPrice?: true
    sellingPrice?: true
    exchangeRate?: true
    companyId?: true
  }

  export type ExpenseSumAggregateInputType = {
    id?: true
    jobId?: true
    vendorId?: true
    costPrice?: true
    sellingPrice?: true
    exchangeRate?: true
    companyId?: true
  }

  export type ExpenseMinAggregateInputType = {
    id?: true
    jobId?: true
    vendorId?: true
    description?: true
    costPrice?: true
    sellingPrice?: true
    currencyCode?: true
    exchangeRate?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    jobId?: true
    vendorId?: true
    description?: true
    costPrice?: true
    sellingPrice?: true
    currencyCode?: true
    exchangeRate?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    jobId?: true
    vendorId?: true
    description?: true
    costPrice?: true
    sellingPrice?: true
    currencyCode?: true
    exchangeRate?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    id: number
    jobId: number
    vendorId: number | null
    description: string
    costPrice: number
    sellingPrice: number
    currencyCode: string
    exchangeRate: number
    companyId: number
    createdAt: Date
    updatedAt: Date
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    vendorId?: boolean
    description?: boolean
    costPrice?: boolean
    sellingPrice?: boolean
    currencyCode?: boolean
    exchangeRate?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
    vendor?: boolean | Expense$vendorArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    vendorId?: boolean
    description?: boolean
    costPrice?: boolean
    sellingPrice?: boolean
    currencyCode?: boolean
    exchangeRate?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
    vendor?: boolean | Expense$vendorArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    vendorId?: boolean
    description?: boolean
    costPrice?: boolean
    sellingPrice?: boolean
    currencyCode?: boolean
    exchangeRate?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
    vendor?: boolean | Expense$vendorArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectScalar = {
    id?: boolean
    jobId?: boolean
    vendorId?: boolean
    description?: boolean
    costPrice?: boolean
    sellingPrice?: boolean
    currencyCode?: boolean
    exchangeRate?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExpenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobId" | "vendorId" | "description" | "costPrice" | "sellingPrice" | "currencyCode" | "exchangeRate" | "companyId" | "createdAt" | "updatedAt", ExtArgs["result"]["expense"]>
  export type ExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
    vendor?: boolean | Expense$vendorArgs<ExtArgs>
  }
  export type ExpenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
    vendor?: boolean | Expense$vendorArgs<ExtArgs>
  }
  export type ExpenseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
    vendor?: boolean | Expense$vendorArgs<ExtArgs>
  }

  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      job: Prisma.$JobPayload<ExtArgs>
      vendor: Prisma.$VendorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      jobId: number
      vendorId: number | null
      description: string
      costPrice: number
      sellingPrice: number
      currencyCode: string
      exchangeRate: number
      companyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseFindUniqueArgs>(args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseFindFirstArgs>(args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseFindManyArgs>(args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
     */
    create<T extends ExpenseCreateArgs>(args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Expenses.
     * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCreateManyArgs>(args?: SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expenses and returns the data saved in the database.
     * @param {ExpenseCreateManyAndReturnArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
     */
    delete<T extends ExpenseDeleteArgs>(args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseUpdateArgs>(args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseDeleteManyArgs>(args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseUpdateManyArgs>(args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses and returns the data updated in the database.
     * @param {ExpenseUpdateManyAndReturnArgs} args - Arguments to update many Expenses.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpenseUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpenseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseUpsertArgs>(args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    job<T extends JobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobDefaultArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vendor<T extends Expense$vendorArgs<ExtArgs> = {}>(args?: Subset<T, Expense$vendorArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expense model
   */
  interface ExpenseFieldRefs {
    readonly id: FieldRef<"Expense", 'Int'>
    readonly jobId: FieldRef<"Expense", 'Int'>
    readonly vendorId: FieldRef<"Expense", 'Int'>
    readonly description: FieldRef<"Expense", 'String'>
    readonly costPrice: FieldRef<"Expense", 'Float'>
    readonly sellingPrice: FieldRef<"Expense", 'Float'>
    readonly currencyCode: FieldRef<"Expense", 'String'>
    readonly exchangeRate: FieldRef<"Expense", 'Float'>
    readonly companyId: FieldRef<"Expense", 'Int'>
    readonly createdAt: FieldRef<"Expense", 'DateTime'>
    readonly updatedAt: FieldRef<"Expense", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }

  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expense createManyAndReturn
   */
  export type ExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
  }

  /**
   * Expense updateManyAndReturn
   */
  export type ExpenseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }

  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to delete.
     */
    limit?: number
  }

  /**
   * Expense.vendor
   */
  export type Expense$vendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
  }

  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
  }


  /**
   * Model ServiceInvoice
   */

  export type AggregateServiceInvoice = {
    _count: ServiceInvoiceCountAggregateOutputType | null
    _avg: ServiceInvoiceAvgAggregateOutputType | null
    _sum: ServiceInvoiceSumAggregateOutputType | null
    _min: ServiceInvoiceMinAggregateOutputType | null
    _max: ServiceInvoiceMaxAggregateOutputType | null
  }

  export type ServiceInvoiceAvgAggregateOutputType = {
    id: number | null
    jobId: number | null
    customerId: number | null
    creditDays: number | null
    totalAmount: number | null
    taxAmount: number | null
    grandTotal: number | null
    exchangeRate: number | null
    approvedById: number | null
    companyId: number | null
    transactionId: number | null
  }

  export type ServiceInvoiceSumAggregateOutputType = {
    id: number | null
    jobId: number | null
    customerId: number | null
    creditDays: number | null
    totalAmount: number | null
    taxAmount: number | null
    grandTotal: number | null
    exchangeRate: number | null
    approvedById: number | null
    companyId: number | null
    transactionId: number | null
  }

  export type ServiceInvoiceMinAggregateOutputType = {
    id: number | null
    invoiceNumber: string | null
    date: Date | null
    jobId: number | null
    customerId: number | null
    type: $Enums.InvoiceType | null
    status: $Enums.InvoiceStatus | null
    masterNumber: string | null
    agentCode: string | null
    shippingLine: string | null
    origin: string | null
    destination: string | null
    creditDays: number | null
    vendorType: string | null
    totalAmount: number | null
    taxAmount: number | null
    grandTotal: number | null
    currencyCode: string | null
    exchangeRate: number | null
    isApproved: boolean | null
    approvedById: number | null
    isLocked: boolean | null
    lockedAt: Date | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    transactionId: number | null
    division: string | null
  }

  export type ServiceInvoiceMaxAggregateOutputType = {
    id: number | null
    invoiceNumber: string | null
    date: Date | null
    jobId: number | null
    customerId: number | null
    type: $Enums.InvoiceType | null
    status: $Enums.InvoiceStatus | null
    masterNumber: string | null
    agentCode: string | null
    shippingLine: string | null
    origin: string | null
    destination: string | null
    creditDays: number | null
    vendorType: string | null
    totalAmount: number | null
    taxAmount: number | null
    grandTotal: number | null
    currencyCode: string | null
    exchangeRate: number | null
    isApproved: boolean | null
    approvedById: number | null
    isLocked: boolean | null
    lockedAt: Date | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    transactionId: number | null
    division: string | null
  }

  export type ServiceInvoiceCountAggregateOutputType = {
    id: number
    invoiceNumber: number
    date: number
    jobId: number
    customerId: number
    type: number
    status: number
    masterNumber: number
    agentCode: number
    shippingLine: number
    origin: number
    destination: number
    creditDays: number
    vendorType: number
    totalAmount: number
    taxAmount: number
    grandTotal: number
    currencyCode: number
    exchangeRate: number
    isApproved: number
    approvedById: number
    isLocked: number
    lockedAt: number
    companyId: number
    createdAt: number
    updatedAt: number
    transactionId: number
    division: number
    _all: number
  }


  export type ServiceInvoiceAvgAggregateInputType = {
    id?: true
    jobId?: true
    customerId?: true
    creditDays?: true
    totalAmount?: true
    taxAmount?: true
    grandTotal?: true
    exchangeRate?: true
    approvedById?: true
    companyId?: true
    transactionId?: true
  }

  export type ServiceInvoiceSumAggregateInputType = {
    id?: true
    jobId?: true
    customerId?: true
    creditDays?: true
    totalAmount?: true
    taxAmount?: true
    grandTotal?: true
    exchangeRate?: true
    approvedById?: true
    companyId?: true
    transactionId?: true
  }

  export type ServiceInvoiceMinAggregateInputType = {
    id?: true
    invoiceNumber?: true
    date?: true
    jobId?: true
    customerId?: true
    type?: true
    status?: true
    masterNumber?: true
    agentCode?: true
    shippingLine?: true
    origin?: true
    destination?: true
    creditDays?: true
    vendorType?: true
    totalAmount?: true
    taxAmount?: true
    grandTotal?: true
    currencyCode?: true
    exchangeRate?: true
    isApproved?: true
    approvedById?: true
    isLocked?: true
    lockedAt?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    transactionId?: true
    division?: true
  }

  export type ServiceInvoiceMaxAggregateInputType = {
    id?: true
    invoiceNumber?: true
    date?: true
    jobId?: true
    customerId?: true
    type?: true
    status?: true
    masterNumber?: true
    agentCode?: true
    shippingLine?: true
    origin?: true
    destination?: true
    creditDays?: true
    vendorType?: true
    totalAmount?: true
    taxAmount?: true
    grandTotal?: true
    currencyCode?: true
    exchangeRate?: true
    isApproved?: true
    approvedById?: true
    isLocked?: true
    lockedAt?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    transactionId?: true
    division?: true
  }

  export type ServiceInvoiceCountAggregateInputType = {
    id?: true
    invoiceNumber?: true
    date?: true
    jobId?: true
    customerId?: true
    type?: true
    status?: true
    masterNumber?: true
    agentCode?: true
    shippingLine?: true
    origin?: true
    destination?: true
    creditDays?: true
    vendorType?: true
    totalAmount?: true
    taxAmount?: true
    grandTotal?: true
    currencyCode?: true
    exchangeRate?: true
    isApproved?: true
    approvedById?: true
    isLocked?: true
    lockedAt?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    transactionId?: true
    division?: true
    _all?: true
  }

  export type ServiceInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceInvoice to aggregate.
     */
    where?: ServiceInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceInvoices to fetch.
     */
    orderBy?: ServiceInvoiceOrderByWithRelationInput | ServiceInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceInvoices
    **/
    _count?: true | ServiceInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceInvoiceMaxAggregateInputType
  }

  export type GetServiceInvoiceAggregateType<T extends ServiceInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceInvoice[P]>
      : GetScalarType<T[P], AggregateServiceInvoice[P]>
  }




  export type ServiceInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceInvoiceWhereInput
    orderBy?: ServiceInvoiceOrderByWithAggregationInput | ServiceInvoiceOrderByWithAggregationInput[]
    by: ServiceInvoiceScalarFieldEnum[] | ServiceInvoiceScalarFieldEnum
    having?: ServiceInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceInvoiceCountAggregateInputType | true
    _avg?: ServiceInvoiceAvgAggregateInputType
    _sum?: ServiceInvoiceSumAggregateInputType
    _min?: ServiceInvoiceMinAggregateInputType
    _max?: ServiceInvoiceMaxAggregateInputType
  }

  export type ServiceInvoiceGroupByOutputType = {
    id: number
    invoiceNumber: string
    date: Date
    jobId: number
    customerId: number
    type: $Enums.InvoiceType
    status: $Enums.InvoiceStatus
    masterNumber: string | null
    agentCode: string | null
    shippingLine: string | null
    origin: string | null
    destination: string | null
    creditDays: number | null
    vendorType: string | null
    totalAmount: number
    taxAmount: number
    grandTotal: number
    currencyCode: string
    exchangeRate: number
    isApproved: boolean
    approvedById: number | null
    isLocked: boolean
    lockedAt: Date | null
    companyId: number
    createdAt: Date
    updatedAt: Date
    transactionId: number | null
    division: string | null
    _count: ServiceInvoiceCountAggregateOutputType | null
    _avg: ServiceInvoiceAvgAggregateOutputType | null
    _sum: ServiceInvoiceSumAggregateOutputType | null
    _min: ServiceInvoiceMinAggregateOutputType | null
    _max: ServiceInvoiceMaxAggregateOutputType | null
  }

  type GetServiceInvoiceGroupByPayload<T extends ServiceInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    date?: boolean
    jobId?: boolean
    customerId?: boolean
    type?: boolean
    status?: boolean
    masterNumber?: boolean
    agentCode?: boolean
    shippingLine?: boolean
    origin?: boolean
    destination?: boolean
    creditDays?: boolean
    vendorType?: boolean
    totalAmount?: boolean
    taxAmount?: boolean
    grandTotal?: boolean
    currencyCode?: boolean
    exchangeRate?: boolean
    isApproved?: boolean
    approvedById?: boolean
    isLocked?: boolean
    lockedAt?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactionId?: boolean
    division?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
    transaction?: boolean | ServiceInvoice$transactionArgs<ExtArgs>
    items?: boolean | ServiceInvoice$itemsArgs<ExtArgs>
    _count?: boolean | ServiceInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceInvoice"]>

  export type ServiceInvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    date?: boolean
    jobId?: boolean
    customerId?: boolean
    type?: boolean
    status?: boolean
    masterNumber?: boolean
    agentCode?: boolean
    shippingLine?: boolean
    origin?: boolean
    destination?: boolean
    creditDays?: boolean
    vendorType?: boolean
    totalAmount?: boolean
    taxAmount?: boolean
    grandTotal?: boolean
    currencyCode?: boolean
    exchangeRate?: boolean
    isApproved?: boolean
    approvedById?: boolean
    isLocked?: boolean
    lockedAt?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactionId?: boolean
    division?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
    transaction?: boolean | ServiceInvoice$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["serviceInvoice"]>

  export type ServiceInvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    date?: boolean
    jobId?: boolean
    customerId?: boolean
    type?: boolean
    status?: boolean
    masterNumber?: boolean
    agentCode?: boolean
    shippingLine?: boolean
    origin?: boolean
    destination?: boolean
    creditDays?: boolean
    vendorType?: boolean
    totalAmount?: boolean
    taxAmount?: boolean
    grandTotal?: boolean
    currencyCode?: boolean
    exchangeRate?: boolean
    isApproved?: boolean
    approvedById?: boolean
    isLocked?: boolean
    lockedAt?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactionId?: boolean
    division?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
    transaction?: boolean | ServiceInvoice$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["serviceInvoice"]>

  export type ServiceInvoiceSelectScalar = {
    id?: boolean
    invoiceNumber?: boolean
    date?: boolean
    jobId?: boolean
    customerId?: boolean
    type?: boolean
    status?: boolean
    masterNumber?: boolean
    agentCode?: boolean
    shippingLine?: boolean
    origin?: boolean
    destination?: boolean
    creditDays?: boolean
    vendorType?: boolean
    totalAmount?: boolean
    taxAmount?: boolean
    grandTotal?: boolean
    currencyCode?: boolean
    exchangeRate?: boolean
    isApproved?: boolean
    approvedById?: boolean
    isLocked?: boolean
    lockedAt?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactionId?: boolean
    division?: boolean
  }

  export type ServiceInvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceNumber" | "date" | "jobId" | "customerId" | "type" | "status" | "masterNumber" | "agentCode" | "shippingLine" | "origin" | "destination" | "creditDays" | "vendorType" | "totalAmount" | "taxAmount" | "grandTotal" | "currencyCode" | "exchangeRate" | "isApproved" | "approvedById" | "isLocked" | "lockedAt" | "companyId" | "createdAt" | "updatedAt" | "transactionId" | "division", ExtArgs["result"]["serviceInvoice"]>
  export type ServiceInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
    transaction?: boolean | ServiceInvoice$transactionArgs<ExtArgs>
    items?: boolean | ServiceInvoice$itemsArgs<ExtArgs>
    _count?: boolean | ServiceInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceInvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
    transaction?: boolean | ServiceInvoice$transactionArgs<ExtArgs>
  }
  export type ServiceInvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
    transaction?: boolean | ServiceInvoice$transactionArgs<ExtArgs>
  }

  export type $ServiceInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceInvoice"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs>
      job: Prisma.$JobPayload<ExtArgs>
      transaction: Prisma.$TransactionPayload<ExtArgs> | null
      items: Prisma.$ServiceInvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoiceNumber: string
      date: Date
      jobId: number
      customerId: number
      type: $Enums.InvoiceType
      status: $Enums.InvoiceStatus
      masterNumber: string | null
      agentCode: string | null
      shippingLine: string | null
      origin: string | null
      destination: string | null
      creditDays: number | null
      vendorType: string | null
      totalAmount: number
      taxAmount: number
      grandTotal: number
      currencyCode: string
      exchangeRate: number
      isApproved: boolean
      approvedById: number | null
      isLocked: boolean
      lockedAt: Date | null
      companyId: number
      createdAt: Date
      updatedAt: Date
      transactionId: number | null
      division: string | null
    }, ExtArgs["result"]["serviceInvoice"]>
    composites: {}
  }

  type ServiceInvoiceGetPayload<S extends boolean | null | undefined | ServiceInvoiceDefaultArgs> = $Result.GetResult<Prisma.$ServiceInvoicePayload, S>

  type ServiceInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceInvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceInvoiceCountAggregateInputType | true
    }

  export interface ServiceInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceInvoice'], meta: { name: 'ServiceInvoice' } }
    /**
     * Find zero or one ServiceInvoice that matches the filter.
     * @param {ServiceInvoiceFindUniqueArgs} args - Arguments to find a ServiceInvoice
     * @example
     * // Get one ServiceInvoice
     * const serviceInvoice = await prisma.serviceInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceInvoiceFindUniqueArgs>(args: SelectSubset<T, ServiceInvoiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceInvoiceClient<$Result.GetResult<Prisma.$ServiceInvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceInvoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceInvoiceFindUniqueOrThrowArgs} args - Arguments to find a ServiceInvoice
     * @example
     * // Get one ServiceInvoice
     * const serviceInvoice = await prisma.serviceInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceInvoiceClient<$Result.GetResult<Prisma.$ServiceInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInvoiceFindFirstArgs} args - Arguments to find a ServiceInvoice
     * @example
     * // Get one ServiceInvoice
     * const serviceInvoice = await prisma.serviceInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceInvoiceFindFirstArgs>(args?: SelectSubset<T, ServiceInvoiceFindFirstArgs<ExtArgs>>): Prisma__ServiceInvoiceClient<$Result.GetResult<Prisma.$ServiceInvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInvoiceFindFirstOrThrowArgs} args - Arguments to find a ServiceInvoice
     * @example
     * // Get one ServiceInvoice
     * const serviceInvoice = await prisma.serviceInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceInvoiceClient<$Result.GetResult<Prisma.$ServiceInvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceInvoices
     * const serviceInvoices = await prisma.serviceInvoice.findMany()
     * 
     * // Get first 10 ServiceInvoices
     * const serviceInvoices = await prisma.serviceInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceInvoiceWithIdOnly = await prisma.serviceInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceInvoiceFindManyArgs>(args?: SelectSubset<T, ServiceInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceInvoice.
     * @param {ServiceInvoiceCreateArgs} args - Arguments to create a ServiceInvoice.
     * @example
     * // Create one ServiceInvoice
     * const ServiceInvoice = await prisma.serviceInvoice.create({
     *   data: {
     *     // ... data to create a ServiceInvoice
     *   }
     * })
     * 
     */
    create<T extends ServiceInvoiceCreateArgs>(args: SelectSubset<T, ServiceInvoiceCreateArgs<ExtArgs>>): Prisma__ServiceInvoiceClient<$Result.GetResult<Prisma.$ServiceInvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceInvoices.
     * @param {ServiceInvoiceCreateManyArgs} args - Arguments to create many ServiceInvoices.
     * @example
     * // Create many ServiceInvoices
     * const serviceInvoice = await prisma.serviceInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceInvoiceCreateManyArgs>(args?: SelectSubset<T, ServiceInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceInvoices and returns the data saved in the database.
     * @param {ServiceInvoiceCreateManyAndReturnArgs} args - Arguments to create many ServiceInvoices.
     * @example
     * // Create many ServiceInvoices
     * const serviceInvoice = await prisma.serviceInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceInvoices and only return the `id`
     * const serviceInvoiceWithIdOnly = await prisma.serviceInvoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceInvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceInvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceInvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceInvoice.
     * @param {ServiceInvoiceDeleteArgs} args - Arguments to delete one ServiceInvoice.
     * @example
     * // Delete one ServiceInvoice
     * const ServiceInvoice = await prisma.serviceInvoice.delete({
     *   where: {
     *     // ... filter to delete one ServiceInvoice
     *   }
     * })
     * 
     */
    delete<T extends ServiceInvoiceDeleteArgs>(args: SelectSubset<T, ServiceInvoiceDeleteArgs<ExtArgs>>): Prisma__ServiceInvoiceClient<$Result.GetResult<Prisma.$ServiceInvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceInvoice.
     * @param {ServiceInvoiceUpdateArgs} args - Arguments to update one ServiceInvoice.
     * @example
     * // Update one ServiceInvoice
     * const serviceInvoice = await prisma.serviceInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceInvoiceUpdateArgs>(args: SelectSubset<T, ServiceInvoiceUpdateArgs<ExtArgs>>): Prisma__ServiceInvoiceClient<$Result.GetResult<Prisma.$ServiceInvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceInvoices.
     * @param {ServiceInvoiceDeleteManyArgs} args - Arguments to filter ServiceInvoices to delete.
     * @example
     * // Delete a few ServiceInvoices
     * const { count } = await prisma.serviceInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceInvoiceDeleteManyArgs>(args?: SelectSubset<T, ServiceInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceInvoices
     * const serviceInvoice = await prisma.serviceInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceInvoiceUpdateManyArgs>(args: SelectSubset<T, ServiceInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceInvoices and returns the data updated in the database.
     * @param {ServiceInvoiceUpdateManyAndReturnArgs} args - Arguments to update many ServiceInvoices.
     * @example
     * // Update many ServiceInvoices
     * const serviceInvoice = await prisma.serviceInvoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceInvoices and only return the `id`
     * const serviceInvoiceWithIdOnly = await prisma.serviceInvoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceInvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceInvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceInvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceInvoice.
     * @param {ServiceInvoiceUpsertArgs} args - Arguments to update or create a ServiceInvoice.
     * @example
     * // Update or create a ServiceInvoice
     * const serviceInvoice = await prisma.serviceInvoice.upsert({
     *   create: {
     *     // ... data to create a ServiceInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceInvoice we want to update
     *   }
     * })
     */
    upsert<T extends ServiceInvoiceUpsertArgs>(args: SelectSubset<T, ServiceInvoiceUpsertArgs<ExtArgs>>): Prisma__ServiceInvoiceClient<$Result.GetResult<Prisma.$ServiceInvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInvoiceCountArgs} args - Arguments to filter ServiceInvoices to count.
     * @example
     * // Count the number of ServiceInvoices
     * const count = await prisma.serviceInvoice.count({
     *   where: {
     *     // ... the filter for the ServiceInvoices we want to count
     *   }
     * })
    **/
    count<T extends ServiceInvoiceCountArgs>(
      args?: Subset<T, ServiceInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceInvoiceAggregateArgs>(args: Subset<T, ServiceInvoiceAggregateArgs>): Prisma.PrismaPromise<GetServiceInvoiceAggregateType<T>>

    /**
     * Group by ServiceInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceInvoice model
   */
  readonly fields: ServiceInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    job<T extends JobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobDefaultArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transaction<T extends ServiceInvoice$transactionArgs<ExtArgs> = {}>(args?: Subset<T, ServiceInvoice$transactionArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends ServiceInvoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceInvoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceInvoice model
   */
  interface ServiceInvoiceFieldRefs {
    readonly id: FieldRef<"ServiceInvoice", 'Int'>
    readonly invoiceNumber: FieldRef<"ServiceInvoice", 'String'>
    readonly date: FieldRef<"ServiceInvoice", 'DateTime'>
    readonly jobId: FieldRef<"ServiceInvoice", 'Int'>
    readonly customerId: FieldRef<"ServiceInvoice", 'Int'>
    readonly type: FieldRef<"ServiceInvoice", 'InvoiceType'>
    readonly status: FieldRef<"ServiceInvoice", 'InvoiceStatus'>
    readonly masterNumber: FieldRef<"ServiceInvoice", 'String'>
    readonly agentCode: FieldRef<"ServiceInvoice", 'String'>
    readonly shippingLine: FieldRef<"ServiceInvoice", 'String'>
    readonly origin: FieldRef<"ServiceInvoice", 'String'>
    readonly destination: FieldRef<"ServiceInvoice", 'String'>
    readonly creditDays: FieldRef<"ServiceInvoice", 'Int'>
    readonly vendorType: FieldRef<"ServiceInvoice", 'String'>
    readonly totalAmount: FieldRef<"ServiceInvoice", 'Float'>
    readonly taxAmount: FieldRef<"ServiceInvoice", 'Float'>
    readonly grandTotal: FieldRef<"ServiceInvoice", 'Float'>
    readonly currencyCode: FieldRef<"ServiceInvoice", 'String'>
    readonly exchangeRate: FieldRef<"ServiceInvoice", 'Float'>
    readonly isApproved: FieldRef<"ServiceInvoice", 'Boolean'>
    readonly approvedById: FieldRef<"ServiceInvoice", 'Int'>
    readonly isLocked: FieldRef<"ServiceInvoice", 'Boolean'>
    readonly lockedAt: FieldRef<"ServiceInvoice", 'DateTime'>
    readonly companyId: FieldRef<"ServiceInvoice", 'Int'>
    readonly createdAt: FieldRef<"ServiceInvoice", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceInvoice", 'DateTime'>
    readonly transactionId: FieldRef<"ServiceInvoice", 'Int'>
    readonly division: FieldRef<"ServiceInvoice", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServiceInvoice findUnique
   */
  export type ServiceInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoice
     */
    select?: ServiceInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoice
     */
    omit?: ServiceInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which ServiceInvoice to fetch.
     */
    where: ServiceInvoiceWhereUniqueInput
  }

  /**
   * ServiceInvoice findUniqueOrThrow
   */
  export type ServiceInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoice
     */
    select?: ServiceInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoice
     */
    omit?: ServiceInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which ServiceInvoice to fetch.
     */
    where: ServiceInvoiceWhereUniqueInput
  }

  /**
   * ServiceInvoice findFirst
   */
  export type ServiceInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoice
     */
    select?: ServiceInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoice
     */
    omit?: ServiceInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which ServiceInvoice to fetch.
     */
    where?: ServiceInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceInvoices to fetch.
     */
    orderBy?: ServiceInvoiceOrderByWithRelationInput | ServiceInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceInvoices.
     */
    cursor?: ServiceInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceInvoices.
     */
    distinct?: ServiceInvoiceScalarFieldEnum | ServiceInvoiceScalarFieldEnum[]
  }

  /**
   * ServiceInvoice findFirstOrThrow
   */
  export type ServiceInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoice
     */
    select?: ServiceInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoice
     */
    omit?: ServiceInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which ServiceInvoice to fetch.
     */
    where?: ServiceInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceInvoices to fetch.
     */
    orderBy?: ServiceInvoiceOrderByWithRelationInput | ServiceInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceInvoices.
     */
    cursor?: ServiceInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceInvoices.
     */
    distinct?: ServiceInvoiceScalarFieldEnum | ServiceInvoiceScalarFieldEnum[]
  }

  /**
   * ServiceInvoice findMany
   */
  export type ServiceInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoice
     */
    select?: ServiceInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoice
     */
    omit?: ServiceInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which ServiceInvoices to fetch.
     */
    where?: ServiceInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceInvoices to fetch.
     */
    orderBy?: ServiceInvoiceOrderByWithRelationInput | ServiceInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceInvoices.
     */
    cursor?: ServiceInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceInvoices.
     */
    skip?: number
    distinct?: ServiceInvoiceScalarFieldEnum | ServiceInvoiceScalarFieldEnum[]
  }

  /**
   * ServiceInvoice create
   */
  export type ServiceInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoice
     */
    select?: ServiceInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoice
     */
    omit?: ServiceInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceInvoice.
     */
    data: XOR<ServiceInvoiceCreateInput, ServiceInvoiceUncheckedCreateInput>
  }

  /**
   * ServiceInvoice createMany
   */
  export type ServiceInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceInvoices.
     */
    data: ServiceInvoiceCreateManyInput | ServiceInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceInvoice createManyAndReturn
   */
  export type ServiceInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoice
     */
    select?: ServiceInvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoice
     */
    omit?: ServiceInvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceInvoices.
     */
    data: ServiceInvoiceCreateManyInput | ServiceInvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceInvoice update
   */
  export type ServiceInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoice
     */
    select?: ServiceInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoice
     */
    omit?: ServiceInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceInvoice.
     */
    data: XOR<ServiceInvoiceUpdateInput, ServiceInvoiceUncheckedUpdateInput>
    /**
     * Choose, which ServiceInvoice to update.
     */
    where: ServiceInvoiceWhereUniqueInput
  }

  /**
   * ServiceInvoice updateMany
   */
  export type ServiceInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceInvoices.
     */
    data: XOR<ServiceInvoiceUpdateManyMutationInput, ServiceInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which ServiceInvoices to update
     */
    where?: ServiceInvoiceWhereInput
    /**
     * Limit how many ServiceInvoices to update.
     */
    limit?: number
  }

  /**
   * ServiceInvoice updateManyAndReturn
   */
  export type ServiceInvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoice
     */
    select?: ServiceInvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoice
     */
    omit?: ServiceInvoiceOmit<ExtArgs> | null
    /**
     * The data used to update ServiceInvoices.
     */
    data: XOR<ServiceInvoiceUpdateManyMutationInput, ServiceInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which ServiceInvoices to update
     */
    where?: ServiceInvoiceWhereInput
    /**
     * Limit how many ServiceInvoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceInvoice upsert
   */
  export type ServiceInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoice
     */
    select?: ServiceInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoice
     */
    omit?: ServiceInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceInvoice to update in case it exists.
     */
    where: ServiceInvoiceWhereUniqueInput
    /**
     * In case the ServiceInvoice found by the `where` argument doesn't exist, create a new ServiceInvoice with this data.
     */
    create: XOR<ServiceInvoiceCreateInput, ServiceInvoiceUncheckedCreateInput>
    /**
     * In case the ServiceInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceInvoiceUpdateInput, ServiceInvoiceUncheckedUpdateInput>
  }

  /**
   * ServiceInvoice delete
   */
  export type ServiceInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoice
     */
    select?: ServiceInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoice
     */
    omit?: ServiceInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceInclude<ExtArgs> | null
    /**
     * Filter which ServiceInvoice to delete.
     */
    where: ServiceInvoiceWhereUniqueInput
  }

  /**
   * ServiceInvoice deleteMany
   */
  export type ServiceInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceInvoices to delete
     */
    where?: ServiceInvoiceWhereInput
    /**
     * Limit how many ServiceInvoices to delete.
     */
    limit?: number
  }

  /**
   * ServiceInvoice.transaction
   */
  export type ServiceInvoice$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
  }

  /**
   * ServiceInvoice.items
   */
  export type ServiceInvoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoiceItem
     */
    select?: ServiceInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoiceItem
     */
    omit?: ServiceInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceItemInclude<ExtArgs> | null
    where?: ServiceInvoiceItemWhereInput
    orderBy?: ServiceInvoiceItemOrderByWithRelationInput | ServiceInvoiceItemOrderByWithRelationInput[]
    cursor?: ServiceInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceInvoiceItemScalarFieldEnum | ServiceInvoiceItemScalarFieldEnum[]
  }

  /**
   * ServiceInvoice without action
   */
  export type ServiceInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoice
     */
    select?: ServiceInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoice
     */
    omit?: ServiceInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model ServiceInvoiceItem
   */

  export type AggregateServiceInvoiceItem = {
    _count: ServiceInvoiceItemCountAggregateOutputType | null
    _avg: ServiceInvoiceItemAvgAggregateOutputType | null
    _sum: ServiceInvoiceItemSumAggregateOutputType | null
    _min: ServiceInvoiceItemMinAggregateOutputType | null
    _max: ServiceInvoiceItemMaxAggregateOutputType | null
  }

  export type ServiceInvoiceItemAvgAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    quantity: number | null
    rate: number | null
    amount: number | null
    taxPercentage: number | null
    taxAmount: number | null
    total: number | null
    productId: number | null
  }

  export type ServiceInvoiceItemSumAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    quantity: number | null
    rate: number | null
    amount: number | null
    taxPercentage: number | null
    taxAmount: number | null
    total: number | null
    productId: number | null
  }

  export type ServiceInvoiceItemMinAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    description: string | null
    quantity: number | null
    rate: number | null
    amount: number | null
    taxPercentage: number | null
    taxAmount: number | null
    total: number | null
    productId: number | null
  }

  export type ServiceInvoiceItemMaxAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    description: string | null
    quantity: number | null
    rate: number | null
    amount: number | null
    taxPercentage: number | null
    taxAmount: number | null
    total: number | null
    productId: number | null
  }

  export type ServiceInvoiceItemCountAggregateOutputType = {
    id: number
    invoiceId: number
    description: number
    quantity: number
    rate: number
    amount: number
    taxPercentage: number
    taxAmount: number
    total: number
    productId: number
    _all: number
  }


  export type ServiceInvoiceItemAvgAggregateInputType = {
    id?: true
    invoiceId?: true
    quantity?: true
    rate?: true
    amount?: true
    taxPercentage?: true
    taxAmount?: true
    total?: true
    productId?: true
  }

  export type ServiceInvoiceItemSumAggregateInputType = {
    id?: true
    invoiceId?: true
    quantity?: true
    rate?: true
    amount?: true
    taxPercentage?: true
    taxAmount?: true
    total?: true
    productId?: true
  }

  export type ServiceInvoiceItemMinAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    rate?: true
    amount?: true
    taxPercentage?: true
    taxAmount?: true
    total?: true
    productId?: true
  }

  export type ServiceInvoiceItemMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    rate?: true
    amount?: true
    taxPercentage?: true
    taxAmount?: true
    total?: true
    productId?: true
  }

  export type ServiceInvoiceItemCountAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    rate?: true
    amount?: true
    taxPercentage?: true
    taxAmount?: true
    total?: true
    productId?: true
    _all?: true
  }

  export type ServiceInvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceInvoiceItem to aggregate.
     */
    where?: ServiceInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceInvoiceItems to fetch.
     */
    orderBy?: ServiceInvoiceItemOrderByWithRelationInput | ServiceInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceInvoiceItems
    **/
    _count?: true | ServiceInvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceInvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceInvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceInvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceInvoiceItemMaxAggregateInputType
  }

  export type GetServiceInvoiceItemAggregateType<T extends ServiceInvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceInvoiceItem[P]>
      : GetScalarType<T[P], AggregateServiceInvoiceItem[P]>
  }




  export type ServiceInvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceInvoiceItemWhereInput
    orderBy?: ServiceInvoiceItemOrderByWithAggregationInput | ServiceInvoiceItemOrderByWithAggregationInput[]
    by: ServiceInvoiceItemScalarFieldEnum[] | ServiceInvoiceItemScalarFieldEnum
    having?: ServiceInvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceInvoiceItemCountAggregateInputType | true
    _avg?: ServiceInvoiceItemAvgAggregateInputType
    _sum?: ServiceInvoiceItemSumAggregateInputType
    _min?: ServiceInvoiceItemMinAggregateInputType
    _max?: ServiceInvoiceItemMaxAggregateInputType
  }

  export type ServiceInvoiceItemGroupByOutputType = {
    id: number
    invoiceId: number
    description: string
    quantity: number
    rate: number
    amount: number
    taxPercentage: number
    taxAmount: number
    total: number
    productId: number | null
    _count: ServiceInvoiceItemCountAggregateOutputType | null
    _avg: ServiceInvoiceItemAvgAggregateOutputType | null
    _sum: ServiceInvoiceItemSumAggregateOutputType | null
    _min: ServiceInvoiceItemMinAggregateOutputType | null
    _max: ServiceInvoiceItemMaxAggregateOutputType | null
  }

  type GetServiceInvoiceItemGroupByPayload<T extends ServiceInvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceInvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceInvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceInvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceInvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type ServiceInvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    rate?: boolean
    amount?: boolean
    taxPercentage?: boolean
    taxAmount?: boolean
    total?: boolean
    productId?: boolean
    invoice?: boolean | ServiceInvoiceDefaultArgs<ExtArgs>
    product?: boolean | ServiceInvoiceItem$productArgs<ExtArgs>
  }, ExtArgs["result"]["serviceInvoiceItem"]>

  export type ServiceInvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    rate?: boolean
    amount?: boolean
    taxPercentage?: boolean
    taxAmount?: boolean
    total?: boolean
    productId?: boolean
    invoice?: boolean | ServiceInvoiceDefaultArgs<ExtArgs>
    product?: boolean | ServiceInvoiceItem$productArgs<ExtArgs>
  }, ExtArgs["result"]["serviceInvoiceItem"]>

  export type ServiceInvoiceItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    rate?: boolean
    amount?: boolean
    taxPercentage?: boolean
    taxAmount?: boolean
    total?: boolean
    productId?: boolean
    invoice?: boolean | ServiceInvoiceDefaultArgs<ExtArgs>
    product?: boolean | ServiceInvoiceItem$productArgs<ExtArgs>
  }, ExtArgs["result"]["serviceInvoiceItem"]>

  export type ServiceInvoiceItemSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    rate?: boolean
    amount?: boolean
    taxPercentage?: boolean
    taxAmount?: boolean
    total?: boolean
    productId?: boolean
  }

  export type ServiceInvoiceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "description" | "quantity" | "rate" | "amount" | "taxPercentage" | "taxAmount" | "total" | "productId", ExtArgs["result"]["serviceInvoiceItem"]>
  export type ServiceInvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | ServiceInvoiceDefaultArgs<ExtArgs>
    product?: boolean | ServiceInvoiceItem$productArgs<ExtArgs>
  }
  export type ServiceInvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | ServiceInvoiceDefaultArgs<ExtArgs>
    product?: boolean | ServiceInvoiceItem$productArgs<ExtArgs>
  }
  export type ServiceInvoiceItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | ServiceInvoiceDefaultArgs<ExtArgs>
    product?: boolean | ServiceInvoiceItem$productArgs<ExtArgs>
  }

  export type $ServiceInvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceInvoiceItem"
    objects: {
      invoice: Prisma.$ServiceInvoicePayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoiceId: number
      description: string
      quantity: number
      rate: number
      amount: number
      taxPercentage: number
      taxAmount: number
      total: number
      productId: number | null
    }, ExtArgs["result"]["serviceInvoiceItem"]>
    composites: {}
  }

  type ServiceInvoiceItemGetPayload<S extends boolean | null | undefined | ServiceInvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$ServiceInvoiceItemPayload, S>

  type ServiceInvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceInvoiceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceInvoiceItemCountAggregateInputType | true
    }

  export interface ServiceInvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceInvoiceItem'], meta: { name: 'ServiceInvoiceItem' } }
    /**
     * Find zero or one ServiceInvoiceItem that matches the filter.
     * @param {ServiceInvoiceItemFindUniqueArgs} args - Arguments to find a ServiceInvoiceItem
     * @example
     * // Get one ServiceInvoiceItem
     * const serviceInvoiceItem = await prisma.serviceInvoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceInvoiceItemFindUniqueArgs>(args: SelectSubset<T, ServiceInvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__ServiceInvoiceItemClient<$Result.GetResult<Prisma.$ServiceInvoiceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceInvoiceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceInvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a ServiceInvoiceItem
     * @example
     * // Get one ServiceInvoiceItem
     * const serviceInvoiceItem = await prisma.serviceInvoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceInvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceInvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceInvoiceItemClient<$Result.GetResult<Prisma.$ServiceInvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceInvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInvoiceItemFindFirstArgs} args - Arguments to find a ServiceInvoiceItem
     * @example
     * // Get one ServiceInvoiceItem
     * const serviceInvoiceItem = await prisma.serviceInvoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceInvoiceItemFindFirstArgs>(args?: SelectSubset<T, ServiceInvoiceItemFindFirstArgs<ExtArgs>>): Prisma__ServiceInvoiceItemClient<$Result.GetResult<Prisma.$ServiceInvoiceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceInvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInvoiceItemFindFirstOrThrowArgs} args - Arguments to find a ServiceInvoiceItem
     * @example
     * // Get one ServiceInvoiceItem
     * const serviceInvoiceItem = await prisma.serviceInvoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceInvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceInvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceInvoiceItemClient<$Result.GetResult<Prisma.$ServiceInvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceInvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceInvoiceItems
     * const serviceInvoiceItems = await prisma.serviceInvoiceItem.findMany()
     * 
     * // Get first 10 ServiceInvoiceItems
     * const serviceInvoiceItems = await prisma.serviceInvoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceInvoiceItemWithIdOnly = await prisma.serviceInvoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceInvoiceItemFindManyArgs>(args?: SelectSubset<T, ServiceInvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceInvoiceItem.
     * @param {ServiceInvoiceItemCreateArgs} args - Arguments to create a ServiceInvoiceItem.
     * @example
     * // Create one ServiceInvoiceItem
     * const ServiceInvoiceItem = await prisma.serviceInvoiceItem.create({
     *   data: {
     *     // ... data to create a ServiceInvoiceItem
     *   }
     * })
     * 
     */
    create<T extends ServiceInvoiceItemCreateArgs>(args: SelectSubset<T, ServiceInvoiceItemCreateArgs<ExtArgs>>): Prisma__ServiceInvoiceItemClient<$Result.GetResult<Prisma.$ServiceInvoiceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceInvoiceItems.
     * @param {ServiceInvoiceItemCreateManyArgs} args - Arguments to create many ServiceInvoiceItems.
     * @example
     * // Create many ServiceInvoiceItems
     * const serviceInvoiceItem = await prisma.serviceInvoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceInvoiceItemCreateManyArgs>(args?: SelectSubset<T, ServiceInvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceInvoiceItems and returns the data saved in the database.
     * @param {ServiceInvoiceItemCreateManyAndReturnArgs} args - Arguments to create many ServiceInvoiceItems.
     * @example
     * // Create many ServiceInvoiceItems
     * const serviceInvoiceItem = await prisma.serviceInvoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceInvoiceItems and only return the `id`
     * const serviceInvoiceItemWithIdOnly = await prisma.serviceInvoiceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceInvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceInvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceInvoiceItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceInvoiceItem.
     * @param {ServiceInvoiceItemDeleteArgs} args - Arguments to delete one ServiceInvoiceItem.
     * @example
     * // Delete one ServiceInvoiceItem
     * const ServiceInvoiceItem = await prisma.serviceInvoiceItem.delete({
     *   where: {
     *     // ... filter to delete one ServiceInvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends ServiceInvoiceItemDeleteArgs>(args: SelectSubset<T, ServiceInvoiceItemDeleteArgs<ExtArgs>>): Prisma__ServiceInvoiceItemClient<$Result.GetResult<Prisma.$ServiceInvoiceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceInvoiceItem.
     * @param {ServiceInvoiceItemUpdateArgs} args - Arguments to update one ServiceInvoiceItem.
     * @example
     * // Update one ServiceInvoiceItem
     * const serviceInvoiceItem = await prisma.serviceInvoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceInvoiceItemUpdateArgs>(args: SelectSubset<T, ServiceInvoiceItemUpdateArgs<ExtArgs>>): Prisma__ServiceInvoiceItemClient<$Result.GetResult<Prisma.$ServiceInvoiceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceInvoiceItems.
     * @param {ServiceInvoiceItemDeleteManyArgs} args - Arguments to filter ServiceInvoiceItems to delete.
     * @example
     * // Delete a few ServiceInvoiceItems
     * const { count } = await prisma.serviceInvoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceInvoiceItemDeleteManyArgs>(args?: SelectSubset<T, ServiceInvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceInvoiceItems
     * const serviceInvoiceItem = await prisma.serviceInvoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceInvoiceItemUpdateManyArgs>(args: SelectSubset<T, ServiceInvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceInvoiceItems and returns the data updated in the database.
     * @param {ServiceInvoiceItemUpdateManyAndReturnArgs} args - Arguments to update many ServiceInvoiceItems.
     * @example
     * // Update many ServiceInvoiceItems
     * const serviceInvoiceItem = await prisma.serviceInvoiceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceInvoiceItems and only return the `id`
     * const serviceInvoiceItemWithIdOnly = await prisma.serviceInvoiceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceInvoiceItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceInvoiceItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceInvoiceItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceInvoiceItem.
     * @param {ServiceInvoiceItemUpsertArgs} args - Arguments to update or create a ServiceInvoiceItem.
     * @example
     * // Update or create a ServiceInvoiceItem
     * const serviceInvoiceItem = await prisma.serviceInvoiceItem.upsert({
     *   create: {
     *     // ... data to create a ServiceInvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceInvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends ServiceInvoiceItemUpsertArgs>(args: SelectSubset<T, ServiceInvoiceItemUpsertArgs<ExtArgs>>): Prisma__ServiceInvoiceItemClient<$Result.GetResult<Prisma.$ServiceInvoiceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInvoiceItemCountArgs} args - Arguments to filter ServiceInvoiceItems to count.
     * @example
     * // Count the number of ServiceInvoiceItems
     * const count = await prisma.serviceInvoiceItem.count({
     *   where: {
     *     // ... the filter for the ServiceInvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends ServiceInvoiceItemCountArgs>(
      args?: Subset<T, ServiceInvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceInvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceInvoiceItemAggregateArgs>(args: Subset<T, ServiceInvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetServiceInvoiceItemAggregateType<T>>

    /**
     * Group by ServiceInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceInvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceInvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: ServiceInvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceInvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceInvoiceItem model
   */
  readonly fields: ServiceInvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceInvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceInvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends ServiceInvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceInvoiceDefaultArgs<ExtArgs>>): Prisma__ServiceInvoiceClient<$Result.GetResult<Prisma.$ServiceInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ServiceInvoiceItem$productArgs<ExtArgs> = {}>(args?: Subset<T, ServiceInvoiceItem$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceInvoiceItem model
   */
  interface ServiceInvoiceItemFieldRefs {
    readonly id: FieldRef<"ServiceInvoiceItem", 'Int'>
    readonly invoiceId: FieldRef<"ServiceInvoiceItem", 'Int'>
    readonly description: FieldRef<"ServiceInvoiceItem", 'String'>
    readonly quantity: FieldRef<"ServiceInvoiceItem", 'Float'>
    readonly rate: FieldRef<"ServiceInvoiceItem", 'Float'>
    readonly amount: FieldRef<"ServiceInvoiceItem", 'Float'>
    readonly taxPercentage: FieldRef<"ServiceInvoiceItem", 'Float'>
    readonly taxAmount: FieldRef<"ServiceInvoiceItem", 'Float'>
    readonly total: FieldRef<"ServiceInvoiceItem", 'Float'>
    readonly productId: FieldRef<"ServiceInvoiceItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ServiceInvoiceItem findUnique
   */
  export type ServiceInvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoiceItem
     */
    select?: ServiceInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoiceItem
     */
    omit?: ServiceInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which ServiceInvoiceItem to fetch.
     */
    where: ServiceInvoiceItemWhereUniqueInput
  }

  /**
   * ServiceInvoiceItem findUniqueOrThrow
   */
  export type ServiceInvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoiceItem
     */
    select?: ServiceInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoiceItem
     */
    omit?: ServiceInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which ServiceInvoiceItem to fetch.
     */
    where: ServiceInvoiceItemWhereUniqueInput
  }

  /**
   * ServiceInvoiceItem findFirst
   */
  export type ServiceInvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoiceItem
     */
    select?: ServiceInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoiceItem
     */
    omit?: ServiceInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which ServiceInvoiceItem to fetch.
     */
    where?: ServiceInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceInvoiceItems to fetch.
     */
    orderBy?: ServiceInvoiceItemOrderByWithRelationInput | ServiceInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceInvoiceItems.
     */
    cursor?: ServiceInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceInvoiceItems.
     */
    distinct?: ServiceInvoiceItemScalarFieldEnum | ServiceInvoiceItemScalarFieldEnum[]
  }

  /**
   * ServiceInvoiceItem findFirstOrThrow
   */
  export type ServiceInvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoiceItem
     */
    select?: ServiceInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoiceItem
     */
    omit?: ServiceInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which ServiceInvoiceItem to fetch.
     */
    where?: ServiceInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceInvoiceItems to fetch.
     */
    orderBy?: ServiceInvoiceItemOrderByWithRelationInput | ServiceInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceInvoiceItems.
     */
    cursor?: ServiceInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceInvoiceItems.
     */
    distinct?: ServiceInvoiceItemScalarFieldEnum | ServiceInvoiceItemScalarFieldEnum[]
  }

  /**
   * ServiceInvoiceItem findMany
   */
  export type ServiceInvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoiceItem
     */
    select?: ServiceInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoiceItem
     */
    omit?: ServiceInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which ServiceInvoiceItems to fetch.
     */
    where?: ServiceInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceInvoiceItems to fetch.
     */
    orderBy?: ServiceInvoiceItemOrderByWithRelationInput | ServiceInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceInvoiceItems.
     */
    cursor?: ServiceInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceInvoiceItems.
     */
    skip?: number
    distinct?: ServiceInvoiceItemScalarFieldEnum | ServiceInvoiceItemScalarFieldEnum[]
  }

  /**
   * ServiceInvoiceItem create
   */
  export type ServiceInvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoiceItem
     */
    select?: ServiceInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoiceItem
     */
    omit?: ServiceInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceInvoiceItem.
     */
    data: XOR<ServiceInvoiceItemCreateInput, ServiceInvoiceItemUncheckedCreateInput>
  }

  /**
   * ServiceInvoiceItem createMany
   */
  export type ServiceInvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceInvoiceItems.
     */
    data: ServiceInvoiceItemCreateManyInput | ServiceInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceInvoiceItem createManyAndReturn
   */
  export type ServiceInvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoiceItem
     */
    select?: ServiceInvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoiceItem
     */
    omit?: ServiceInvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceInvoiceItems.
     */
    data: ServiceInvoiceItemCreateManyInput | ServiceInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceInvoiceItem update
   */
  export type ServiceInvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoiceItem
     */
    select?: ServiceInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoiceItem
     */
    omit?: ServiceInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceInvoiceItem.
     */
    data: XOR<ServiceInvoiceItemUpdateInput, ServiceInvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which ServiceInvoiceItem to update.
     */
    where: ServiceInvoiceItemWhereUniqueInput
  }

  /**
   * ServiceInvoiceItem updateMany
   */
  export type ServiceInvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceInvoiceItems.
     */
    data: XOR<ServiceInvoiceItemUpdateManyMutationInput, ServiceInvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which ServiceInvoiceItems to update
     */
    where?: ServiceInvoiceItemWhereInput
    /**
     * Limit how many ServiceInvoiceItems to update.
     */
    limit?: number
  }

  /**
   * ServiceInvoiceItem updateManyAndReturn
   */
  export type ServiceInvoiceItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoiceItem
     */
    select?: ServiceInvoiceItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoiceItem
     */
    omit?: ServiceInvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to update ServiceInvoiceItems.
     */
    data: XOR<ServiceInvoiceItemUpdateManyMutationInput, ServiceInvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which ServiceInvoiceItems to update
     */
    where?: ServiceInvoiceItemWhereInput
    /**
     * Limit how many ServiceInvoiceItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceInvoiceItem upsert
   */
  export type ServiceInvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoiceItem
     */
    select?: ServiceInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoiceItem
     */
    omit?: ServiceInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceInvoiceItem to update in case it exists.
     */
    where: ServiceInvoiceItemWhereUniqueInput
    /**
     * In case the ServiceInvoiceItem found by the `where` argument doesn't exist, create a new ServiceInvoiceItem with this data.
     */
    create: XOR<ServiceInvoiceItemCreateInput, ServiceInvoiceItemUncheckedCreateInput>
    /**
     * In case the ServiceInvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceInvoiceItemUpdateInput, ServiceInvoiceItemUncheckedUpdateInput>
  }

  /**
   * ServiceInvoiceItem delete
   */
  export type ServiceInvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoiceItem
     */
    select?: ServiceInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoiceItem
     */
    omit?: ServiceInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which ServiceInvoiceItem to delete.
     */
    where: ServiceInvoiceItemWhereUniqueInput
  }

  /**
   * ServiceInvoiceItem deleteMany
   */
  export type ServiceInvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceInvoiceItems to delete
     */
    where?: ServiceInvoiceItemWhereInput
    /**
     * Limit how many ServiceInvoiceItems to delete.
     */
    limit?: number
  }

  /**
   * ServiceInvoiceItem.product
   */
  export type ServiceInvoiceItem$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * ServiceInvoiceItem without action
   */
  export type ServiceInvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoiceItem
     */
    select?: ServiceInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoiceItem
     */
    omit?: ServiceInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model FreightInvoice
   */

  export type AggregateFreightInvoice = {
    _count: FreightInvoiceCountAggregateOutputType | null
    _avg: FreightInvoiceAvgAggregateOutputType | null
    _sum: FreightInvoiceSumAggregateOutputType | null
    _min: FreightInvoiceMinAggregateOutputType | null
    _max: FreightInvoiceMaxAggregateOutputType | null
  }

  export type FreightInvoiceAvgAggregateOutputType = {
    id: number | null
    jobId: number | null
    customerId: number | null
    usdRate: number | null
    exchangeRate: number | null
    totalAmount: number | null
    taxAmount: number | null
    grandTotal: number | null
    approvedById: number | null
    companyId: number | null
    transactionId: number | null
  }

  export type FreightInvoiceSumAggregateOutputType = {
    id: number | null
    jobId: number | null
    customerId: number | null
    usdRate: number | null
    exchangeRate: number | null
    totalAmount: number | null
    taxAmount: number | null
    grandTotal: number | null
    approvedById: number | null
    companyId: number | null
    transactionId: number | null
  }

  export type FreightInvoiceMinAggregateOutputType = {
    id: number | null
    invoiceNumber: string | null
    date: Date | null
    jobId: number | null
    customerId: number | null
    type: $Enums.InvoiceType | null
    status: $Enums.InvoiceStatus | null
    usdRate: number | null
    exchangeRate: number | null
    totalAmount: number | null
    taxAmount: number | null
    grandTotal: number | null
    currencyCode: string | null
    isApproved: boolean | null
    approvedById: number | null
    isLocked: boolean | null
    lockedAt: Date | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    transactionId: number | null
    division: string | null
  }

  export type FreightInvoiceMaxAggregateOutputType = {
    id: number | null
    invoiceNumber: string | null
    date: Date | null
    jobId: number | null
    customerId: number | null
    type: $Enums.InvoiceType | null
    status: $Enums.InvoiceStatus | null
    usdRate: number | null
    exchangeRate: number | null
    totalAmount: number | null
    taxAmount: number | null
    grandTotal: number | null
    currencyCode: string | null
    isApproved: boolean | null
    approvedById: number | null
    isLocked: boolean | null
    lockedAt: Date | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    transactionId: number | null
    division: string | null
  }

  export type FreightInvoiceCountAggregateOutputType = {
    id: number
    invoiceNumber: number
    date: number
    jobId: number
    customerId: number
    type: number
    status: number
    usdRate: number
    exchangeRate: number
    totalAmount: number
    taxAmount: number
    grandTotal: number
    currencyCode: number
    isApproved: number
    approvedById: number
    isLocked: number
    lockedAt: number
    companyId: number
    createdAt: number
    updatedAt: number
    transactionId: number
    division: number
    _all: number
  }


  export type FreightInvoiceAvgAggregateInputType = {
    id?: true
    jobId?: true
    customerId?: true
    usdRate?: true
    exchangeRate?: true
    totalAmount?: true
    taxAmount?: true
    grandTotal?: true
    approvedById?: true
    companyId?: true
    transactionId?: true
  }

  export type FreightInvoiceSumAggregateInputType = {
    id?: true
    jobId?: true
    customerId?: true
    usdRate?: true
    exchangeRate?: true
    totalAmount?: true
    taxAmount?: true
    grandTotal?: true
    approvedById?: true
    companyId?: true
    transactionId?: true
  }

  export type FreightInvoiceMinAggregateInputType = {
    id?: true
    invoiceNumber?: true
    date?: true
    jobId?: true
    customerId?: true
    type?: true
    status?: true
    usdRate?: true
    exchangeRate?: true
    totalAmount?: true
    taxAmount?: true
    grandTotal?: true
    currencyCode?: true
    isApproved?: true
    approvedById?: true
    isLocked?: true
    lockedAt?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    transactionId?: true
    division?: true
  }

  export type FreightInvoiceMaxAggregateInputType = {
    id?: true
    invoiceNumber?: true
    date?: true
    jobId?: true
    customerId?: true
    type?: true
    status?: true
    usdRate?: true
    exchangeRate?: true
    totalAmount?: true
    taxAmount?: true
    grandTotal?: true
    currencyCode?: true
    isApproved?: true
    approvedById?: true
    isLocked?: true
    lockedAt?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    transactionId?: true
    division?: true
  }

  export type FreightInvoiceCountAggregateInputType = {
    id?: true
    invoiceNumber?: true
    date?: true
    jobId?: true
    customerId?: true
    type?: true
    status?: true
    usdRate?: true
    exchangeRate?: true
    totalAmount?: true
    taxAmount?: true
    grandTotal?: true
    currencyCode?: true
    isApproved?: true
    approvedById?: true
    isLocked?: true
    lockedAt?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    transactionId?: true
    division?: true
    _all?: true
  }

  export type FreightInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FreightInvoice to aggregate.
     */
    where?: FreightInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreightInvoices to fetch.
     */
    orderBy?: FreightInvoiceOrderByWithRelationInput | FreightInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FreightInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreightInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreightInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FreightInvoices
    **/
    _count?: true | FreightInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FreightInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FreightInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FreightInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FreightInvoiceMaxAggregateInputType
  }

  export type GetFreightInvoiceAggregateType<T extends FreightInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateFreightInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFreightInvoice[P]>
      : GetScalarType<T[P], AggregateFreightInvoice[P]>
  }




  export type FreightInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FreightInvoiceWhereInput
    orderBy?: FreightInvoiceOrderByWithAggregationInput | FreightInvoiceOrderByWithAggregationInput[]
    by: FreightInvoiceScalarFieldEnum[] | FreightInvoiceScalarFieldEnum
    having?: FreightInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FreightInvoiceCountAggregateInputType | true
    _avg?: FreightInvoiceAvgAggregateInputType
    _sum?: FreightInvoiceSumAggregateInputType
    _min?: FreightInvoiceMinAggregateInputType
    _max?: FreightInvoiceMaxAggregateInputType
  }

  export type FreightInvoiceGroupByOutputType = {
    id: number
    invoiceNumber: string
    date: Date
    jobId: number | null
    customerId: number
    type: $Enums.InvoiceType
    status: $Enums.InvoiceStatus
    usdRate: number
    exchangeRate: number
    totalAmount: number
    taxAmount: number
    grandTotal: number
    currencyCode: string
    isApproved: boolean
    approvedById: number | null
    isLocked: boolean
    lockedAt: Date | null
    companyId: number
    createdAt: Date
    updatedAt: Date
    transactionId: number | null
    division: string | null
    _count: FreightInvoiceCountAggregateOutputType | null
    _avg: FreightInvoiceAvgAggregateOutputType | null
    _sum: FreightInvoiceSumAggregateOutputType | null
    _min: FreightInvoiceMinAggregateOutputType | null
    _max: FreightInvoiceMaxAggregateOutputType | null
  }

  type GetFreightInvoiceGroupByPayload<T extends FreightInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FreightInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FreightInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FreightInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], FreightInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type FreightInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    date?: boolean
    jobId?: boolean
    customerId?: boolean
    type?: boolean
    status?: boolean
    usdRate?: boolean
    exchangeRate?: boolean
    totalAmount?: boolean
    taxAmount?: boolean
    grandTotal?: boolean
    currencyCode?: boolean
    isApproved?: boolean
    approvedById?: boolean
    isLocked?: boolean
    lockedAt?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactionId?: boolean
    division?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    transaction?: boolean | FreightInvoice$transactionArgs<ExtArgs>
    job?: boolean | FreightInvoice$jobArgs<ExtArgs>
    items?: boolean | FreightInvoice$itemsArgs<ExtArgs>
    _count?: boolean | FreightInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["freightInvoice"]>

  export type FreightInvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    date?: boolean
    jobId?: boolean
    customerId?: boolean
    type?: boolean
    status?: boolean
    usdRate?: boolean
    exchangeRate?: boolean
    totalAmount?: boolean
    taxAmount?: boolean
    grandTotal?: boolean
    currencyCode?: boolean
    isApproved?: boolean
    approvedById?: boolean
    isLocked?: boolean
    lockedAt?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactionId?: boolean
    division?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    transaction?: boolean | FreightInvoice$transactionArgs<ExtArgs>
    job?: boolean | FreightInvoice$jobArgs<ExtArgs>
  }, ExtArgs["result"]["freightInvoice"]>

  export type FreightInvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    date?: boolean
    jobId?: boolean
    customerId?: boolean
    type?: boolean
    status?: boolean
    usdRate?: boolean
    exchangeRate?: boolean
    totalAmount?: boolean
    taxAmount?: boolean
    grandTotal?: boolean
    currencyCode?: boolean
    isApproved?: boolean
    approvedById?: boolean
    isLocked?: boolean
    lockedAt?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactionId?: boolean
    division?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    transaction?: boolean | FreightInvoice$transactionArgs<ExtArgs>
    job?: boolean | FreightInvoice$jobArgs<ExtArgs>
  }, ExtArgs["result"]["freightInvoice"]>

  export type FreightInvoiceSelectScalar = {
    id?: boolean
    invoiceNumber?: boolean
    date?: boolean
    jobId?: boolean
    customerId?: boolean
    type?: boolean
    status?: boolean
    usdRate?: boolean
    exchangeRate?: boolean
    totalAmount?: boolean
    taxAmount?: boolean
    grandTotal?: boolean
    currencyCode?: boolean
    isApproved?: boolean
    approvedById?: boolean
    isLocked?: boolean
    lockedAt?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactionId?: boolean
    division?: boolean
  }

  export type FreightInvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceNumber" | "date" | "jobId" | "customerId" | "type" | "status" | "usdRate" | "exchangeRate" | "totalAmount" | "taxAmount" | "grandTotal" | "currencyCode" | "isApproved" | "approvedById" | "isLocked" | "lockedAt" | "companyId" | "createdAt" | "updatedAt" | "transactionId" | "division", ExtArgs["result"]["freightInvoice"]>
  export type FreightInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    transaction?: boolean | FreightInvoice$transactionArgs<ExtArgs>
    job?: boolean | FreightInvoice$jobArgs<ExtArgs>
    items?: boolean | FreightInvoice$itemsArgs<ExtArgs>
    _count?: boolean | FreightInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FreightInvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    transaction?: boolean | FreightInvoice$transactionArgs<ExtArgs>
    job?: boolean | FreightInvoice$jobArgs<ExtArgs>
  }
  export type FreightInvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    transaction?: boolean | FreightInvoice$transactionArgs<ExtArgs>
    job?: boolean | FreightInvoice$jobArgs<ExtArgs>
  }

  export type $FreightInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FreightInvoice"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs>
      transaction: Prisma.$TransactionPayload<ExtArgs> | null
      job: Prisma.$JobPayload<ExtArgs> | null
      items: Prisma.$FreightInvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoiceNumber: string
      date: Date
      jobId: number | null
      customerId: number
      type: $Enums.InvoiceType
      status: $Enums.InvoiceStatus
      usdRate: number
      exchangeRate: number
      totalAmount: number
      taxAmount: number
      grandTotal: number
      currencyCode: string
      isApproved: boolean
      approvedById: number | null
      isLocked: boolean
      lockedAt: Date | null
      companyId: number
      createdAt: Date
      updatedAt: Date
      transactionId: number | null
      division: string | null
    }, ExtArgs["result"]["freightInvoice"]>
    composites: {}
  }

  type FreightInvoiceGetPayload<S extends boolean | null | undefined | FreightInvoiceDefaultArgs> = $Result.GetResult<Prisma.$FreightInvoicePayload, S>

  type FreightInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FreightInvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FreightInvoiceCountAggregateInputType | true
    }

  export interface FreightInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FreightInvoice'], meta: { name: 'FreightInvoice' } }
    /**
     * Find zero or one FreightInvoice that matches the filter.
     * @param {FreightInvoiceFindUniqueArgs} args - Arguments to find a FreightInvoice
     * @example
     * // Get one FreightInvoice
     * const freightInvoice = await prisma.freightInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FreightInvoiceFindUniqueArgs>(args: SelectSubset<T, FreightInvoiceFindUniqueArgs<ExtArgs>>): Prisma__FreightInvoiceClient<$Result.GetResult<Prisma.$FreightInvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FreightInvoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FreightInvoiceFindUniqueOrThrowArgs} args - Arguments to find a FreightInvoice
     * @example
     * // Get one FreightInvoice
     * const freightInvoice = await prisma.freightInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FreightInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, FreightInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FreightInvoiceClient<$Result.GetResult<Prisma.$FreightInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FreightInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreightInvoiceFindFirstArgs} args - Arguments to find a FreightInvoice
     * @example
     * // Get one FreightInvoice
     * const freightInvoice = await prisma.freightInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FreightInvoiceFindFirstArgs>(args?: SelectSubset<T, FreightInvoiceFindFirstArgs<ExtArgs>>): Prisma__FreightInvoiceClient<$Result.GetResult<Prisma.$FreightInvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FreightInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreightInvoiceFindFirstOrThrowArgs} args - Arguments to find a FreightInvoice
     * @example
     * // Get one FreightInvoice
     * const freightInvoice = await prisma.freightInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FreightInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, FreightInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__FreightInvoiceClient<$Result.GetResult<Prisma.$FreightInvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FreightInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreightInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FreightInvoices
     * const freightInvoices = await prisma.freightInvoice.findMany()
     * 
     * // Get first 10 FreightInvoices
     * const freightInvoices = await prisma.freightInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const freightInvoiceWithIdOnly = await prisma.freightInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FreightInvoiceFindManyArgs>(args?: SelectSubset<T, FreightInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreightInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FreightInvoice.
     * @param {FreightInvoiceCreateArgs} args - Arguments to create a FreightInvoice.
     * @example
     * // Create one FreightInvoice
     * const FreightInvoice = await prisma.freightInvoice.create({
     *   data: {
     *     // ... data to create a FreightInvoice
     *   }
     * })
     * 
     */
    create<T extends FreightInvoiceCreateArgs>(args: SelectSubset<T, FreightInvoiceCreateArgs<ExtArgs>>): Prisma__FreightInvoiceClient<$Result.GetResult<Prisma.$FreightInvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FreightInvoices.
     * @param {FreightInvoiceCreateManyArgs} args - Arguments to create many FreightInvoices.
     * @example
     * // Create many FreightInvoices
     * const freightInvoice = await prisma.freightInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FreightInvoiceCreateManyArgs>(args?: SelectSubset<T, FreightInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FreightInvoices and returns the data saved in the database.
     * @param {FreightInvoiceCreateManyAndReturnArgs} args - Arguments to create many FreightInvoices.
     * @example
     * // Create many FreightInvoices
     * const freightInvoice = await prisma.freightInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FreightInvoices and only return the `id`
     * const freightInvoiceWithIdOnly = await prisma.freightInvoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FreightInvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, FreightInvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreightInvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FreightInvoice.
     * @param {FreightInvoiceDeleteArgs} args - Arguments to delete one FreightInvoice.
     * @example
     * // Delete one FreightInvoice
     * const FreightInvoice = await prisma.freightInvoice.delete({
     *   where: {
     *     // ... filter to delete one FreightInvoice
     *   }
     * })
     * 
     */
    delete<T extends FreightInvoiceDeleteArgs>(args: SelectSubset<T, FreightInvoiceDeleteArgs<ExtArgs>>): Prisma__FreightInvoiceClient<$Result.GetResult<Prisma.$FreightInvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FreightInvoice.
     * @param {FreightInvoiceUpdateArgs} args - Arguments to update one FreightInvoice.
     * @example
     * // Update one FreightInvoice
     * const freightInvoice = await prisma.freightInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FreightInvoiceUpdateArgs>(args: SelectSubset<T, FreightInvoiceUpdateArgs<ExtArgs>>): Prisma__FreightInvoiceClient<$Result.GetResult<Prisma.$FreightInvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FreightInvoices.
     * @param {FreightInvoiceDeleteManyArgs} args - Arguments to filter FreightInvoices to delete.
     * @example
     * // Delete a few FreightInvoices
     * const { count } = await prisma.freightInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FreightInvoiceDeleteManyArgs>(args?: SelectSubset<T, FreightInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FreightInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreightInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FreightInvoices
     * const freightInvoice = await prisma.freightInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FreightInvoiceUpdateManyArgs>(args: SelectSubset<T, FreightInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FreightInvoices and returns the data updated in the database.
     * @param {FreightInvoiceUpdateManyAndReturnArgs} args - Arguments to update many FreightInvoices.
     * @example
     * // Update many FreightInvoices
     * const freightInvoice = await prisma.freightInvoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FreightInvoices and only return the `id`
     * const freightInvoiceWithIdOnly = await prisma.freightInvoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FreightInvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, FreightInvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreightInvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FreightInvoice.
     * @param {FreightInvoiceUpsertArgs} args - Arguments to update or create a FreightInvoice.
     * @example
     * // Update or create a FreightInvoice
     * const freightInvoice = await prisma.freightInvoice.upsert({
     *   create: {
     *     // ... data to create a FreightInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FreightInvoice we want to update
     *   }
     * })
     */
    upsert<T extends FreightInvoiceUpsertArgs>(args: SelectSubset<T, FreightInvoiceUpsertArgs<ExtArgs>>): Prisma__FreightInvoiceClient<$Result.GetResult<Prisma.$FreightInvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FreightInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreightInvoiceCountArgs} args - Arguments to filter FreightInvoices to count.
     * @example
     * // Count the number of FreightInvoices
     * const count = await prisma.freightInvoice.count({
     *   where: {
     *     // ... the filter for the FreightInvoices we want to count
     *   }
     * })
    **/
    count<T extends FreightInvoiceCountArgs>(
      args?: Subset<T, FreightInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FreightInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FreightInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreightInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FreightInvoiceAggregateArgs>(args: Subset<T, FreightInvoiceAggregateArgs>): Prisma.PrismaPromise<GetFreightInvoiceAggregateType<T>>

    /**
     * Group by FreightInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreightInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FreightInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FreightInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: FreightInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FreightInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFreightInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FreightInvoice model
   */
  readonly fields: FreightInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FreightInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FreightInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transaction<T extends FreightInvoice$transactionArgs<ExtArgs> = {}>(args?: Subset<T, FreightInvoice$transactionArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    job<T extends FreightInvoice$jobArgs<ExtArgs> = {}>(args?: Subset<T, FreightInvoice$jobArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends FreightInvoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, FreightInvoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreightInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FreightInvoice model
   */
  interface FreightInvoiceFieldRefs {
    readonly id: FieldRef<"FreightInvoice", 'Int'>
    readonly invoiceNumber: FieldRef<"FreightInvoice", 'String'>
    readonly date: FieldRef<"FreightInvoice", 'DateTime'>
    readonly jobId: FieldRef<"FreightInvoice", 'Int'>
    readonly customerId: FieldRef<"FreightInvoice", 'Int'>
    readonly type: FieldRef<"FreightInvoice", 'InvoiceType'>
    readonly status: FieldRef<"FreightInvoice", 'InvoiceStatus'>
    readonly usdRate: FieldRef<"FreightInvoice", 'Float'>
    readonly exchangeRate: FieldRef<"FreightInvoice", 'Float'>
    readonly totalAmount: FieldRef<"FreightInvoice", 'Float'>
    readonly taxAmount: FieldRef<"FreightInvoice", 'Float'>
    readonly grandTotal: FieldRef<"FreightInvoice", 'Float'>
    readonly currencyCode: FieldRef<"FreightInvoice", 'String'>
    readonly isApproved: FieldRef<"FreightInvoice", 'Boolean'>
    readonly approvedById: FieldRef<"FreightInvoice", 'Int'>
    readonly isLocked: FieldRef<"FreightInvoice", 'Boolean'>
    readonly lockedAt: FieldRef<"FreightInvoice", 'DateTime'>
    readonly companyId: FieldRef<"FreightInvoice", 'Int'>
    readonly createdAt: FieldRef<"FreightInvoice", 'DateTime'>
    readonly updatedAt: FieldRef<"FreightInvoice", 'DateTime'>
    readonly transactionId: FieldRef<"FreightInvoice", 'Int'>
    readonly division: FieldRef<"FreightInvoice", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FreightInvoice findUnique
   */
  export type FreightInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoice
     */
    select?: FreightInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoice
     */
    omit?: FreightInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which FreightInvoice to fetch.
     */
    where: FreightInvoiceWhereUniqueInput
  }

  /**
   * FreightInvoice findUniqueOrThrow
   */
  export type FreightInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoice
     */
    select?: FreightInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoice
     */
    omit?: FreightInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which FreightInvoice to fetch.
     */
    where: FreightInvoiceWhereUniqueInput
  }

  /**
   * FreightInvoice findFirst
   */
  export type FreightInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoice
     */
    select?: FreightInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoice
     */
    omit?: FreightInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which FreightInvoice to fetch.
     */
    where?: FreightInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreightInvoices to fetch.
     */
    orderBy?: FreightInvoiceOrderByWithRelationInput | FreightInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FreightInvoices.
     */
    cursor?: FreightInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreightInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreightInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FreightInvoices.
     */
    distinct?: FreightInvoiceScalarFieldEnum | FreightInvoiceScalarFieldEnum[]
  }

  /**
   * FreightInvoice findFirstOrThrow
   */
  export type FreightInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoice
     */
    select?: FreightInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoice
     */
    omit?: FreightInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which FreightInvoice to fetch.
     */
    where?: FreightInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreightInvoices to fetch.
     */
    orderBy?: FreightInvoiceOrderByWithRelationInput | FreightInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FreightInvoices.
     */
    cursor?: FreightInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreightInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreightInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FreightInvoices.
     */
    distinct?: FreightInvoiceScalarFieldEnum | FreightInvoiceScalarFieldEnum[]
  }

  /**
   * FreightInvoice findMany
   */
  export type FreightInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoice
     */
    select?: FreightInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoice
     */
    omit?: FreightInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which FreightInvoices to fetch.
     */
    where?: FreightInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreightInvoices to fetch.
     */
    orderBy?: FreightInvoiceOrderByWithRelationInput | FreightInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FreightInvoices.
     */
    cursor?: FreightInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreightInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreightInvoices.
     */
    skip?: number
    distinct?: FreightInvoiceScalarFieldEnum | FreightInvoiceScalarFieldEnum[]
  }

  /**
   * FreightInvoice create
   */
  export type FreightInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoice
     */
    select?: FreightInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoice
     */
    omit?: FreightInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a FreightInvoice.
     */
    data: XOR<FreightInvoiceCreateInput, FreightInvoiceUncheckedCreateInput>
  }

  /**
   * FreightInvoice createMany
   */
  export type FreightInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FreightInvoices.
     */
    data: FreightInvoiceCreateManyInput | FreightInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FreightInvoice createManyAndReturn
   */
  export type FreightInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoice
     */
    select?: FreightInvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoice
     */
    omit?: FreightInvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many FreightInvoices.
     */
    data: FreightInvoiceCreateManyInput | FreightInvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FreightInvoice update
   */
  export type FreightInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoice
     */
    select?: FreightInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoice
     */
    omit?: FreightInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a FreightInvoice.
     */
    data: XOR<FreightInvoiceUpdateInput, FreightInvoiceUncheckedUpdateInput>
    /**
     * Choose, which FreightInvoice to update.
     */
    where: FreightInvoiceWhereUniqueInput
  }

  /**
   * FreightInvoice updateMany
   */
  export type FreightInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FreightInvoices.
     */
    data: XOR<FreightInvoiceUpdateManyMutationInput, FreightInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which FreightInvoices to update
     */
    where?: FreightInvoiceWhereInput
    /**
     * Limit how many FreightInvoices to update.
     */
    limit?: number
  }

  /**
   * FreightInvoice updateManyAndReturn
   */
  export type FreightInvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoice
     */
    select?: FreightInvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoice
     */
    omit?: FreightInvoiceOmit<ExtArgs> | null
    /**
     * The data used to update FreightInvoices.
     */
    data: XOR<FreightInvoiceUpdateManyMutationInput, FreightInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which FreightInvoices to update
     */
    where?: FreightInvoiceWhereInput
    /**
     * Limit how many FreightInvoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FreightInvoice upsert
   */
  export type FreightInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoice
     */
    select?: FreightInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoice
     */
    omit?: FreightInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the FreightInvoice to update in case it exists.
     */
    where: FreightInvoiceWhereUniqueInput
    /**
     * In case the FreightInvoice found by the `where` argument doesn't exist, create a new FreightInvoice with this data.
     */
    create: XOR<FreightInvoiceCreateInput, FreightInvoiceUncheckedCreateInput>
    /**
     * In case the FreightInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FreightInvoiceUpdateInput, FreightInvoiceUncheckedUpdateInput>
  }

  /**
   * FreightInvoice delete
   */
  export type FreightInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoice
     */
    select?: FreightInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoice
     */
    omit?: FreightInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceInclude<ExtArgs> | null
    /**
     * Filter which FreightInvoice to delete.
     */
    where: FreightInvoiceWhereUniqueInput
  }

  /**
   * FreightInvoice deleteMany
   */
  export type FreightInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FreightInvoices to delete
     */
    where?: FreightInvoiceWhereInput
    /**
     * Limit how many FreightInvoices to delete.
     */
    limit?: number
  }

  /**
   * FreightInvoice.transaction
   */
  export type FreightInvoice$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
  }

  /**
   * FreightInvoice.job
   */
  export type FreightInvoice$jobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
  }

  /**
   * FreightInvoice.items
   */
  export type FreightInvoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoiceItem
     */
    select?: FreightInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoiceItem
     */
    omit?: FreightInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceItemInclude<ExtArgs> | null
    where?: FreightInvoiceItemWhereInput
    orderBy?: FreightInvoiceItemOrderByWithRelationInput | FreightInvoiceItemOrderByWithRelationInput[]
    cursor?: FreightInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FreightInvoiceItemScalarFieldEnum | FreightInvoiceItemScalarFieldEnum[]
  }

  /**
   * FreightInvoice without action
   */
  export type FreightInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoice
     */
    select?: FreightInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoice
     */
    omit?: FreightInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model FreightInvoiceItem
   */

  export type AggregateFreightInvoiceItem = {
    _count: FreightInvoiceItemCountAggregateOutputType | null
    _avg: FreightInvoiceItemAvgAggregateOutputType | null
    _sum: FreightInvoiceItemSumAggregateOutputType | null
    _min: FreightInvoiceItemMinAggregateOutputType | null
    _max: FreightInvoiceItemMaxAggregateOutputType | null
  }

  export type FreightInvoiceItemAvgAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    quantity: number | null
    rate: number | null
    amount: number | null
    taxPercentage: number | null
    taxAmount: number | null
    total: number | null
    vendorId: number | null
  }

  export type FreightInvoiceItemSumAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    quantity: number | null
    rate: number | null
    amount: number | null
    taxPercentage: number | null
    taxAmount: number | null
    total: number | null
    vendorId: number | null
  }

  export type FreightInvoiceItemMinAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    description: string | null
    quantity: number | null
    rate: number | null
    amount: number | null
    taxPercentage: number | null
    taxAmount: number | null
    total: number | null
    vendorId: number | null
  }

  export type FreightInvoiceItemMaxAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    description: string | null
    quantity: number | null
    rate: number | null
    amount: number | null
    taxPercentage: number | null
    taxAmount: number | null
    total: number | null
    vendorId: number | null
  }

  export type FreightInvoiceItemCountAggregateOutputType = {
    id: number
    invoiceId: number
    description: number
    quantity: number
    rate: number
    amount: number
    taxPercentage: number
    taxAmount: number
    total: number
    vendorId: number
    _all: number
  }


  export type FreightInvoiceItemAvgAggregateInputType = {
    id?: true
    invoiceId?: true
    quantity?: true
    rate?: true
    amount?: true
    taxPercentage?: true
    taxAmount?: true
    total?: true
    vendorId?: true
  }

  export type FreightInvoiceItemSumAggregateInputType = {
    id?: true
    invoiceId?: true
    quantity?: true
    rate?: true
    amount?: true
    taxPercentage?: true
    taxAmount?: true
    total?: true
    vendorId?: true
  }

  export type FreightInvoiceItemMinAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    rate?: true
    amount?: true
    taxPercentage?: true
    taxAmount?: true
    total?: true
    vendorId?: true
  }

  export type FreightInvoiceItemMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    rate?: true
    amount?: true
    taxPercentage?: true
    taxAmount?: true
    total?: true
    vendorId?: true
  }

  export type FreightInvoiceItemCountAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    rate?: true
    amount?: true
    taxPercentage?: true
    taxAmount?: true
    total?: true
    vendorId?: true
    _all?: true
  }

  export type FreightInvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FreightInvoiceItem to aggregate.
     */
    where?: FreightInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreightInvoiceItems to fetch.
     */
    orderBy?: FreightInvoiceItemOrderByWithRelationInput | FreightInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FreightInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreightInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreightInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FreightInvoiceItems
    **/
    _count?: true | FreightInvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FreightInvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FreightInvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FreightInvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FreightInvoiceItemMaxAggregateInputType
  }

  export type GetFreightInvoiceItemAggregateType<T extends FreightInvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateFreightInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFreightInvoiceItem[P]>
      : GetScalarType<T[P], AggregateFreightInvoiceItem[P]>
  }




  export type FreightInvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FreightInvoiceItemWhereInput
    orderBy?: FreightInvoiceItemOrderByWithAggregationInput | FreightInvoiceItemOrderByWithAggregationInput[]
    by: FreightInvoiceItemScalarFieldEnum[] | FreightInvoiceItemScalarFieldEnum
    having?: FreightInvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FreightInvoiceItemCountAggregateInputType | true
    _avg?: FreightInvoiceItemAvgAggregateInputType
    _sum?: FreightInvoiceItemSumAggregateInputType
    _min?: FreightInvoiceItemMinAggregateInputType
    _max?: FreightInvoiceItemMaxAggregateInputType
  }

  export type FreightInvoiceItemGroupByOutputType = {
    id: number
    invoiceId: number
    description: string
    quantity: number
    rate: number
    amount: number
    taxPercentage: number
    taxAmount: number
    total: number
    vendorId: number | null
    _count: FreightInvoiceItemCountAggregateOutputType | null
    _avg: FreightInvoiceItemAvgAggregateOutputType | null
    _sum: FreightInvoiceItemSumAggregateOutputType | null
    _min: FreightInvoiceItemMinAggregateOutputType | null
    _max: FreightInvoiceItemMaxAggregateOutputType | null
  }

  type GetFreightInvoiceItemGroupByPayload<T extends FreightInvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FreightInvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FreightInvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FreightInvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], FreightInvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type FreightInvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    rate?: boolean
    amount?: boolean
    taxPercentage?: boolean
    taxAmount?: boolean
    total?: boolean
    vendorId?: boolean
    invoice?: boolean | FreightInvoiceDefaultArgs<ExtArgs>
    vendor?: boolean | FreightInvoiceItem$vendorArgs<ExtArgs>
  }, ExtArgs["result"]["freightInvoiceItem"]>

  export type FreightInvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    rate?: boolean
    amount?: boolean
    taxPercentage?: boolean
    taxAmount?: boolean
    total?: boolean
    vendorId?: boolean
    invoice?: boolean | FreightInvoiceDefaultArgs<ExtArgs>
    vendor?: boolean | FreightInvoiceItem$vendorArgs<ExtArgs>
  }, ExtArgs["result"]["freightInvoiceItem"]>

  export type FreightInvoiceItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    rate?: boolean
    amount?: boolean
    taxPercentage?: boolean
    taxAmount?: boolean
    total?: boolean
    vendorId?: boolean
    invoice?: boolean | FreightInvoiceDefaultArgs<ExtArgs>
    vendor?: boolean | FreightInvoiceItem$vendorArgs<ExtArgs>
  }, ExtArgs["result"]["freightInvoiceItem"]>

  export type FreightInvoiceItemSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    rate?: boolean
    amount?: boolean
    taxPercentage?: boolean
    taxAmount?: boolean
    total?: boolean
    vendorId?: boolean
  }

  export type FreightInvoiceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "description" | "quantity" | "rate" | "amount" | "taxPercentage" | "taxAmount" | "total" | "vendorId", ExtArgs["result"]["freightInvoiceItem"]>
  export type FreightInvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | FreightInvoiceDefaultArgs<ExtArgs>
    vendor?: boolean | FreightInvoiceItem$vendorArgs<ExtArgs>
  }
  export type FreightInvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | FreightInvoiceDefaultArgs<ExtArgs>
    vendor?: boolean | FreightInvoiceItem$vendorArgs<ExtArgs>
  }
  export type FreightInvoiceItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | FreightInvoiceDefaultArgs<ExtArgs>
    vendor?: boolean | FreightInvoiceItem$vendorArgs<ExtArgs>
  }

  export type $FreightInvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FreightInvoiceItem"
    objects: {
      invoice: Prisma.$FreightInvoicePayload<ExtArgs>
      vendor: Prisma.$VendorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoiceId: number
      description: string
      quantity: number
      rate: number
      amount: number
      taxPercentage: number
      taxAmount: number
      total: number
      vendorId: number | null
    }, ExtArgs["result"]["freightInvoiceItem"]>
    composites: {}
  }

  type FreightInvoiceItemGetPayload<S extends boolean | null | undefined | FreightInvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$FreightInvoiceItemPayload, S>

  type FreightInvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FreightInvoiceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FreightInvoiceItemCountAggregateInputType | true
    }

  export interface FreightInvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FreightInvoiceItem'], meta: { name: 'FreightInvoiceItem' } }
    /**
     * Find zero or one FreightInvoiceItem that matches the filter.
     * @param {FreightInvoiceItemFindUniqueArgs} args - Arguments to find a FreightInvoiceItem
     * @example
     * // Get one FreightInvoiceItem
     * const freightInvoiceItem = await prisma.freightInvoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FreightInvoiceItemFindUniqueArgs>(args: SelectSubset<T, FreightInvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__FreightInvoiceItemClient<$Result.GetResult<Prisma.$FreightInvoiceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FreightInvoiceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FreightInvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a FreightInvoiceItem
     * @example
     * // Get one FreightInvoiceItem
     * const freightInvoiceItem = await prisma.freightInvoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FreightInvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, FreightInvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FreightInvoiceItemClient<$Result.GetResult<Prisma.$FreightInvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FreightInvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreightInvoiceItemFindFirstArgs} args - Arguments to find a FreightInvoiceItem
     * @example
     * // Get one FreightInvoiceItem
     * const freightInvoiceItem = await prisma.freightInvoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FreightInvoiceItemFindFirstArgs>(args?: SelectSubset<T, FreightInvoiceItemFindFirstArgs<ExtArgs>>): Prisma__FreightInvoiceItemClient<$Result.GetResult<Prisma.$FreightInvoiceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FreightInvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreightInvoiceItemFindFirstOrThrowArgs} args - Arguments to find a FreightInvoiceItem
     * @example
     * // Get one FreightInvoiceItem
     * const freightInvoiceItem = await prisma.freightInvoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FreightInvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, FreightInvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__FreightInvoiceItemClient<$Result.GetResult<Prisma.$FreightInvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FreightInvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreightInvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FreightInvoiceItems
     * const freightInvoiceItems = await prisma.freightInvoiceItem.findMany()
     * 
     * // Get first 10 FreightInvoiceItems
     * const freightInvoiceItems = await prisma.freightInvoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const freightInvoiceItemWithIdOnly = await prisma.freightInvoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FreightInvoiceItemFindManyArgs>(args?: SelectSubset<T, FreightInvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreightInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FreightInvoiceItem.
     * @param {FreightInvoiceItemCreateArgs} args - Arguments to create a FreightInvoiceItem.
     * @example
     * // Create one FreightInvoiceItem
     * const FreightInvoiceItem = await prisma.freightInvoiceItem.create({
     *   data: {
     *     // ... data to create a FreightInvoiceItem
     *   }
     * })
     * 
     */
    create<T extends FreightInvoiceItemCreateArgs>(args: SelectSubset<T, FreightInvoiceItemCreateArgs<ExtArgs>>): Prisma__FreightInvoiceItemClient<$Result.GetResult<Prisma.$FreightInvoiceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FreightInvoiceItems.
     * @param {FreightInvoiceItemCreateManyArgs} args - Arguments to create many FreightInvoiceItems.
     * @example
     * // Create many FreightInvoiceItems
     * const freightInvoiceItem = await prisma.freightInvoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FreightInvoiceItemCreateManyArgs>(args?: SelectSubset<T, FreightInvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FreightInvoiceItems and returns the data saved in the database.
     * @param {FreightInvoiceItemCreateManyAndReturnArgs} args - Arguments to create many FreightInvoiceItems.
     * @example
     * // Create many FreightInvoiceItems
     * const freightInvoiceItem = await prisma.freightInvoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FreightInvoiceItems and only return the `id`
     * const freightInvoiceItemWithIdOnly = await prisma.freightInvoiceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FreightInvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, FreightInvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreightInvoiceItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FreightInvoiceItem.
     * @param {FreightInvoiceItemDeleteArgs} args - Arguments to delete one FreightInvoiceItem.
     * @example
     * // Delete one FreightInvoiceItem
     * const FreightInvoiceItem = await prisma.freightInvoiceItem.delete({
     *   where: {
     *     // ... filter to delete one FreightInvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends FreightInvoiceItemDeleteArgs>(args: SelectSubset<T, FreightInvoiceItemDeleteArgs<ExtArgs>>): Prisma__FreightInvoiceItemClient<$Result.GetResult<Prisma.$FreightInvoiceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FreightInvoiceItem.
     * @param {FreightInvoiceItemUpdateArgs} args - Arguments to update one FreightInvoiceItem.
     * @example
     * // Update one FreightInvoiceItem
     * const freightInvoiceItem = await prisma.freightInvoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FreightInvoiceItemUpdateArgs>(args: SelectSubset<T, FreightInvoiceItemUpdateArgs<ExtArgs>>): Prisma__FreightInvoiceItemClient<$Result.GetResult<Prisma.$FreightInvoiceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FreightInvoiceItems.
     * @param {FreightInvoiceItemDeleteManyArgs} args - Arguments to filter FreightInvoiceItems to delete.
     * @example
     * // Delete a few FreightInvoiceItems
     * const { count } = await prisma.freightInvoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FreightInvoiceItemDeleteManyArgs>(args?: SelectSubset<T, FreightInvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FreightInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreightInvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FreightInvoiceItems
     * const freightInvoiceItem = await prisma.freightInvoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FreightInvoiceItemUpdateManyArgs>(args: SelectSubset<T, FreightInvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FreightInvoiceItems and returns the data updated in the database.
     * @param {FreightInvoiceItemUpdateManyAndReturnArgs} args - Arguments to update many FreightInvoiceItems.
     * @example
     * // Update many FreightInvoiceItems
     * const freightInvoiceItem = await prisma.freightInvoiceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FreightInvoiceItems and only return the `id`
     * const freightInvoiceItemWithIdOnly = await prisma.freightInvoiceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FreightInvoiceItemUpdateManyAndReturnArgs>(args: SelectSubset<T, FreightInvoiceItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreightInvoiceItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FreightInvoiceItem.
     * @param {FreightInvoiceItemUpsertArgs} args - Arguments to update or create a FreightInvoiceItem.
     * @example
     * // Update or create a FreightInvoiceItem
     * const freightInvoiceItem = await prisma.freightInvoiceItem.upsert({
     *   create: {
     *     // ... data to create a FreightInvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FreightInvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends FreightInvoiceItemUpsertArgs>(args: SelectSubset<T, FreightInvoiceItemUpsertArgs<ExtArgs>>): Prisma__FreightInvoiceItemClient<$Result.GetResult<Prisma.$FreightInvoiceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FreightInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreightInvoiceItemCountArgs} args - Arguments to filter FreightInvoiceItems to count.
     * @example
     * // Count the number of FreightInvoiceItems
     * const count = await prisma.freightInvoiceItem.count({
     *   where: {
     *     // ... the filter for the FreightInvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends FreightInvoiceItemCountArgs>(
      args?: Subset<T, FreightInvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FreightInvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FreightInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreightInvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FreightInvoiceItemAggregateArgs>(args: Subset<T, FreightInvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetFreightInvoiceItemAggregateType<T>>

    /**
     * Group by FreightInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreightInvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FreightInvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FreightInvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: FreightInvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FreightInvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFreightInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FreightInvoiceItem model
   */
  readonly fields: FreightInvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FreightInvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FreightInvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends FreightInvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FreightInvoiceDefaultArgs<ExtArgs>>): Prisma__FreightInvoiceClient<$Result.GetResult<Prisma.$FreightInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vendor<T extends FreightInvoiceItem$vendorArgs<ExtArgs> = {}>(args?: Subset<T, FreightInvoiceItem$vendorArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FreightInvoiceItem model
   */
  interface FreightInvoiceItemFieldRefs {
    readonly id: FieldRef<"FreightInvoiceItem", 'Int'>
    readonly invoiceId: FieldRef<"FreightInvoiceItem", 'Int'>
    readonly description: FieldRef<"FreightInvoiceItem", 'String'>
    readonly quantity: FieldRef<"FreightInvoiceItem", 'Float'>
    readonly rate: FieldRef<"FreightInvoiceItem", 'Float'>
    readonly amount: FieldRef<"FreightInvoiceItem", 'Float'>
    readonly taxPercentage: FieldRef<"FreightInvoiceItem", 'Float'>
    readonly taxAmount: FieldRef<"FreightInvoiceItem", 'Float'>
    readonly total: FieldRef<"FreightInvoiceItem", 'Float'>
    readonly vendorId: FieldRef<"FreightInvoiceItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FreightInvoiceItem findUnique
   */
  export type FreightInvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoiceItem
     */
    select?: FreightInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoiceItem
     */
    omit?: FreightInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which FreightInvoiceItem to fetch.
     */
    where: FreightInvoiceItemWhereUniqueInput
  }

  /**
   * FreightInvoiceItem findUniqueOrThrow
   */
  export type FreightInvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoiceItem
     */
    select?: FreightInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoiceItem
     */
    omit?: FreightInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which FreightInvoiceItem to fetch.
     */
    where: FreightInvoiceItemWhereUniqueInput
  }

  /**
   * FreightInvoiceItem findFirst
   */
  export type FreightInvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoiceItem
     */
    select?: FreightInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoiceItem
     */
    omit?: FreightInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which FreightInvoiceItem to fetch.
     */
    where?: FreightInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreightInvoiceItems to fetch.
     */
    orderBy?: FreightInvoiceItemOrderByWithRelationInput | FreightInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FreightInvoiceItems.
     */
    cursor?: FreightInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreightInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreightInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FreightInvoiceItems.
     */
    distinct?: FreightInvoiceItemScalarFieldEnum | FreightInvoiceItemScalarFieldEnum[]
  }

  /**
   * FreightInvoiceItem findFirstOrThrow
   */
  export type FreightInvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoiceItem
     */
    select?: FreightInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoiceItem
     */
    omit?: FreightInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which FreightInvoiceItem to fetch.
     */
    where?: FreightInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreightInvoiceItems to fetch.
     */
    orderBy?: FreightInvoiceItemOrderByWithRelationInput | FreightInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FreightInvoiceItems.
     */
    cursor?: FreightInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreightInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreightInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FreightInvoiceItems.
     */
    distinct?: FreightInvoiceItemScalarFieldEnum | FreightInvoiceItemScalarFieldEnum[]
  }

  /**
   * FreightInvoiceItem findMany
   */
  export type FreightInvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoiceItem
     */
    select?: FreightInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoiceItem
     */
    omit?: FreightInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which FreightInvoiceItems to fetch.
     */
    where?: FreightInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreightInvoiceItems to fetch.
     */
    orderBy?: FreightInvoiceItemOrderByWithRelationInput | FreightInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FreightInvoiceItems.
     */
    cursor?: FreightInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreightInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreightInvoiceItems.
     */
    skip?: number
    distinct?: FreightInvoiceItemScalarFieldEnum | FreightInvoiceItemScalarFieldEnum[]
  }

  /**
   * FreightInvoiceItem create
   */
  export type FreightInvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoiceItem
     */
    select?: FreightInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoiceItem
     */
    omit?: FreightInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a FreightInvoiceItem.
     */
    data: XOR<FreightInvoiceItemCreateInput, FreightInvoiceItemUncheckedCreateInput>
  }

  /**
   * FreightInvoiceItem createMany
   */
  export type FreightInvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FreightInvoiceItems.
     */
    data: FreightInvoiceItemCreateManyInput | FreightInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FreightInvoiceItem createManyAndReturn
   */
  export type FreightInvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoiceItem
     */
    select?: FreightInvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoiceItem
     */
    omit?: FreightInvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to create many FreightInvoiceItems.
     */
    data: FreightInvoiceItemCreateManyInput | FreightInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FreightInvoiceItem update
   */
  export type FreightInvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoiceItem
     */
    select?: FreightInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoiceItem
     */
    omit?: FreightInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a FreightInvoiceItem.
     */
    data: XOR<FreightInvoiceItemUpdateInput, FreightInvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which FreightInvoiceItem to update.
     */
    where: FreightInvoiceItemWhereUniqueInput
  }

  /**
   * FreightInvoiceItem updateMany
   */
  export type FreightInvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FreightInvoiceItems.
     */
    data: XOR<FreightInvoiceItemUpdateManyMutationInput, FreightInvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which FreightInvoiceItems to update
     */
    where?: FreightInvoiceItemWhereInput
    /**
     * Limit how many FreightInvoiceItems to update.
     */
    limit?: number
  }

  /**
   * FreightInvoiceItem updateManyAndReturn
   */
  export type FreightInvoiceItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoiceItem
     */
    select?: FreightInvoiceItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoiceItem
     */
    omit?: FreightInvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to update FreightInvoiceItems.
     */
    data: XOR<FreightInvoiceItemUpdateManyMutationInput, FreightInvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which FreightInvoiceItems to update
     */
    where?: FreightInvoiceItemWhereInput
    /**
     * Limit how many FreightInvoiceItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FreightInvoiceItem upsert
   */
  export type FreightInvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoiceItem
     */
    select?: FreightInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoiceItem
     */
    omit?: FreightInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the FreightInvoiceItem to update in case it exists.
     */
    where: FreightInvoiceItemWhereUniqueInput
    /**
     * In case the FreightInvoiceItem found by the `where` argument doesn't exist, create a new FreightInvoiceItem with this data.
     */
    create: XOR<FreightInvoiceItemCreateInput, FreightInvoiceItemUncheckedCreateInput>
    /**
     * In case the FreightInvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FreightInvoiceItemUpdateInput, FreightInvoiceItemUncheckedUpdateInput>
  }

  /**
   * FreightInvoiceItem delete
   */
  export type FreightInvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoiceItem
     */
    select?: FreightInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoiceItem
     */
    omit?: FreightInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which FreightInvoiceItem to delete.
     */
    where: FreightInvoiceItemWhereUniqueInput
  }

  /**
   * FreightInvoiceItem deleteMany
   */
  export type FreightInvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FreightInvoiceItems to delete
     */
    where?: FreightInvoiceItemWhereInput
    /**
     * Limit how many FreightInvoiceItems to delete.
     */
    limit?: number
  }

  /**
   * FreightInvoiceItem.vendor
   */
  export type FreightInvoiceItem$vendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
  }

  /**
   * FreightInvoiceItem without action
   */
  export type FreightInvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoiceItem
     */
    select?: FreightInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoiceItem
     */
    omit?: FreightInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model ProductCategory
   */

  export type AggregateProductCategory = {
    _count: ProductCategoryCountAggregateOutputType | null
    _avg: ProductCategoryAvgAggregateOutputType | null
    _sum: ProductCategorySumAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  export type ProductCategoryAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type ProductCategorySumAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type ProductCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductCategoryAvgAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type ProductCategorySumAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type ProductCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategory to aggregate.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCategories
    **/
    _count?: true | ProductCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type GetProductCategoryAggregateType<T extends ProductCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCategory[P]>
      : GetScalarType<T[P], AggregateProductCategory[P]>
  }




  export type ProductCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithAggregationInput | ProductCategoryOrderByWithAggregationInput[]
    by: ProductCategoryScalarFieldEnum[] | ProductCategoryScalarFieldEnum
    having?: ProductCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCategoryCountAggregateInputType | true
    _avg?: ProductCategoryAvgAggregateInputType
    _sum?: ProductCategorySumAggregateInputType
    _min?: ProductCategoryMinAggregateInputType
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type ProductCategoryGroupByOutputType = {
    id: number
    name: string
    description: string | null
    companyId: number
    createdAt: Date
    updatedAt: Date
    _count: ProductCategoryCountAggregateOutputType | null
    _avg: ProductCategoryAvgAggregateOutputType | null
    _sum: ProductCategorySumAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  type GetProductCategoryGroupByPayload<T extends ProductCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | ProductCategory$productsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "companyId" | "createdAt" | "updatedAt", ExtArgs["result"]["productCategory"]>
  export type ProductCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | ProductCategory$productsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type ProductCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $ProductCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductCategory"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      companyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productCategory"]>
    composites: {}
  }

  type ProductCategoryGetPayload<S extends boolean | null | undefined | ProductCategoryDefaultArgs> = $Result.GetResult<Prisma.$ProductCategoryPayload, S>

  type ProductCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCategoryCountAggregateInputType | true
    }

  export interface ProductCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductCategory'], meta: { name: 'ProductCategory' } }
    /**
     * Find zero or one ProductCategory that matches the filter.
     * @param {ProductCategoryFindUniqueArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductCategoryFindUniqueArgs>(args: SelectSubset<T, ProductCategoryFindUniqueArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductCategoryFindUniqueOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductCategoryFindFirstArgs>(args?: SelectSubset<T, ProductCategoryFindFirstArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCategories
     * const productCategories = await prisma.productCategory.findMany()
     * 
     * // Get first 10 ProductCategories
     * const productCategories = await prisma.productCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductCategoryFindManyArgs>(args?: SelectSubset<T, ProductCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductCategory.
     * @param {ProductCategoryCreateArgs} args - Arguments to create a ProductCategory.
     * @example
     * // Create one ProductCategory
     * const ProductCategory = await prisma.productCategory.create({
     *   data: {
     *     // ... data to create a ProductCategory
     *   }
     * })
     * 
     */
    create<T extends ProductCategoryCreateArgs>(args: SelectSubset<T, ProductCategoryCreateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductCategories.
     * @param {ProductCategoryCreateManyArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCategoryCreateManyArgs>(args?: SelectSubset<T, ProductCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductCategories and returns the data saved in the database.
     * @param {ProductCategoryCreateManyAndReturnArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductCategory.
     * @param {ProductCategoryDeleteArgs} args - Arguments to delete one ProductCategory.
     * @example
     * // Delete one ProductCategory
     * const ProductCategory = await prisma.productCategory.delete({
     *   where: {
     *     // ... filter to delete one ProductCategory
     *   }
     * })
     * 
     */
    delete<T extends ProductCategoryDeleteArgs>(args: SelectSubset<T, ProductCategoryDeleteArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductCategory.
     * @param {ProductCategoryUpdateArgs} args - Arguments to update one ProductCategory.
     * @example
     * // Update one ProductCategory
     * const productCategory = await prisma.productCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductCategoryUpdateArgs>(args: SelectSubset<T, ProductCategoryUpdateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductCategories.
     * @param {ProductCategoryDeleteManyArgs} args - Arguments to filter ProductCategories to delete.
     * @example
     * // Delete a few ProductCategories
     * const { count } = await prisma.productCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductCategoryDeleteManyArgs>(args?: SelectSubset<T, ProductCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductCategoryUpdateManyArgs>(args: SelectSubset<T, ProductCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories and returns the data updated in the database.
     * @param {ProductCategoryUpdateManyAndReturnArgs} args - Arguments to update many ProductCategories.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductCategory.
     * @param {ProductCategoryUpsertArgs} args - Arguments to update or create a ProductCategory.
     * @example
     * // Update or create a ProductCategory
     * const productCategory = await prisma.productCategory.upsert({
     *   create: {
     *     // ... data to create a ProductCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCategory we want to update
     *   }
     * })
     */
    upsert<T extends ProductCategoryUpsertArgs>(args: SelectSubset<T, ProductCategoryUpsertArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryCountArgs} args - Arguments to filter ProductCategories to count.
     * @example
     * // Count the number of ProductCategories
     * const count = await prisma.productCategory.count({
     *   where: {
     *     // ... the filter for the ProductCategories we want to count
     *   }
     * })
    **/
    count<T extends ProductCategoryCountArgs>(
      args?: Subset<T, ProductCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCategoryAggregateArgs>(args: Subset<T, ProductCategoryAggregateArgs>): Prisma.PrismaPromise<GetProductCategoryAggregateType<T>>

    /**
     * Group by ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductCategory model
   */
  readonly fields: ProductCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends ProductCategory$productsArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductCategory model
   */
  interface ProductCategoryFieldRefs {
    readonly id: FieldRef<"ProductCategory", 'Int'>
    readonly name: FieldRef<"ProductCategory", 'String'>
    readonly description: FieldRef<"ProductCategory", 'String'>
    readonly companyId: FieldRef<"ProductCategory", 'Int'>
    readonly createdAt: FieldRef<"ProductCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductCategory findUnique
   */
  export type ProductCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findUniqueOrThrow
   */
  export type ProductCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findFirst
   */
  export type ProductCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findFirstOrThrow
   */
  export type ProductCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findMany
   */
  export type ProductCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategories to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory create
   */
  export type ProductCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductCategory.
     */
    data: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
  }

  /**
   * ProductCategory createMany
   */
  export type ProductCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCategory createManyAndReturn
   */
  export type ProductCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCategory update
   */
  export type ProductCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductCategory.
     */
    data: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
    /**
     * Choose, which ProductCategory to update.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory updateMany
   */
  export type ProductCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
  }

  /**
   * ProductCategory updateManyAndReturn
   */
  export type ProductCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCategory upsert
   */
  export type ProductCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductCategory to update in case it exists.
     */
    where: ProductCategoryWhereUniqueInput
    /**
     * In case the ProductCategory found by the `where` argument doesn't exist, create a new ProductCategory with this data.
     */
    create: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
    /**
     * In case the ProductCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
  }

  /**
   * ProductCategory delete
   */
  export type ProductCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter which ProductCategory to delete.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory deleteMany
   */
  export type ProductCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategories to delete
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to delete.
     */
    limit?: number
  }

  /**
   * ProductCategory.products
   */
  export type ProductCategory$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * ProductCategory without action
   */
  export type ProductCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    purchasePrice: number | null
    sellingPrice: number | null
    categoryId: number | null
    companyId: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    purchasePrice: number | null
    sellingPrice: number | null
    categoryId: number | null
    companyId: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    sku: string | null
    name: string | null
    description: string | null
    unit: string | null
    purchasePrice: number | null
    sellingPrice: number | null
    categoryId: number | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    sku: string | null
    name: string | null
    description: string | null
    unit: string | null
    purchasePrice: number | null
    sellingPrice: number | null
    categoryId: number | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    sku: number
    name: number
    description: number
    unit: number
    purchasePrice: number
    sellingPrice: number
    categoryId: number
    companyId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    purchasePrice?: true
    sellingPrice?: true
    categoryId?: true
    companyId?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    purchasePrice?: true
    sellingPrice?: true
    categoryId?: true
    companyId?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    unit?: true
    purchasePrice?: true
    sellingPrice?: true
    categoryId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    unit?: true
    purchasePrice?: true
    sellingPrice?: true
    categoryId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    unit?: true
    purchasePrice?: true
    sellingPrice?: true
    categoryId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    sku: string | null
    name: string
    description: string | null
    unit: string
    purchasePrice: number
    sellingPrice: number
    categoryId: number
    companyId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    unit?: boolean
    purchasePrice?: boolean
    sellingPrice?: boolean
    categoryId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    serviceItems?: boolean | Product$serviceItemsArgs<ExtArgs>
    category?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    purchaseItems?: boolean | Product$purchaseItemsArgs<ExtArgs>
    movements?: boolean | Product$movementsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    unit?: boolean
    purchasePrice?: boolean
    sellingPrice?: boolean
    categoryId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    category?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    unit?: boolean
    purchasePrice?: boolean
    sellingPrice?: boolean
    categoryId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    category?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    unit?: boolean
    purchasePrice?: boolean
    sellingPrice?: boolean
    categoryId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sku" | "name" | "description" | "unit" | "purchasePrice" | "sellingPrice" | "categoryId" | "companyId" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceItems?: boolean | Product$serviceItemsArgs<ExtArgs>
    category?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    purchaseItems?: boolean | Product$purchaseItemsArgs<ExtArgs>
    movements?: boolean | Product$movementsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      serviceItems: Prisma.$ServiceInvoiceItemPayload<ExtArgs>[]
      category: Prisma.$ProductCategoryPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
      purchaseItems: Prisma.$PurchaseInvoiceItemPayload<ExtArgs>[]
      movements: Prisma.$StockMovementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sku: string | null
      name: string
      description: string | null
      unit: string
      purchasePrice: number
      sellingPrice: number
      categoryId: number
      companyId: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceItems<T extends Product$serviceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$serviceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    category<T extends ProductCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategoryDefaultArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchaseItems<T extends Product$purchaseItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$purchaseItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    movements<T extends Product$movementsArgs<ExtArgs> = {}>(args?: Subset<T, Product$movementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly sku: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly unit: FieldRef<"Product", 'String'>
    readonly purchasePrice: FieldRef<"Product", 'Float'>
    readonly sellingPrice: FieldRef<"Product", 'Float'>
    readonly categoryId: FieldRef<"Product", 'Int'>
    readonly companyId: FieldRef<"Product", 'Int'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly deletedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.serviceItems
   */
  export type Product$serviceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoiceItem
     */
    select?: ServiceInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoiceItem
     */
    omit?: ServiceInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceItemInclude<ExtArgs> | null
    where?: ServiceInvoiceItemWhereInput
    orderBy?: ServiceInvoiceItemOrderByWithRelationInput | ServiceInvoiceItemOrderByWithRelationInput[]
    cursor?: ServiceInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceInvoiceItemScalarFieldEnum | ServiceInvoiceItemScalarFieldEnum[]
  }

  /**
   * Product.purchaseItems
   */
  export type Product$purchaseItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    where?: PurchaseInvoiceItemWhereInput
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseInvoiceItemScalarFieldEnum | PurchaseInvoiceItemScalarFieldEnum[]
  }

  /**
   * Product.movements
   */
  export type Product$movementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    cursor?: StockMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Warehouse
   */

  export type AggregateWarehouse = {
    _count: WarehouseCountAggregateOutputType | null
    _avg: WarehouseAvgAggregateOutputType | null
    _sum: WarehouseSumAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  export type WarehouseAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type WarehouseSumAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type WarehouseMinAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseMaxAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseCountAggregateOutputType = {
    id: number
    name: number
    location: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WarehouseAvgAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type WarehouseSumAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type WarehouseMinAggregateInputType = {
    id?: true
    name?: true
    location?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseMaxAggregateInputType = {
    id?: true
    name?: true
    location?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseCountAggregateInputType = {
    id?: true
    name?: true
    location?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WarehouseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warehouse to aggregate.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Warehouses
    **/
    _count?: true | WarehouseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WarehouseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WarehouseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseMaxAggregateInputType
  }

  export type GetWarehouseAggregateType<T extends WarehouseAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouse[P]>
      : GetScalarType<T[P], AggregateWarehouse[P]>
  }




  export type WarehouseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseWhereInput
    orderBy?: WarehouseOrderByWithAggregationInput | WarehouseOrderByWithAggregationInput[]
    by: WarehouseScalarFieldEnum[] | WarehouseScalarFieldEnum
    having?: WarehouseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseCountAggregateInputType | true
    _avg?: WarehouseAvgAggregateInputType
    _sum?: WarehouseSumAggregateInputType
    _min?: WarehouseMinAggregateInputType
    _max?: WarehouseMaxAggregateInputType
  }

  export type WarehouseGroupByOutputType = {
    id: number
    name: string
    location: string | null
    companyId: number
    createdAt: Date
    updatedAt: Date
    _count: WarehouseCountAggregateOutputType | null
    _avg: WarehouseAvgAggregateOutputType | null
    _sum: WarehouseSumAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  type GetWarehouseGroupByPayload<T extends WarehouseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stockMovements?: boolean | Warehouse$stockMovementsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | WarehouseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectScalar = {
    id?: boolean
    name?: boolean
    location?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WarehouseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "location" | "companyId" | "createdAt" | "updatedAt", ExtArgs["result"]["warehouse"]>
  export type WarehouseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockMovements?: boolean | Warehouse$stockMovementsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | WarehouseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WarehouseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type WarehouseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $WarehousePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Warehouse"
    objects: {
      stockMovements: Prisma.$StockMovementPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      location: string | null
      companyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["warehouse"]>
    composites: {}
  }

  type WarehouseGetPayload<S extends boolean | null | undefined | WarehouseDefaultArgs> = $Result.GetResult<Prisma.$WarehousePayload, S>

  type WarehouseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WarehouseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WarehouseCountAggregateInputType | true
    }

  export interface WarehouseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Warehouse'], meta: { name: 'Warehouse' } }
    /**
     * Find zero or one Warehouse that matches the filter.
     * @param {WarehouseFindUniqueArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarehouseFindUniqueArgs>(args: SelectSubset<T, WarehouseFindUniqueArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Warehouse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WarehouseFindUniqueOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarehouseFindUniqueOrThrowArgs>(args: SelectSubset<T, WarehouseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Warehouse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindFirstArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarehouseFindFirstArgs>(args?: SelectSubset<T, WarehouseFindFirstArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Warehouse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindFirstOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarehouseFindFirstOrThrowArgs>(args?: SelectSubset<T, WarehouseFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Warehouses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Warehouses
     * const warehouses = await prisma.warehouse.findMany()
     * 
     * // Get first 10 Warehouses
     * const warehouses = await prisma.warehouse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WarehouseFindManyArgs>(args?: SelectSubset<T, WarehouseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Warehouse.
     * @param {WarehouseCreateArgs} args - Arguments to create a Warehouse.
     * @example
     * // Create one Warehouse
     * const Warehouse = await prisma.warehouse.create({
     *   data: {
     *     // ... data to create a Warehouse
     *   }
     * })
     * 
     */
    create<T extends WarehouseCreateArgs>(args: SelectSubset<T, WarehouseCreateArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Warehouses.
     * @param {WarehouseCreateManyArgs} args - Arguments to create many Warehouses.
     * @example
     * // Create many Warehouses
     * const warehouse = await prisma.warehouse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarehouseCreateManyArgs>(args?: SelectSubset<T, WarehouseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Warehouses and returns the data saved in the database.
     * @param {WarehouseCreateManyAndReturnArgs} args - Arguments to create many Warehouses.
     * @example
     * // Create many Warehouses
     * const warehouse = await prisma.warehouse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Warehouses and only return the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WarehouseCreateManyAndReturnArgs>(args?: SelectSubset<T, WarehouseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Warehouse.
     * @param {WarehouseDeleteArgs} args - Arguments to delete one Warehouse.
     * @example
     * // Delete one Warehouse
     * const Warehouse = await prisma.warehouse.delete({
     *   where: {
     *     // ... filter to delete one Warehouse
     *   }
     * })
     * 
     */
    delete<T extends WarehouseDeleteArgs>(args: SelectSubset<T, WarehouseDeleteArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Warehouse.
     * @param {WarehouseUpdateArgs} args - Arguments to update one Warehouse.
     * @example
     * // Update one Warehouse
     * const warehouse = await prisma.warehouse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarehouseUpdateArgs>(args: SelectSubset<T, WarehouseUpdateArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Warehouses.
     * @param {WarehouseDeleteManyArgs} args - Arguments to filter Warehouses to delete.
     * @example
     * // Delete a few Warehouses
     * const { count } = await prisma.warehouse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarehouseDeleteManyArgs>(args?: SelectSubset<T, WarehouseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Warehouses
     * const warehouse = await prisma.warehouse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarehouseUpdateManyArgs>(args: SelectSubset<T, WarehouseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouses and returns the data updated in the database.
     * @param {WarehouseUpdateManyAndReturnArgs} args - Arguments to update many Warehouses.
     * @example
     * // Update many Warehouses
     * const warehouse = await prisma.warehouse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Warehouses and only return the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WarehouseUpdateManyAndReturnArgs>(args: SelectSubset<T, WarehouseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Warehouse.
     * @param {WarehouseUpsertArgs} args - Arguments to update or create a Warehouse.
     * @example
     * // Update or create a Warehouse
     * const warehouse = await prisma.warehouse.upsert({
     *   create: {
     *     // ... data to create a Warehouse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Warehouse we want to update
     *   }
     * })
     */
    upsert<T extends WarehouseUpsertArgs>(args: SelectSubset<T, WarehouseUpsertArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseCountArgs} args - Arguments to filter Warehouses to count.
     * @example
     * // Count the number of Warehouses
     * const count = await prisma.warehouse.count({
     *   where: {
     *     // ... the filter for the Warehouses we want to count
     *   }
     * })
    **/
    count<T extends WarehouseCountArgs>(
      args?: Subset<T, WarehouseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseAggregateArgs>(args: Subset<T, WarehouseAggregateArgs>): Prisma.PrismaPromise<GetWarehouseAggregateType<T>>

    /**
     * Group by Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Warehouse model
   */
  readonly fields: WarehouseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Warehouse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehouseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stockMovements<T extends Warehouse$stockMovementsArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$stockMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Warehouse model
   */
  interface WarehouseFieldRefs {
    readonly id: FieldRef<"Warehouse", 'Int'>
    readonly name: FieldRef<"Warehouse", 'String'>
    readonly location: FieldRef<"Warehouse", 'String'>
    readonly companyId: FieldRef<"Warehouse", 'Int'>
    readonly createdAt: FieldRef<"Warehouse", 'DateTime'>
    readonly updatedAt: FieldRef<"Warehouse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Warehouse findUnique
   */
  export type WarehouseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse findUniqueOrThrow
   */
  export type WarehouseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse findFirst
   */
  export type WarehouseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse findFirstOrThrow
   */
  export type WarehouseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse findMany
   */
  export type WarehouseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouses to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse create
   */
  export type WarehouseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The data needed to create a Warehouse.
     */
    data: XOR<WarehouseCreateInput, WarehouseUncheckedCreateInput>
  }

  /**
   * Warehouse createMany
   */
  export type WarehouseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Warehouses.
     */
    data: WarehouseCreateManyInput | WarehouseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Warehouse createManyAndReturn
   */
  export type WarehouseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * The data used to create many Warehouses.
     */
    data: WarehouseCreateManyInput | WarehouseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Warehouse update
   */
  export type WarehouseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The data needed to update a Warehouse.
     */
    data: XOR<WarehouseUpdateInput, WarehouseUncheckedUpdateInput>
    /**
     * Choose, which Warehouse to update.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse updateMany
   */
  export type WarehouseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Warehouses.
     */
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyInput>
    /**
     * Filter which Warehouses to update
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to update.
     */
    limit?: number
  }

  /**
   * Warehouse updateManyAndReturn
   */
  export type WarehouseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * The data used to update Warehouses.
     */
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyInput>
    /**
     * Filter which Warehouses to update
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Warehouse upsert
   */
  export type WarehouseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The filter to search for the Warehouse to update in case it exists.
     */
    where: WarehouseWhereUniqueInput
    /**
     * In case the Warehouse found by the `where` argument doesn't exist, create a new Warehouse with this data.
     */
    create: XOR<WarehouseCreateInput, WarehouseUncheckedCreateInput>
    /**
     * In case the Warehouse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehouseUpdateInput, WarehouseUncheckedUpdateInput>
  }

  /**
   * Warehouse delete
   */
  export type WarehouseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter which Warehouse to delete.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse deleteMany
   */
  export type WarehouseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warehouses to delete
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to delete.
     */
    limit?: number
  }

  /**
   * Warehouse.stockMovements
   */
  export type Warehouse$stockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    cursor?: StockMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * Warehouse without action
   */
  export type WarehouseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
  }


  /**
   * Model StockMovement
   */

  export type AggregateStockMovement = {
    _count: StockMovementCountAggregateOutputType | null
    _avg: StockMovementAvgAggregateOutputType | null
    _sum: StockMovementSumAggregateOutputType | null
    _min: StockMovementMinAggregateOutputType | null
    _max: StockMovementMaxAggregateOutputType | null
  }

  export type StockMovementAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    warehouseId: number | null
    quantity: number | null
    companyId: number | null
  }

  export type StockMovementSumAggregateOutputType = {
    id: number | null
    productId: number | null
    warehouseId: number | null
    quantity: number | null
    companyId: number | null
  }

  export type StockMovementMinAggregateOutputType = {
    id: number | null
    productId: number | null
    warehouseId: number | null
    quantity: number | null
    type: string | null
    reference: string | null
    companyId: number | null
    createdAt: Date | null
  }

  export type StockMovementMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    warehouseId: number | null
    quantity: number | null
    type: string | null
    reference: string | null
    companyId: number | null
    createdAt: Date | null
  }

  export type StockMovementCountAggregateOutputType = {
    id: number
    productId: number
    warehouseId: number
    quantity: number
    type: number
    reference: number
    companyId: number
    createdAt: number
    _all: number
  }


  export type StockMovementAvgAggregateInputType = {
    id?: true
    productId?: true
    warehouseId?: true
    quantity?: true
    companyId?: true
  }

  export type StockMovementSumAggregateInputType = {
    id?: true
    productId?: true
    warehouseId?: true
    quantity?: true
    companyId?: true
  }

  export type StockMovementMinAggregateInputType = {
    id?: true
    productId?: true
    warehouseId?: true
    quantity?: true
    type?: true
    reference?: true
    companyId?: true
    createdAt?: true
  }

  export type StockMovementMaxAggregateInputType = {
    id?: true
    productId?: true
    warehouseId?: true
    quantity?: true
    type?: true
    reference?: true
    companyId?: true
    createdAt?: true
  }

  export type StockMovementCountAggregateInputType = {
    id?: true
    productId?: true
    warehouseId?: true
    quantity?: true
    type?: true
    reference?: true
    companyId?: true
    createdAt?: true
    _all?: true
  }

  export type StockMovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockMovement to aggregate.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockMovements
    **/
    _count?: true | StockMovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockMovementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockMovementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockMovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockMovementMaxAggregateInputType
  }

  export type GetStockMovementAggregateType<T extends StockMovementAggregateArgs> = {
        [P in keyof T & keyof AggregateStockMovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockMovement[P]>
      : GetScalarType<T[P], AggregateStockMovement[P]>
  }




  export type StockMovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithAggregationInput | StockMovementOrderByWithAggregationInput[]
    by: StockMovementScalarFieldEnum[] | StockMovementScalarFieldEnum
    having?: StockMovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockMovementCountAggregateInputType | true
    _avg?: StockMovementAvgAggregateInputType
    _sum?: StockMovementSumAggregateInputType
    _min?: StockMovementMinAggregateInputType
    _max?: StockMovementMaxAggregateInputType
  }

  export type StockMovementGroupByOutputType = {
    id: number
    productId: number
    warehouseId: number | null
    quantity: number
    type: string
    reference: string | null
    companyId: number
    createdAt: Date
    _count: StockMovementCountAggregateOutputType | null
    _avg: StockMovementAvgAggregateOutputType | null
    _sum: StockMovementSumAggregateOutputType | null
    _min: StockMovementMinAggregateOutputType | null
    _max: StockMovementMaxAggregateOutputType | null
  }

  type GetStockMovementGroupByPayload<T extends StockMovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockMovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockMovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockMovementGroupByOutputType[P]>
            : GetScalarType<T[P], StockMovementGroupByOutputType[P]>
        }
      >
    >


  export type StockMovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    warehouseId?: boolean
    quantity?: boolean
    type?: boolean
    reference?: boolean
    companyId?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | StockMovement$warehouseArgs<ExtArgs>
  }, ExtArgs["result"]["stockMovement"]>

  export type StockMovementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    warehouseId?: boolean
    quantity?: boolean
    type?: boolean
    reference?: boolean
    companyId?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | StockMovement$warehouseArgs<ExtArgs>
  }, ExtArgs["result"]["stockMovement"]>

  export type StockMovementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    warehouseId?: boolean
    quantity?: boolean
    type?: boolean
    reference?: boolean
    companyId?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | StockMovement$warehouseArgs<ExtArgs>
  }, ExtArgs["result"]["stockMovement"]>

  export type StockMovementSelectScalar = {
    id?: boolean
    productId?: boolean
    warehouseId?: boolean
    quantity?: boolean
    type?: boolean
    reference?: boolean
    companyId?: boolean
    createdAt?: boolean
  }

  export type StockMovementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "warehouseId" | "quantity" | "type" | "reference" | "companyId" | "createdAt", ExtArgs["result"]["stockMovement"]>
  export type StockMovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | StockMovement$warehouseArgs<ExtArgs>
  }
  export type StockMovementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | StockMovement$warehouseArgs<ExtArgs>
  }
  export type StockMovementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | StockMovement$warehouseArgs<ExtArgs>
  }

  export type $StockMovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockMovement"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      warehouse: Prisma.$WarehousePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      warehouseId: number | null
      quantity: number
      type: string
      reference: string | null
      companyId: number
      createdAt: Date
    }, ExtArgs["result"]["stockMovement"]>
    composites: {}
  }

  type StockMovementGetPayload<S extends boolean | null | undefined | StockMovementDefaultArgs> = $Result.GetResult<Prisma.$StockMovementPayload, S>

  type StockMovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockMovementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockMovementCountAggregateInputType | true
    }

  export interface StockMovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockMovement'], meta: { name: 'StockMovement' } }
    /**
     * Find zero or one StockMovement that matches the filter.
     * @param {StockMovementFindUniqueArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockMovementFindUniqueArgs>(args: SelectSubset<T, StockMovementFindUniqueArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockMovement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockMovementFindUniqueOrThrowArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockMovementFindUniqueOrThrowArgs>(args: SelectSubset<T, StockMovementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockMovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindFirstArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockMovementFindFirstArgs>(args?: SelectSubset<T, StockMovementFindFirstArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockMovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindFirstOrThrowArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockMovementFindFirstOrThrowArgs>(args?: SelectSubset<T, StockMovementFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockMovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockMovements
     * const stockMovements = await prisma.stockMovement.findMany()
     * 
     * // Get first 10 StockMovements
     * const stockMovements = await prisma.stockMovement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockMovementWithIdOnly = await prisma.stockMovement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockMovementFindManyArgs>(args?: SelectSubset<T, StockMovementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockMovement.
     * @param {StockMovementCreateArgs} args - Arguments to create a StockMovement.
     * @example
     * // Create one StockMovement
     * const StockMovement = await prisma.stockMovement.create({
     *   data: {
     *     // ... data to create a StockMovement
     *   }
     * })
     * 
     */
    create<T extends StockMovementCreateArgs>(args: SelectSubset<T, StockMovementCreateArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockMovements.
     * @param {StockMovementCreateManyArgs} args - Arguments to create many StockMovements.
     * @example
     * // Create many StockMovements
     * const stockMovement = await prisma.stockMovement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockMovementCreateManyArgs>(args?: SelectSubset<T, StockMovementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockMovements and returns the data saved in the database.
     * @param {StockMovementCreateManyAndReturnArgs} args - Arguments to create many StockMovements.
     * @example
     * // Create many StockMovements
     * const stockMovement = await prisma.stockMovement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockMovements and only return the `id`
     * const stockMovementWithIdOnly = await prisma.stockMovement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockMovementCreateManyAndReturnArgs>(args?: SelectSubset<T, StockMovementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StockMovement.
     * @param {StockMovementDeleteArgs} args - Arguments to delete one StockMovement.
     * @example
     * // Delete one StockMovement
     * const StockMovement = await prisma.stockMovement.delete({
     *   where: {
     *     // ... filter to delete one StockMovement
     *   }
     * })
     * 
     */
    delete<T extends StockMovementDeleteArgs>(args: SelectSubset<T, StockMovementDeleteArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockMovement.
     * @param {StockMovementUpdateArgs} args - Arguments to update one StockMovement.
     * @example
     * // Update one StockMovement
     * const stockMovement = await prisma.stockMovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockMovementUpdateArgs>(args: SelectSubset<T, StockMovementUpdateArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockMovements.
     * @param {StockMovementDeleteManyArgs} args - Arguments to filter StockMovements to delete.
     * @example
     * // Delete a few StockMovements
     * const { count } = await prisma.stockMovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockMovementDeleteManyArgs>(args?: SelectSubset<T, StockMovementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockMovements
     * const stockMovement = await prisma.stockMovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockMovementUpdateManyArgs>(args: SelectSubset<T, StockMovementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockMovements and returns the data updated in the database.
     * @param {StockMovementUpdateManyAndReturnArgs} args - Arguments to update many StockMovements.
     * @example
     * // Update many StockMovements
     * const stockMovement = await prisma.stockMovement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StockMovements and only return the `id`
     * const stockMovementWithIdOnly = await prisma.stockMovement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockMovementUpdateManyAndReturnArgs>(args: SelectSubset<T, StockMovementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StockMovement.
     * @param {StockMovementUpsertArgs} args - Arguments to update or create a StockMovement.
     * @example
     * // Update or create a StockMovement
     * const stockMovement = await prisma.stockMovement.upsert({
     *   create: {
     *     // ... data to create a StockMovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockMovement we want to update
     *   }
     * })
     */
    upsert<T extends StockMovementUpsertArgs>(args: SelectSubset<T, StockMovementUpsertArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementCountArgs} args - Arguments to filter StockMovements to count.
     * @example
     * // Count the number of StockMovements
     * const count = await prisma.stockMovement.count({
     *   where: {
     *     // ... the filter for the StockMovements we want to count
     *   }
     * })
    **/
    count<T extends StockMovementCountArgs>(
      args?: Subset<T, StockMovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockMovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockMovementAggregateArgs>(args: Subset<T, StockMovementAggregateArgs>): Prisma.PrismaPromise<GetStockMovementAggregateType<T>>

    /**
     * Group by StockMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockMovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockMovementGroupByArgs['orderBy'] }
        : { orderBy?: StockMovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockMovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockMovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockMovement model
   */
  readonly fields: StockMovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockMovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockMovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    warehouse<T extends StockMovement$warehouseArgs<ExtArgs> = {}>(args?: Subset<T, StockMovement$warehouseArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockMovement model
   */
  interface StockMovementFieldRefs {
    readonly id: FieldRef<"StockMovement", 'Int'>
    readonly productId: FieldRef<"StockMovement", 'Int'>
    readonly warehouseId: FieldRef<"StockMovement", 'Int'>
    readonly quantity: FieldRef<"StockMovement", 'Float'>
    readonly type: FieldRef<"StockMovement", 'String'>
    readonly reference: FieldRef<"StockMovement", 'String'>
    readonly companyId: FieldRef<"StockMovement", 'Int'>
    readonly createdAt: FieldRef<"StockMovement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockMovement findUnique
   */
  export type StockMovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement findUniqueOrThrow
   */
  export type StockMovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement findFirst
   */
  export type StockMovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockMovements.
     */
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * StockMovement findFirstOrThrow
   */
  export type StockMovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockMovements.
     */
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * StockMovement findMany
   */
  export type StockMovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovements to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * StockMovement create
   */
  export type StockMovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The data needed to create a StockMovement.
     */
    data: XOR<StockMovementCreateInput, StockMovementUncheckedCreateInput>
  }

  /**
   * StockMovement createMany
   */
  export type StockMovementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockMovements.
     */
    data: StockMovementCreateManyInput | StockMovementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockMovement createManyAndReturn
   */
  export type StockMovementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * The data used to create many StockMovements.
     */
    data: StockMovementCreateManyInput | StockMovementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockMovement update
   */
  export type StockMovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The data needed to update a StockMovement.
     */
    data: XOR<StockMovementUpdateInput, StockMovementUncheckedUpdateInput>
    /**
     * Choose, which StockMovement to update.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement updateMany
   */
  export type StockMovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockMovements.
     */
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyInput>
    /**
     * Filter which StockMovements to update
     */
    where?: StockMovementWhereInput
    /**
     * Limit how many StockMovements to update.
     */
    limit?: number
  }

  /**
   * StockMovement updateManyAndReturn
   */
  export type StockMovementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * The data used to update StockMovements.
     */
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyInput>
    /**
     * Filter which StockMovements to update
     */
    where?: StockMovementWhereInput
    /**
     * Limit how many StockMovements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockMovement upsert
   */
  export type StockMovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The filter to search for the StockMovement to update in case it exists.
     */
    where: StockMovementWhereUniqueInput
    /**
     * In case the StockMovement found by the `where` argument doesn't exist, create a new StockMovement with this data.
     */
    create: XOR<StockMovementCreateInput, StockMovementUncheckedCreateInput>
    /**
     * In case the StockMovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockMovementUpdateInput, StockMovementUncheckedUpdateInput>
  }

  /**
   * StockMovement delete
   */
  export type StockMovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter which StockMovement to delete.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement deleteMany
   */
  export type StockMovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockMovements to delete
     */
    where?: StockMovementWhereInput
    /**
     * Limit how many StockMovements to delete.
     */
    limit?: number
  }

  /**
   * StockMovement.warehouse
   */
  export type StockMovement$warehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    where?: WarehouseWhereInput
  }

  /**
   * StockMovement without action
   */
  export type StockMovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseInvoice
   */

  export type AggregatePurchaseInvoice = {
    _count: PurchaseInvoiceCountAggregateOutputType | null
    _avg: PurchaseInvoiceAvgAggregateOutputType | null
    _sum: PurchaseInvoiceSumAggregateOutputType | null
    _min: PurchaseInvoiceMinAggregateOutputType | null
    _max: PurchaseInvoiceMaxAggregateOutputType | null
  }

  export type PurchaseInvoiceAvgAggregateOutputType = {
    id: number | null
    vendorId: number | null
    totalAmount: number | null
    taxAmount: number | null
    grandTotal: number | null
    approvedById: number | null
    companyId: number | null
    transactionId: number | null
  }

  export type PurchaseInvoiceSumAggregateOutputType = {
    id: number | null
    vendorId: number | null
    totalAmount: number | null
    taxAmount: number | null
    grandTotal: number | null
    approvedById: number | null
    companyId: number | null
    transactionId: number | null
  }

  export type PurchaseInvoiceMinAggregateOutputType = {
    id: number | null
    purchaseNumber: string | null
    date: Date | null
    vendorId: number | null
    status: $Enums.InvoiceStatus | null
    totalAmount: number | null
    taxAmount: number | null
    grandTotal: number | null
    currencyCode: string | null
    isApproved: boolean | null
    approvedById: number | null
    isLocked: boolean | null
    lockedAt: Date | null
    companyId: number | null
    transactionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PurchaseInvoiceMaxAggregateOutputType = {
    id: number | null
    purchaseNumber: string | null
    date: Date | null
    vendorId: number | null
    status: $Enums.InvoiceStatus | null
    totalAmount: number | null
    taxAmount: number | null
    grandTotal: number | null
    currencyCode: string | null
    isApproved: boolean | null
    approvedById: number | null
    isLocked: boolean | null
    lockedAt: Date | null
    companyId: number | null
    transactionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PurchaseInvoiceCountAggregateOutputType = {
    id: number
    purchaseNumber: number
    date: number
    vendorId: number
    status: number
    totalAmount: number
    taxAmount: number
    grandTotal: number
    currencyCode: number
    isApproved: number
    approvedById: number
    isLocked: number
    lockedAt: number
    companyId: number
    transactionId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type PurchaseInvoiceAvgAggregateInputType = {
    id?: true
    vendorId?: true
    totalAmount?: true
    taxAmount?: true
    grandTotal?: true
    approvedById?: true
    companyId?: true
    transactionId?: true
  }

  export type PurchaseInvoiceSumAggregateInputType = {
    id?: true
    vendorId?: true
    totalAmount?: true
    taxAmount?: true
    grandTotal?: true
    approvedById?: true
    companyId?: true
    transactionId?: true
  }

  export type PurchaseInvoiceMinAggregateInputType = {
    id?: true
    purchaseNumber?: true
    date?: true
    vendorId?: true
    status?: true
    totalAmount?: true
    taxAmount?: true
    grandTotal?: true
    currencyCode?: true
    isApproved?: true
    approvedById?: true
    isLocked?: true
    lockedAt?: true
    companyId?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PurchaseInvoiceMaxAggregateInputType = {
    id?: true
    purchaseNumber?: true
    date?: true
    vendorId?: true
    status?: true
    totalAmount?: true
    taxAmount?: true
    grandTotal?: true
    currencyCode?: true
    isApproved?: true
    approvedById?: true
    isLocked?: true
    lockedAt?: true
    companyId?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PurchaseInvoiceCountAggregateInputType = {
    id?: true
    purchaseNumber?: true
    date?: true
    vendorId?: true
    status?: true
    totalAmount?: true
    taxAmount?: true
    grandTotal?: true
    currencyCode?: true
    isApproved?: true
    approvedById?: true
    isLocked?: true
    lockedAt?: true
    companyId?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type PurchaseInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseInvoice to aggregate.
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoices to fetch.
     */
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseInvoices
    **/
    _count?: true | PurchaseInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseInvoiceMaxAggregateInputType
  }

  export type GetPurchaseInvoiceAggregateType<T extends PurchaseInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseInvoice[P]>
      : GetScalarType<T[P], AggregatePurchaseInvoice[P]>
  }




  export type PurchaseInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceWhereInput
    orderBy?: PurchaseInvoiceOrderByWithAggregationInput | PurchaseInvoiceOrderByWithAggregationInput[]
    by: PurchaseInvoiceScalarFieldEnum[] | PurchaseInvoiceScalarFieldEnum
    having?: PurchaseInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseInvoiceCountAggregateInputType | true
    _avg?: PurchaseInvoiceAvgAggregateInputType
    _sum?: PurchaseInvoiceSumAggregateInputType
    _min?: PurchaseInvoiceMinAggregateInputType
    _max?: PurchaseInvoiceMaxAggregateInputType
  }

  export type PurchaseInvoiceGroupByOutputType = {
    id: number
    purchaseNumber: string
    date: Date
    vendorId: number
    status: $Enums.InvoiceStatus
    totalAmount: number
    taxAmount: number
    grandTotal: number
    currencyCode: string
    isApproved: boolean
    approvedById: number | null
    isLocked: boolean
    lockedAt: Date | null
    companyId: number
    transactionId: number | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: PurchaseInvoiceCountAggregateOutputType | null
    _avg: PurchaseInvoiceAvgAggregateOutputType | null
    _sum: PurchaseInvoiceSumAggregateOutputType | null
    _min: PurchaseInvoiceMinAggregateOutputType | null
    _max: PurchaseInvoiceMaxAggregateOutputType | null
  }

  type GetPurchaseInvoiceGroupByPayload<T extends PurchaseInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseNumber?: boolean
    date?: boolean
    vendorId?: boolean
    status?: boolean
    totalAmount?: boolean
    taxAmount?: boolean
    grandTotal?: boolean
    currencyCode?: boolean
    isApproved?: boolean
    approvedById?: boolean
    isLocked?: boolean
    lockedAt?: boolean
    companyId?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    transaction?: boolean | PurchaseInvoice$transactionArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    items?: boolean | PurchaseInvoice$itemsArgs<ExtArgs>
    _count?: boolean | PurchaseInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseInvoice"]>

  export type PurchaseInvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseNumber?: boolean
    date?: boolean
    vendorId?: boolean
    status?: boolean
    totalAmount?: boolean
    taxAmount?: boolean
    grandTotal?: boolean
    currencyCode?: boolean
    isApproved?: boolean
    approvedById?: boolean
    isLocked?: boolean
    lockedAt?: boolean
    companyId?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    transaction?: boolean | PurchaseInvoice$transactionArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseInvoice"]>

  export type PurchaseInvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseNumber?: boolean
    date?: boolean
    vendorId?: boolean
    status?: boolean
    totalAmount?: boolean
    taxAmount?: boolean
    grandTotal?: boolean
    currencyCode?: boolean
    isApproved?: boolean
    approvedById?: boolean
    isLocked?: boolean
    lockedAt?: boolean
    companyId?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    transaction?: boolean | PurchaseInvoice$transactionArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseInvoice"]>

  export type PurchaseInvoiceSelectScalar = {
    id?: boolean
    purchaseNumber?: boolean
    date?: boolean
    vendorId?: boolean
    status?: boolean
    totalAmount?: boolean
    taxAmount?: boolean
    grandTotal?: boolean
    currencyCode?: boolean
    isApproved?: boolean
    approvedById?: boolean
    isLocked?: boolean
    lockedAt?: boolean
    companyId?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type PurchaseInvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "purchaseNumber" | "date" | "vendorId" | "status" | "totalAmount" | "taxAmount" | "grandTotal" | "currencyCode" | "isApproved" | "approvedById" | "isLocked" | "lockedAt" | "companyId" | "transactionId" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["purchaseInvoice"]>
  export type PurchaseInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    transaction?: boolean | PurchaseInvoice$transactionArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    items?: boolean | PurchaseInvoice$itemsArgs<ExtArgs>
    _count?: boolean | PurchaseInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseInvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    transaction?: boolean | PurchaseInvoice$transactionArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type PurchaseInvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    transaction?: boolean | PurchaseInvoice$transactionArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $PurchaseInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseInvoice"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      transaction: Prisma.$TransactionPayload<ExtArgs> | null
      vendor: Prisma.$VendorPayload<ExtArgs>
      items: Prisma.$PurchaseInvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      purchaseNumber: string
      date: Date
      vendorId: number
      status: $Enums.InvoiceStatus
      totalAmount: number
      taxAmount: number
      grandTotal: number
      currencyCode: string
      isApproved: boolean
      approvedById: number | null
      isLocked: boolean
      lockedAt: Date | null
      companyId: number
      transactionId: number | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["purchaseInvoice"]>
    composites: {}
  }

  type PurchaseInvoiceGetPayload<S extends boolean | null | undefined | PurchaseInvoiceDefaultArgs> = $Result.GetResult<Prisma.$PurchaseInvoicePayload, S>

  type PurchaseInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseInvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseInvoiceCountAggregateInputType | true
    }

  export interface PurchaseInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseInvoice'], meta: { name: 'PurchaseInvoice' } }
    /**
     * Find zero or one PurchaseInvoice that matches the filter.
     * @param {PurchaseInvoiceFindUniqueArgs} args - Arguments to find a PurchaseInvoice
     * @example
     * // Get one PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseInvoiceFindUniqueArgs>(args: SelectSubset<T, PurchaseInvoiceFindUniqueArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseInvoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseInvoiceFindUniqueOrThrowArgs} args - Arguments to find a PurchaseInvoice
     * @example
     * // Get one PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceFindFirstArgs} args - Arguments to find a PurchaseInvoice
     * @example
     * // Get one PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseInvoiceFindFirstArgs>(args?: SelectSubset<T, PurchaseInvoiceFindFirstArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceFindFirstOrThrowArgs} args - Arguments to find a PurchaseInvoice
     * @example
     * // Get one PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseInvoices
     * const purchaseInvoices = await prisma.purchaseInvoice.findMany()
     * 
     * // Get first 10 PurchaseInvoices
     * const purchaseInvoices = await prisma.purchaseInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseInvoiceWithIdOnly = await prisma.purchaseInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseInvoiceFindManyArgs>(args?: SelectSubset<T, PurchaseInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseInvoice.
     * @param {PurchaseInvoiceCreateArgs} args - Arguments to create a PurchaseInvoice.
     * @example
     * // Create one PurchaseInvoice
     * const PurchaseInvoice = await prisma.purchaseInvoice.create({
     *   data: {
     *     // ... data to create a PurchaseInvoice
     *   }
     * })
     * 
     */
    create<T extends PurchaseInvoiceCreateArgs>(args: SelectSubset<T, PurchaseInvoiceCreateArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseInvoices.
     * @param {PurchaseInvoiceCreateManyArgs} args - Arguments to create many PurchaseInvoices.
     * @example
     * // Create many PurchaseInvoices
     * const purchaseInvoice = await prisma.purchaseInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseInvoiceCreateManyArgs>(args?: SelectSubset<T, PurchaseInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseInvoices and returns the data saved in the database.
     * @param {PurchaseInvoiceCreateManyAndReturnArgs} args - Arguments to create many PurchaseInvoices.
     * @example
     * // Create many PurchaseInvoices
     * const purchaseInvoice = await prisma.purchaseInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseInvoices and only return the `id`
     * const purchaseInvoiceWithIdOnly = await prisma.purchaseInvoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseInvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseInvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseInvoice.
     * @param {PurchaseInvoiceDeleteArgs} args - Arguments to delete one PurchaseInvoice.
     * @example
     * // Delete one PurchaseInvoice
     * const PurchaseInvoice = await prisma.purchaseInvoice.delete({
     *   where: {
     *     // ... filter to delete one PurchaseInvoice
     *   }
     * })
     * 
     */
    delete<T extends PurchaseInvoiceDeleteArgs>(args: SelectSubset<T, PurchaseInvoiceDeleteArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseInvoice.
     * @param {PurchaseInvoiceUpdateArgs} args - Arguments to update one PurchaseInvoice.
     * @example
     * // Update one PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseInvoiceUpdateArgs>(args: SelectSubset<T, PurchaseInvoiceUpdateArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseInvoices.
     * @param {PurchaseInvoiceDeleteManyArgs} args - Arguments to filter PurchaseInvoices to delete.
     * @example
     * // Delete a few PurchaseInvoices
     * const { count } = await prisma.purchaseInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseInvoiceDeleteManyArgs>(args?: SelectSubset<T, PurchaseInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseInvoices
     * const purchaseInvoice = await prisma.purchaseInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseInvoiceUpdateManyArgs>(args: SelectSubset<T, PurchaseInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseInvoices and returns the data updated in the database.
     * @param {PurchaseInvoiceUpdateManyAndReturnArgs} args - Arguments to update many PurchaseInvoices.
     * @example
     * // Update many PurchaseInvoices
     * const purchaseInvoice = await prisma.purchaseInvoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseInvoices and only return the `id`
     * const purchaseInvoiceWithIdOnly = await prisma.purchaseInvoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseInvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseInvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseInvoice.
     * @param {PurchaseInvoiceUpsertArgs} args - Arguments to update or create a PurchaseInvoice.
     * @example
     * // Update or create a PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.upsert({
     *   create: {
     *     // ... data to create a PurchaseInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseInvoice we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseInvoiceUpsertArgs>(args: SelectSubset<T, PurchaseInvoiceUpsertArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceCountArgs} args - Arguments to filter PurchaseInvoices to count.
     * @example
     * // Count the number of PurchaseInvoices
     * const count = await prisma.purchaseInvoice.count({
     *   where: {
     *     // ... the filter for the PurchaseInvoices we want to count
     *   }
     * })
    **/
    count<T extends PurchaseInvoiceCountArgs>(
      args?: Subset<T, PurchaseInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseInvoiceAggregateArgs>(args: Subset<T, PurchaseInvoiceAggregateArgs>): Prisma.PrismaPromise<GetPurchaseInvoiceAggregateType<T>>

    /**
     * Group by PurchaseInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseInvoice model
   */
  readonly fields: PurchaseInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transaction<T extends PurchaseInvoice$transactionArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseInvoice$transactionArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends PurchaseInvoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseInvoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseInvoice model
   */
  interface PurchaseInvoiceFieldRefs {
    readonly id: FieldRef<"PurchaseInvoice", 'Int'>
    readonly purchaseNumber: FieldRef<"PurchaseInvoice", 'String'>
    readonly date: FieldRef<"PurchaseInvoice", 'DateTime'>
    readonly vendorId: FieldRef<"PurchaseInvoice", 'Int'>
    readonly status: FieldRef<"PurchaseInvoice", 'InvoiceStatus'>
    readonly totalAmount: FieldRef<"PurchaseInvoice", 'Float'>
    readonly taxAmount: FieldRef<"PurchaseInvoice", 'Float'>
    readonly grandTotal: FieldRef<"PurchaseInvoice", 'Float'>
    readonly currencyCode: FieldRef<"PurchaseInvoice", 'String'>
    readonly isApproved: FieldRef<"PurchaseInvoice", 'Boolean'>
    readonly approvedById: FieldRef<"PurchaseInvoice", 'Int'>
    readonly isLocked: FieldRef<"PurchaseInvoice", 'Boolean'>
    readonly lockedAt: FieldRef<"PurchaseInvoice", 'DateTime'>
    readonly companyId: FieldRef<"PurchaseInvoice", 'Int'>
    readonly transactionId: FieldRef<"PurchaseInvoice", 'Int'>
    readonly createdAt: FieldRef<"PurchaseInvoice", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseInvoice", 'DateTime'>
    readonly deletedAt: FieldRef<"PurchaseInvoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseInvoice findUnique
   */
  export type PurchaseInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoice to fetch.
     */
    where: PurchaseInvoiceWhereUniqueInput
  }

  /**
   * PurchaseInvoice findUniqueOrThrow
   */
  export type PurchaseInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoice to fetch.
     */
    where: PurchaseInvoiceWhereUniqueInput
  }

  /**
   * PurchaseInvoice findFirst
   */
  export type PurchaseInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoice to fetch.
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoices to fetch.
     */
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseInvoices.
     */
    cursor?: PurchaseInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseInvoices.
     */
    distinct?: PurchaseInvoiceScalarFieldEnum | PurchaseInvoiceScalarFieldEnum[]
  }

  /**
   * PurchaseInvoice findFirstOrThrow
   */
  export type PurchaseInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoice to fetch.
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoices to fetch.
     */
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseInvoices.
     */
    cursor?: PurchaseInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseInvoices.
     */
    distinct?: PurchaseInvoiceScalarFieldEnum | PurchaseInvoiceScalarFieldEnum[]
  }

  /**
   * PurchaseInvoice findMany
   */
  export type PurchaseInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoices to fetch.
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoices to fetch.
     */
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseInvoices.
     */
    cursor?: PurchaseInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoices.
     */
    skip?: number
    distinct?: PurchaseInvoiceScalarFieldEnum | PurchaseInvoiceScalarFieldEnum[]
  }

  /**
   * PurchaseInvoice create
   */
  export type PurchaseInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseInvoice.
     */
    data: XOR<PurchaseInvoiceCreateInput, PurchaseInvoiceUncheckedCreateInput>
  }

  /**
   * PurchaseInvoice createMany
   */
  export type PurchaseInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseInvoices.
     */
    data: PurchaseInvoiceCreateManyInput | PurchaseInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseInvoice createManyAndReturn
   */
  export type PurchaseInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseInvoices.
     */
    data: PurchaseInvoiceCreateManyInput | PurchaseInvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseInvoice update
   */
  export type PurchaseInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseInvoice.
     */
    data: XOR<PurchaseInvoiceUpdateInput, PurchaseInvoiceUncheckedUpdateInput>
    /**
     * Choose, which PurchaseInvoice to update.
     */
    where: PurchaseInvoiceWhereUniqueInput
  }

  /**
   * PurchaseInvoice updateMany
   */
  export type PurchaseInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseInvoices.
     */
    data: XOR<PurchaseInvoiceUpdateManyMutationInput, PurchaseInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseInvoices to update
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * Limit how many PurchaseInvoices to update.
     */
    limit?: number
  }

  /**
   * PurchaseInvoice updateManyAndReturn
   */
  export type PurchaseInvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseInvoices.
     */
    data: XOR<PurchaseInvoiceUpdateManyMutationInput, PurchaseInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseInvoices to update
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * Limit how many PurchaseInvoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseInvoice upsert
   */
  export type PurchaseInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseInvoice to update in case it exists.
     */
    where: PurchaseInvoiceWhereUniqueInput
    /**
     * In case the PurchaseInvoice found by the `where` argument doesn't exist, create a new PurchaseInvoice with this data.
     */
    create: XOR<PurchaseInvoiceCreateInput, PurchaseInvoiceUncheckedCreateInput>
    /**
     * In case the PurchaseInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseInvoiceUpdateInput, PurchaseInvoiceUncheckedUpdateInput>
  }

  /**
   * PurchaseInvoice delete
   */
  export type PurchaseInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter which PurchaseInvoice to delete.
     */
    where: PurchaseInvoiceWhereUniqueInput
  }

  /**
   * PurchaseInvoice deleteMany
   */
  export type PurchaseInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseInvoices to delete
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * Limit how many PurchaseInvoices to delete.
     */
    limit?: number
  }

  /**
   * PurchaseInvoice.transaction
   */
  export type PurchaseInvoice$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
  }

  /**
   * PurchaseInvoice.items
   */
  export type PurchaseInvoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    where?: PurchaseInvoiceItemWhereInput
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseInvoiceItemScalarFieldEnum | PurchaseInvoiceItemScalarFieldEnum[]
  }

  /**
   * PurchaseInvoice without action
   */
  export type PurchaseInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseInvoiceItem
   */

  export type AggregatePurchaseInvoiceItem = {
    _count: PurchaseInvoiceItemCountAggregateOutputType | null
    _avg: PurchaseInvoiceItemAvgAggregateOutputType | null
    _sum: PurchaseInvoiceItemSumAggregateOutputType | null
    _min: PurchaseInvoiceItemMinAggregateOutputType | null
    _max: PurchaseInvoiceItemMaxAggregateOutputType | null
  }

  export type PurchaseInvoiceItemAvgAggregateOutputType = {
    id: number | null
    purchaseInvoiceId: number | null
    productId: number | null
    quantity: number | null
    rate: number | null
    amount: number | null
    taxPercentage: number | null
    taxAmount: number | null
    total: number | null
  }

  export type PurchaseInvoiceItemSumAggregateOutputType = {
    id: number | null
    purchaseInvoiceId: number | null
    productId: number | null
    quantity: number | null
    rate: number | null
    amount: number | null
    taxPercentage: number | null
    taxAmount: number | null
    total: number | null
  }

  export type PurchaseInvoiceItemMinAggregateOutputType = {
    id: number | null
    purchaseInvoiceId: number | null
    productId: number | null
    description: string | null
    quantity: number | null
    rate: number | null
    amount: number | null
    taxPercentage: number | null
    taxAmount: number | null
    total: number | null
  }

  export type PurchaseInvoiceItemMaxAggregateOutputType = {
    id: number | null
    purchaseInvoiceId: number | null
    productId: number | null
    description: string | null
    quantity: number | null
    rate: number | null
    amount: number | null
    taxPercentage: number | null
    taxAmount: number | null
    total: number | null
  }

  export type PurchaseInvoiceItemCountAggregateOutputType = {
    id: number
    purchaseInvoiceId: number
    productId: number
    description: number
    quantity: number
    rate: number
    amount: number
    taxPercentage: number
    taxAmount: number
    total: number
    _all: number
  }


  export type PurchaseInvoiceItemAvgAggregateInputType = {
    id?: true
    purchaseInvoiceId?: true
    productId?: true
    quantity?: true
    rate?: true
    amount?: true
    taxPercentage?: true
    taxAmount?: true
    total?: true
  }

  export type PurchaseInvoiceItemSumAggregateInputType = {
    id?: true
    purchaseInvoiceId?: true
    productId?: true
    quantity?: true
    rate?: true
    amount?: true
    taxPercentage?: true
    taxAmount?: true
    total?: true
  }

  export type PurchaseInvoiceItemMinAggregateInputType = {
    id?: true
    purchaseInvoiceId?: true
    productId?: true
    description?: true
    quantity?: true
    rate?: true
    amount?: true
    taxPercentage?: true
    taxAmount?: true
    total?: true
  }

  export type PurchaseInvoiceItemMaxAggregateInputType = {
    id?: true
    purchaseInvoiceId?: true
    productId?: true
    description?: true
    quantity?: true
    rate?: true
    amount?: true
    taxPercentage?: true
    taxAmount?: true
    total?: true
  }

  export type PurchaseInvoiceItemCountAggregateInputType = {
    id?: true
    purchaseInvoiceId?: true
    productId?: true
    description?: true
    quantity?: true
    rate?: true
    amount?: true
    taxPercentage?: true
    taxAmount?: true
    total?: true
    _all?: true
  }

  export type PurchaseInvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseInvoiceItem to aggregate.
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoiceItems to fetch.
     */
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseInvoiceItems
    **/
    _count?: true | PurchaseInvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseInvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseInvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseInvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseInvoiceItemMaxAggregateInputType
  }

  export type GetPurchaseInvoiceItemAggregateType<T extends PurchaseInvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseInvoiceItem[P]>
      : GetScalarType<T[P], AggregatePurchaseInvoiceItem[P]>
  }




  export type PurchaseInvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceItemWhereInput
    orderBy?: PurchaseInvoiceItemOrderByWithAggregationInput | PurchaseInvoiceItemOrderByWithAggregationInput[]
    by: PurchaseInvoiceItemScalarFieldEnum[] | PurchaseInvoiceItemScalarFieldEnum
    having?: PurchaseInvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseInvoiceItemCountAggregateInputType | true
    _avg?: PurchaseInvoiceItemAvgAggregateInputType
    _sum?: PurchaseInvoiceItemSumAggregateInputType
    _min?: PurchaseInvoiceItemMinAggregateInputType
    _max?: PurchaseInvoiceItemMaxAggregateInputType
  }

  export type PurchaseInvoiceItemGroupByOutputType = {
    id: number
    purchaseInvoiceId: number
    productId: number
    description: string | null
    quantity: number
    rate: number
    amount: number
    taxPercentage: number
    taxAmount: number
    total: number
    _count: PurchaseInvoiceItemCountAggregateOutputType | null
    _avg: PurchaseInvoiceItemAvgAggregateOutputType | null
    _sum: PurchaseInvoiceItemSumAggregateOutputType | null
    _min: PurchaseInvoiceItemMinAggregateOutputType | null
    _max: PurchaseInvoiceItemMaxAggregateOutputType | null
  }

  type GetPurchaseInvoiceItemGroupByPayload<T extends PurchaseInvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseInvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseInvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseInvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseInvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseInvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseInvoiceId?: boolean
    productId?: boolean
    description?: boolean
    quantity?: boolean
    rate?: boolean
    amount?: boolean
    taxPercentage?: boolean
    taxAmount?: boolean
    total?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    purchaseInvoice?: boolean | PurchaseInvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseInvoiceItem"]>

  export type PurchaseInvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseInvoiceId?: boolean
    productId?: boolean
    description?: boolean
    quantity?: boolean
    rate?: boolean
    amount?: boolean
    taxPercentage?: boolean
    taxAmount?: boolean
    total?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    purchaseInvoice?: boolean | PurchaseInvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseInvoiceItem"]>

  export type PurchaseInvoiceItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseInvoiceId?: boolean
    productId?: boolean
    description?: boolean
    quantity?: boolean
    rate?: boolean
    amount?: boolean
    taxPercentage?: boolean
    taxAmount?: boolean
    total?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    purchaseInvoice?: boolean | PurchaseInvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseInvoiceItem"]>

  export type PurchaseInvoiceItemSelectScalar = {
    id?: boolean
    purchaseInvoiceId?: boolean
    productId?: boolean
    description?: boolean
    quantity?: boolean
    rate?: boolean
    amount?: boolean
    taxPercentage?: boolean
    taxAmount?: boolean
    total?: boolean
  }

  export type PurchaseInvoiceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "purchaseInvoiceId" | "productId" | "description" | "quantity" | "rate" | "amount" | "taxPercentage" | "taxAmount" | "total", ExtArgs["result"]["purchaseInvoiceItem"]>
  export type PurchaseInvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    purchaseInvoice?: boolean | PurchaseInvoiceDefaultArgs<ExtArgs>
  }
  export type PurchaseInvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    purchaseInvoice?: boolean | PurchaseInvoiceDefaultArgs<ExtArgs>
  }
  export type PurchaseInvoiceItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    purchaseInvoice?: boolean | PurchaseInvoiceDefaultArgs<ExtArgs>
  }

  export type $PurchaseInvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseInvoiceItem"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      purchaseInvoice: Prisma.$PurchaseInvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      purchaseInvoiceId: number
      productId: number
      description: string | null
      quantity: number
      rate: number
      amount: number
      taxPercentage: number
      taxAmount: number
      total: number
    }, ExtArgs["result"]["purchaseInvoiceItem"]>
    composites: {}
  }

  type PurchaseInvoiceItemGetPayload<S extends boolean | null | undefined | PurchaseInvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$PurchaseInvoiceItemPayload, S>

  type PurchaseInvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseInvoiceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseInvoiceItemCountAggregateInputType | true
    }

  export interface PurchaseInvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseInvoiceItem'], meta: { name: 'PurchaseInvoiceItem' } }
    /**
     * Find zero or one PurchaseInvoiceItem that matches the filter.
     * @param {PurchaseInvoiceItemFindUniqueArgs} args - Arguments to find a PurchaseInvoiceItem
     * @example
     * // Get one PurchaseInvoiceItem
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseInvoiceItemFindUniqueArgs>(args: SelectSubset<T, PurchaseInvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseInvoiceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseInvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a PurchaseInvoiceItem
     * @example
     * // Get one PurchaseInvoiceItem
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseInvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseInvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseInvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemFindFirstArgs} args - Arguments to find a PurchaseInvoiceItem
     * @example
     * // Get one PurchaseInvoiceItem
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseInvoiceItemFindFirstArgs>(args?: SelectSubset<T, PurchaseInvoiceItemFindFirstArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseInvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemFindFirstOrThrowArgs} args - Arguments to find a PurchaseInvoiceItem
     * @example
     * // Get one PurchaseInvoiceItem
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseInvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseInvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseInvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseInvoiceItems
     * const purchaseInvoiceItems = await prisma.purchaseInvoiceItem.findMany()
     * 
     * // Get first 10 PurchaseInvoiceItems
     * const purchaseInvoiceItems = await prisma.purchaseInvoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseInvoiceItemWithIdOnly = await prisma.purchaseInvoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseInvoiceItemFindManyArgs>(args?: SelectSubset<T, PurchaseInvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseInvoiceItem.
     * @param {PurchaseInvoiceItemCreateArgs} args - Arguments to create a PurchaseInvoiceItem.
     * @example
     * // Create one PurchaseInvoiceItem
     * const PurchaseInvoiceItem = await prisma.purchaseInvoiceItem.create({
     *   data: {
     *     // ... data to create a PurchaseInvoiceItem
     *   }
     * })
     * 
     */
    create<T extends PurchaseInvoiceItemCreateArgs>(args: SelectSubset<T, PurchaseInvoiceItemCreateArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseInvoiceItems.
     * @param {PurchaseInvoiceItemCreateManyArgs} args - Arguments to create many PurchaseInvoiceItems.
     * @example
     * // Create many PurchaseInvoiceItems
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseInvoiceItemCreateManyArgs>(args?: SelectSubset<T, PurchaseInvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseInvoiceItems and returns the data saved in the database.
     * @param {PurchaseInvoiceItemCreateManyAndReturnArgs} args - Arguments to create many PurchaseInvoiceItems.
     * @example
     * // Create many PurchaseInvoiceItems
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseInvoiceItems and only return the `id`
     * const purchaseInvoiceItemWithIdOnly = await prisma.purchaseInvoiceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseInvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseInvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseInvoiceItem.
     * @param {PurchaseInvoiceItemDeleteArgs} args - Arguments to delete one PurchaseInvoiceItem.
     * @example
     * // Delete one PurchaseInvoiceItem
     * const PurchaseInvoiceItem = await prisma.purchaseInvoiceItem.delete({
     *   where: {
     *     // ... filter to delete one PurchaseInvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends PurchaseInvoiceItemDeleteArgs>(args: SelectSubset<T, PurchaseInvoiceItemDeleteArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseInvoiceItem.
     * @param {PurchaseInvoiceItemUpdateArgs} args - Arguments to update one PurchaseInvoiceItem.
     * @example
     * // Update one PurchaseInvoiceItem
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseInvoiceItemUpdateArgs>(args: SelectSubset<T, PurchaseInvoiceItemUpdateArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseInvoiceItems.
     * @param {PurchaseInvoiceItemDeleteManyArgs} args - Arguments to filter PurchaseInvoiceItems to delete.
     * @example
     * // Delete a few PurchaseInvoiceItems
     * const { count } = await prisma.purchaseInvoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseInvoiceItemDeleteManyArgs>(args?: SelectSubset<T, PurchaseInvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseInvoiceItems
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseInvoiceItemUpdateManyArgs>(args: SelectSubset<T, PurchaseInvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseInvoiceItems and returns the data updated in the database.
     * @param {PurchaseInvoiceItemUpdateManyAndReturnArgs} args - Arguments to update many PurchaseInvoiceItems.
     * @example
     * // Update many PurchaseInvoiceItems
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseInvoiceItems and only return the `id`
     * const purchaseInvoiceItemWithIdOnly = await prisma.purchaseInvoiceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseInvoiceItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseInvoiceItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseInvoiceItem.
     * @param {PurchaseInvoiceItemUpsertArgs} args - Arguments to update or create a PurchaseInvoiceItem.
     * @example
     * // Update or create a PurchaseInvoiceItem
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.upsert({
     *   create: {
     *     // ... data to create a PurchaseInvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseInvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseInvoiceItemUpsertArgs>(args: SelectSubset<T, PurchaseInvoiceItemUpsertArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemCountArgs} args - Arguments to filter PurchaseInvoiceItems to count.
     * @example
     * // Count the number of PurchaseInvoiceItems
     * const count = await prisma.purchaseInvoiceItem.count({
     *   where: {
     *     // ... the filter for the PurchaseInvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends PurchaseInvoiceItemCountArgs>(
      args?: Subset<T, PurchaseInvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseInvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseInvoiceItemAggregateArgs>(args: Subset<T, PurchaseInvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetPurchaseInvoiceItemAggregateType<T>>

    /**
     * Group by PurchaseInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseInvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseInvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseInvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseInvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseInvoiceItem model
   */
  readonly fields: PurchaseInvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseInvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseInvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchaseInvoice<T extends PurchaseInvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseInvoiceDefaultArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseInvoiceItem model
   */
  interface PurchaseInvoiceItemFieldRefs {
    readonly id: FieldRef<"PurchaseInvoiceItem", 'Int'>
    readonly purchaseInvoiceId: FieldRef<"PurchaseInvoiceItem", 'Int'>
    readonly productId: FieldRef<"PurchaseInvoiceItem", 'Int'>
    readonly description: FieldRef<"PurchaseInvoiceItem", 'String'>
    readonly quantity: FieldRef<"PurchaseInvoiceItem", 'Float'>
    readonly rate: FieldRef<"PurchaseInvoiceItem", 'Float'>
    readonly amount: FieldRef<"PurchaseInvoiceItem", 'Float'>
    readonly taxPercentage: FieldRef<"PurchaseInvoiceItem", 'Float'>
    readonly taxAmount: FieldRef<"PurchaseInvoiceItem", 'Float'>
    readonly total: FieldRef<"PurchaseInvoiceItem", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseInvoiceItem findUnique
   */
  export type PurchaseInvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoiceItem to fetch.
     */
    where: PurchaseInvoiceItemWhereUniqueInput
  }

  /**
   * PurchaseInvoiceItem findUniqueOrThrow
   */
  export type PurchaseInvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoiceItem to fetch.
     */
    where: PurchaseInvoiceItemWhereUniqueInput
  }

  /**
   * PurchaseInvoiceItem findFirst
   */
  export type PurchaseInvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoiceItem to fetch.
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoiceItems to fetch.
     */
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseInvoiceItems.
     */
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseInvoiceItems.
     */
    distinct?: PurchaseInvoiceItemScalarFieldEnum | PurchaseInvoiceItemScalarFieldEnum[]
  }

  /**
   * PurchaseInvoiceItem findFirstOrThrow
   */
  export type PurchaseInvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoiceItem to fetch.
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoiceItems to fetch.
     */
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseInvoiceItems.
     */
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseInvoiceItems.
     */
    distinct?: PurchaseInvoiceItemScalarFieldEnum | PurchaseInvoiceItemScalarFieldEnum[]
  }

  /**
   * PurchaseInvoiceItem findMany
   */
  export type PurchaseInvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoiceItems to fetch.
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoiceItems to fetch.
     */
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseInvoiceItems.
     */
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoiceItems.
     */
    skip?: number
    distinct?: PurchaseInvoiceItemScalarFieldEnum | PurchaseInvoiceItemScalarFieldEnum[]
  }

  /**
   * PurchaseInvoiceItem create
   */
  export type PurchaseInvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseInvoiceItem.
     */
    data: XOR<PurchaseInvoiceItemCreateInput, PurchaseInvoiceItemUncheckedCreateInput>
  }

  /**
   * PurchaseInvoiceItem createMany
   */
  export type PurchaseInvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseInvoiceItems.
     */
    data: PurchaseInvoiceItemCreateManyInput | PurchaseInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseInvoiceItem createManyAndReturn
   */
  export type PurchaseInvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseInvoiceItems.
     */
    data: PurchaseInvoiceItemCreateManyInput | PurchaseInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseInvoiceItem update
   */
  export type PurchaseInvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseInvoiceItem.
     */
    data: XOR<PurchaseInvoiceItemUpdateInput, PurchaseInvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which PurchaseInvoiceItem to update.
     */
    where: PurchaseInvoiceItemWhereUniqueInput
  }

  /**
   * PurchaseInvoiceItem updateMany
   */
  export type PurchaseInvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseInvoiceItems.
     */
    data: XOR<PurchaseInvoiceItemUpdateManyMutationInput, PurchaseInvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseInvoiceItems to update
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * Limit how many PurchaseInvoiceItems to update.
     */
    limit?: number
  }

  /**
   * PurchaseInvoiceItem updateManyAndReturn
   */
  export type PurchaseInvoiceItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseInvoiceItems.
     */
    data: XOR<PurchaseInvoiceItemUpdateManyMutationInput, PurchaseInvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseInvoiceItems to update
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * Limit how many PurchaseInvoiceItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseInvoiceItem upsert
   */
  export type PurchaseInvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseInvoiceItem to update in case it exists.
     */
    where: PurchaseInvoiceItemWhereUniqueInput
    /**
     * In case the PurchaseInvoiceItem found by the `where` argument doesn't exist, create a new PurchaseInvoiceItem with this data.
     */
    create: XOR<PurchaseInvoiceItemCreateInput, PurchaseInvoiceItemUncheckedCreateInput>
    /**
     * In case the PurchaseInvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseInvoiceItemUpdateInput, PurchaseInvoiceItemUncheckedUpdateInput>
  }

  /**
   * PurchaseInvoiceItem delete
   */
  export type PurchaseInvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which PurchaseInvoiceItem to delete.
     */
    where: PurchaseInvoiceItemWhereUniqueInput
  }

  /**
   * PurchaseInvoiceItem deleteMany
   */
  export type PurchaseInvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseInvoiceItems to delete
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * Limit how many PurchaseInvoiceItems to delete.
     */
    limit?: number
  }

  /**
   * PurchaseInvoiceItem without action
   */
  export type PurchaseInvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    id: number | null
    parentId: number | null
    companyId: number | null
  }

  export type AccountSumAggregateOutputType = {
    id: number | null
    parentId: number | null
    companyId: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    type: $Enums.AccountType | null
    description: string | null
    parentId: number | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    division: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    type: $Enums.AccountType | null
    description: string | null
    parentId: number | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    division: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    code: number
    name: number
    type: number
    description: number
    parentId: number
    companyId: number
    createdAt: number
    updatedAt: number
    division: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    id?: true
    parentId?: true
    companyId?: true
  }

  export type AccountSumAggregateInputType = {
    id?: true
    parentId?: true
    companyId?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    type?: true
    description?: true
    parentId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    division?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    type?: true
    description?: true
    parentId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    division?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    type?: true
    description?: true
    parentId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    division?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: number
    code: string
    name: string
    type: $Enums.AccountType
    description: string | null
    parentId: number | null
    companyId: number
    createdAt: Date
    updatedAt: Date
    division: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    parentId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    division?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    parent?: boolean | Account$parentArgs<ExtArgs>
    children?: boolean | Account$childrenArgs<ExtArgs>
    entries?: boolean | Account$entriesArgs<ExtArgs>
    customer?: boolean | Account$customerArgs<ExtArgs>
    vendor?: boolean | Account$vendorArgs<ExtArgs>
    voucherEntries?: boolean | Account$voucherEntriesArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    parentId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    division?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    parent?: boolean | Account$parentArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    parentId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    division?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    parent?: boolean | Account$parentArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    parentId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    division?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "type" | "description" | "parentId" | "companyId" | "createdAt" | "updatedAt" | "division", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    parent?: boolean | Account$parentArgs<ExtArgs>
    children?: boolean | Account$childrenArgs<ExtArgs>
    entries?: boolean | Account$entriesArgs<ExtArgs>
    customer?: boolean | Account$customerArgs<ExtArgs>
    vendor?: boolean | Account$vendorArgs<ExtArgs>
    voucherEntries?: boolean | Account$voucherEntriesArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    parent?: boolean | Account$parentArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    parent?: boolean | Account$parentArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      parent: Prisma.$AccountPayload<ExtArgs> | null
      children: Prisma.$AccountPayload<ExtArgs>[]
      entries: Prisma.$AccountEntryPayload<ExtArgs>[]
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      vendor: Prisma.$VendorPayload<ExtArgs> | null
      voucherEntries: Prisma.$VoucherEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      type: $Enums.AccountType
      description: string | null
      parentId: number | null
      companyId: number
      createdAt: Date
      updatedAt: Date
      division: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends Account$parentArgs<ExtArgs> = {}>(args?: Subset<T, Account$parentArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Account$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Account$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    entries<T extends Account$entriesArgs<ExtArgs> = {}>(args?: Subset<T, Account$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customer<T extends Account$customerArgs<ExtArgs> = {}>(args?: Subset<T, Account$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    vendor<T extends Account$vendorArgs<ExtArgs> = {}>(args?: Subset<T, Account$vendorArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    voucherEntries<T extends Account$voucherEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Account$voucherEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'Int'>
    readonly code: FieldRef<"Account", 'String'>
    readonly name: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'AccountType'>
    readonly description: FieldRef<"Account", 'String'>
    readonly parentId: FieldRef<"Account", 'Int'>
    readonly companyId: FieldRef<"Account", 'Int'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
    readonly division: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account.parent
   */
  export type Account$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Account.children
   */
  export type Account$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account.entries
   */
  export type Account$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountEntry
     */
    select?: AccountEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountEntry
     */
    omit?: AccountEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountEntryInclude<ExtArgs> | null
    where?: AccountEntryWhereInput
    orderBy?: AccountEntryOrderByWithRelationInput | AccountEntryOrderByWithRelationInput[]
    cursor?: AccountEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountEntryScalarFieldEnum | AccountEntryScalarFieldEnum[]
  }

  /**
   * Account.customer
   */
  export type Account$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Account.vendor
   */
  export type Account$vendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
  }

  /**
   * Account.voucherEntries
   */
  export type Account$voucherEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherEntry
     */
    select?: VoucherEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherEntry
     */
    omit?: VoucherEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherEntryInclude<ExtArgs> | null
    where?: VoucherEntryWhereInput
    orderBy?: VoucherEntryOrderByWithRelationInput | VoucherEntryOrderByWithRelationInput[]
    cursor?: VoucherEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherEntryScalarFieldEnum | VoucherEntryScalarFieldEnum[]
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type TransactionSumAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: number | null
    reference: string | null
    date: Date | null
    description: string | null
    type: $Enums.TransactionType | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isLocked: boolean | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: number | null
    reference: string | null
    date: Date | null
    description: string | null
    type: $Enums.TransactionType | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isLocked: boolean | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    reference: number
    date: number
    description: number
    type: number
    companyId: number
    createdAt: number
    updatedAt: number
    isLocked: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type TransactionSumAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    reference?: true
    date?: true
    description?: true
    type?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    isLocked?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    reference?: true
    date?: true
    description?: true
    type?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    isLocked?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    reference?: true
    date?: true
    description?: true
    type?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    isLocked?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: number
    reference: string
    date: Date
    description: string | null
    type: $Enums.TransactionType
    companyId: number
    createdAt: Date
    updatedAt: Date
    isLocked: boolean
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reference?: boolean
    date?: boolean
    description?: boolean
    type?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isLocked?: boolean
    entries?: boolean | Transaction$entriesArgs<ExtArgs>
    service?: boolean | Transaction$serviceArgs<ExtArgs>
    freight?: boolean | Transaction$freightArgs<ExtArgs>
    payment?: boolean | Transaction$paymentArgs<ExtArgs>
    purchase?: boolean | Transaction$purchaseArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reference?: boolean
    date?: boolean
    description?: boolean
    type?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isLocked?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reference?: boolean
    date?: boolean
    description?: boolean
    type?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isLocked?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    reference?: boolean
    date?: boolean
    description?: boolean
    type?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isLocked?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reference" | "date" | "description" | "type" | "companyId" | "createdAt" | "updatedAt" | "isLocked", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | Transaction$entriesArgs<ExtArgs>
    service?: boolean | Transaction$serviceArgs<ExtArgs>
    freight?: boolean | Transaction$freightArgs<ExtArgs>
    payment?: boolean | Transaction$paymentArgs<ExtArgs>
    purchase?: boolean | Transaction$purchaseArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      entries: Prisma.$AccountEntryPayload<ExtArgs>[]
      service: Prisma.$ServiceInvoicePayload<ExtArgs> | null
      freight: Prisma.$FreightInvoicePayload<ExtArgs> | null
      payment: Prisma.$PaymentPayload<ExtArgs> | null
      purchase: Prisma.$PurchaseInvoicePayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      reference: string
      date: Date
      description: string | null
      type: $Enums.TransactionType
      companyId: number
      createdAt: Date
      updatedAt: Date
      isLocked: boolean
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entries<T extends Transaction$entriesArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    service<T extends Transaction$serviceArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$serviceArgs<ExtArgs>>): Prisma__ServiceInvoiceClient<$Result.GetResult<Prisma.$ServiceInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    freight<T extends Transaction$freightArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$freightArgs<ExtArgs>>): Prisma__FreightInvoiceClient<$Result.GetResult<Prisma.$FreightInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payment<T extends Transaction$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$paymentArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    purchase<T extends Transaction$purchaseArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$purchaseArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'Int'>
    readonly reference: FieldRef<"Transaction", 'String'>
    readonly date: FieldRef<"Transaction", 'DateTime'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly type: FieldRef<"Transaction", 'TransactionType'>
    readonly companyId: FieldRef<"Transaction", 'Int'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
    readonly isLocked: FieldRef<"Transaction", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.entries
   */
  export type Transaction$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountEntry
     */
    select?: AccountEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountEntry
     */
    omit?: AccountEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountEntryInclude<ExtArgs> | null
    where?: AccountEntryWhereInput
    orderBy?: AccountEntryOrderByWithRelationInput | AccountEntryOrderByWithRelationInput[]
    cursor?: AccountEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountEntryScalarFieldEnum | AccountEntryScalarFieldEnum[]
  }

  /**
   * Transaction.service
   */
  export type Transaction$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInvoice
     */
    select?: ServiceInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInvoice
     */
    omit?: ServiceInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInvoiceInclude<ExtArgs> | null
    where?: ServiceInvoiceWhereInput
  }

  /**
   * Transaction.freight
   */
  export type Transaction$freightArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreightInvoice
     */
    select?: FreightInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreightInvoice
     */
    omit?: FreightInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreightInvoiceInclude<ExtArgs> | null
    where?: FreightInvoiceWhereInput
  }

  /**
   * Transaction.payment
   */
  export type Transaction$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
  }

  /**
   * Transaction.purchase
   */
  export type Transaction$purchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    where?: PurchaseInvoiceWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model AccountEntry
   */

  export type AggregateAccountEntry = {
    _count: AccountEntryCountAggregateOutputType | null
    _avg: AccountEntryAvgAggregateOutputType | null
    _sum: AccountEntrySumAggregateOutputType | null
    _min: AccountEntryMinAggregateOutputType | null
    _max: AccountEntryMaxAggregateOutputType | null
  }

  export type AccountEntryAvgAggregateOutputType = {
    id: number | null
    transactionId: number | null
    accountId: number | null
    debit: number | null
    credit: number | null
  }

  export type AccountEntrySumAggregateOutputType = {
    id: number | null
    transactionId: number | null
    accountId: number | null
    debit: number | null
    credit: number | null
  }

  export type AccountEntryMinAggregateOutputType = {
    id: number | null
    transactionId: number | null
    accountId: number | null
    description: string | null
    debit: number | null
    credit: number | null
    createdAt: Date | null
  }

  export type AccountEntryMaxAggregateOutputType = {
    id: number | null
    transactionId: number | null
    accountId: number | null
    description: string | null
    debit: number | null
    credit: number | null
    createdAt: Date | null
  }

  export type AccountEntryCountAggregateOutputType = {
    id: number
    transactionId: number
    accountId: number
    description: number
    debit: number
    credit: number
    createdAt: number
    _all: number
  }


  export type AccountEntryAvgAggregateInputType = {
    id?: true
    transactionId?: true
    accountId?: true
    debit?: true
    credit?: true
  }

  export type AccountEntrySumAggregateInputType = {
    id?: true
    transactionId?: true
    accountId?: true
    debit?: true
    credit?: true
  }

  export type AccountEntryMinAggregateInputType = {
    id?: true
    transactionId?: true
    accountId?: true
    description?: true
    debit?: true
    credit?: true
    createdAt?: true
  }

  export type AccountEntryMaxAggregateInputType = {
    id?: true
    transactionId?: true
    accountId?: true
    description?: true
    debit?: true
    credit?: true
    createdAt?: true
  }

  export type AccountEntryCountAggregateInputType = {
    id?: true
    transactionId?: true
    accountId?: true
    description?: true
    debit?: true
    credit?: true
    createdAt?: true
    _all?: true
  }

  export type AccountEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountEntry to aggregate.
     */
    where?: AccountEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountEntries to fetch.
     */
    orderBy?: AccountEntryOrderByWithRelationInput | AccountEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountEntries
    **/
    _count?: true | AccountEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountEntryMaxAggregateInputType
  }

  export type GetAccountEntryAggregateType<T extends AccountEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountEntry[P]>
      : GetScalarType<T[P], AggregateAccountEntry[P]>
  }




  export type AccountEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountEntryWhereInput
    orderBy?: AccountEntryOrderByWithAggregationInput | AccountEntryOrderByWithAggregationInput[]
    by: AccountEntryScalarFieldEnum[] | AccountEntryScalarFieldEnum
    having?: AccountEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountEntryCountAggregateInputType | true
    _avg?: AccountEntryAvgAggregateInputType
    _sum?: AccountEntrySumAggregateInputType
    _min?: AccountEntryMinAggregateInputType
    _max?: AccountEntryMaxAggregateInputType
  }

  export type AccountEntryGroupByOutputType = {
    id: number
    transactionId: number
    accountId: number
    description: string | null
    debit: number
    credit: number
    createdAt: Date
    _count: AccountEntryCountAggregateOutputType | null
    _avg: AccountEntryAvgAggregateOutputType | null
    _sum: AccountEntrySumAggregateOutputType | null
    _min: AccountEntryMinAggregateOutputType | null
    _max: AccountEntryMaxAggregateOutputType | null
  }

  type GetAccountEntryGroupByPayload<T extends AccountEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountEntryGroupByOutputType[P]>
            : GetScalarType<T[P], AccountEntryGroupByOutputType[P]>
        }
      >
    >


  export type AccountEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    accountId?: boolean
    description?: boolean
    debit?: boolean
    credit?: boolean
    createdAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountEntry"]>

  export type AccountEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    accountId?: boolean
    description?: boolean
    debit?: boolean
    credit?: boolean
    createdAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountEntry"]>

  export type AccountEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    accountId?: boolean
    description?: boolean
    debit?: boolean
    credit?: boolean
    createdAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountEntry"]>

  export type AccountEntrySelectScalar = {
    id?: boolean
    transactionId?: boolean
    accountId?: boolean
    description?: boolean
    debit?: boolean
    credit?: boolean
    createdAt?: boolean
  }

  export type AccountEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "accountId" | "description" | "debit" | "credit" | "createdAt", ExtArgs["result"]["accountEntry"]>
  export type AccountEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type AccountEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type AccountEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }

  export type $AccountEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountEntry"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      transaction: Prisma.$TransactionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      transactionId: number
      accountId: number
      description: string | null
      debit: number
      credit: number
      createdAt: Date
    }, ExtArgs["result"]["accountEntry"]>
    composites: {}
  }

  type AccountEntryGetPayload<S extends boolean | null | undefined | AccountEntryDefaultArgs> = $Result.GetResult<Prisma.$AccountEntryPayload, S>

  type AccountEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountEntryCountAggregateInputType | true
    }

  export interface AccountEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountEntry'], meta: { name: 'AccountEntry' } }
    /**
     * Find zero or one AccountEntry that matches the filter.
     * @param {AccountEntryFindUniqueArgs} args - Arguments to find a AccountEntry
     * @example
     * // Get one AccountEntry
     * const accountEntry = await prisma.accountEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountEntryFindUniqueArgs>(args: SelectSubset<T, AccountEntryFindUniqueArgs<ExtArgs>>): Prisma__AccountEntryClient<$Result.GetResult<Prisma.$AccountEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccountEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountEntryFindUniqueOrThrowArgs} args - Arguments to find a AccountEntry
     * @example
     * // Get one AccountEntry
     * const accountEntry = await prisma.accountEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountEntryClient<$Result.GetResult<Prisma.$AccountEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountEntryFindFirstArgs} args - Arguments to find a AccountEntry
     * @example
     * // Get one AccountEntry
     * const accountEntry = await prisma.accountEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountEntryFindFirstArgs>(args?: SelectSubset<T, AccountEntryFindFirstArgs<ExtArgs>>): Prisma__AccountEntryClient<$Result.GetResult<Prisma.$AccountEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountEntryFindFirstOrThrowArgs} args - Arguments to find a AccountEntry
     * @example
     * // Get one AccountEntry
     * const accountEntry = await prisma.accountEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountEntryClient<$Result.GetResult<Prisma.$AccountEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccountEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountEntries
     * const accountEntries = await prisma.accountEntry.findMany()
     * 
     * // Get first 10 AccountEntries
     * const accountEntries = await prisma.accountEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountEntryWithIdOnly = await prisma.accountEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountEntryFindManyArgs>(args?: SelectSubset<T, AccountEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccountEntry.
     * @param {AccountEntryCreateArgs} args - Arguments to create a AccountEntry.
     * @example
     * // Create one AccountEntry
     * const AccountEntry = await prisma.accountEntry.create({
     *   data: {
     *     // ... data to create a AccountEntry
     *   }
     * })
     * 
     */
    create<T extends AccountEntryCreateArgs>(args: SelectSubset<T, AccountEntryCreateArgs<ExtArgs>>): Prisma__AccountEntryClient<$Result.GetResult<Prisma.$AccountEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccountEntries.
     * @param {AccountEntryCreateManyArgs} args - Arguments to create many AccountEntries.
     * @example
     * // Create many AccountEntries
     * const accountEntry = await prisma.accountEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountEntryCreateManyArgs>(args?: SelectSubset<T, AccountEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccountEntries and returns the data saved in the database.
     * @param {AccountEntryCreateManyAndReturnArgs} args - Arguments to create many AccountEntries.
     * @example
     * // Create many AccountEntries
     * const accountEntry = await prisma.accountEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccountEntries and only return the `id`
     * const accountEntryWithIdOnly = await prisma.accountEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AccountEntry.
     * @param {AccountEntryDeleteArgs} args - Arguments to delete one AccountEntry.
     * @example
     * // Delete one AccountEntry
     * const AccountEntry = await prisma.accountEntry.delete({
     *   where: {
     *     // ... filter to delete one AccountEntry
     *   }
     * })
     * 
     */
    delete<T extends AccountEntryDeleteArgs>(args: SelectSubset<T, AccountEntryDeleteArgs<ExtArgs>>): Prisma__AccountEntryClient<$Result.GetResult<Prisma.$AccountEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccountEntry.
     * @param {AccountEntryUpdateArgs} args - Arguments to update one AccountEntry.
     * @example
     * // Update one AccountEntry
     * const accountEntry = await prisma.accountEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountEntryUpdateArgs>(args: SelectSubset<T, AccountEntryUpdateArgs<ExtArgs>>): Prisma__AccountEntryClient<$Result.GetResult<Prisma.$AccountEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccountEntries.
     * @param {AccountEntryDeleteManyArgs} args - Arguments to filter AccountEntries to delete.
     * @example
     * // Delete a few AccountEntries
     * const { count } = await prisma.accountEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountEntryDeleteManyArgs>(args?: SelectSubset<T, AccountEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountEntries
     * const accountEntry = await prisma.accountEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountEntryUpdateManyArgs>(args: SelectSubset<T, AccountEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountEntries and returns the data updated in the database.
     * @param {AccountEntryUpdateManyAndReturnArgs} args - Arguments to update many AccountEntries.
     * @example
     * // Update many AccountEntries
     * const accountEntry = await prisma.accountEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AccountEntries and only return the `id`
     * const accountEntryWithIdOnly = await prisma.accountEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AccountEntry.
     * @param {AccountEntryUpsertArgs} args - Arguments to update or create a AccountEntry.
     * @example
     * // Update or create a AccountEntry
     * const accountEntry = await prisma.accountEntry.upsert({
     *   create: {
     *     // ... data to create a AccountEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountEntry we want to update
     *   }
     * })
     */
    upsert<T extends AccountEntryUpsertArgs>(args: SelectSubset<T, AccountEntryUpsertArgs<ExtArgs>>): Prisma__AccountEntryClient<$Result.GetResult<Prisma.$AccountEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccountEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountEntryCountArgs} args - Arguments to filter AccountEntries to count.
     * @example
     * // Count the number of AccountEntries
     * const count = await prisma.accountEntry.count({
     *   where: {
     *     // ... the filter for the AccountEntries we want to count
     *   }
     * })
    **/
    count<T extends AccountEntryCountArgs>(
      args?: Subset<T, AccountEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountEntryAggregateArgs>(args: Subset<T, AccountEntryAggregateArgs>): Prisma.PrismaPromise<GetAccountEntryAggregateType<T>>

    /**
     * Group by AccountEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountEntryGroupByArgs['orderBy'] }
        : { orderBy?: AccountEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountEntry model
   */
  readonly fields: AccountEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccountEntry model
   */
  interface AccountEntryFieldRefs {
    readonly id: FieldRef<"AccountEntry", 'Int'>
    readonly transactionId: FieldRef<"AccountEntry", 'Int'>
    readonly accountId: FieldRef<"AccountEntry", 'Int'>
    readonly description: FieldRef<"AccountEntry", 'String'>
    readonly debit: FieldRef<"AccountEntry", 'Float'>
    readonly credit: FieldRef<"AccountEntry", 'Float'>
    readonly createdAt: FieldRef<"AccountEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccountEntry findUnique
   */
  export type AccountEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountEntry
     */
    select?: AccountEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountEntry
     */
    omit?: AccountEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountEntryInclude<ExtArgs> | null
    /**
     * Filter, which AccountEntry to fetch.
     */
    where: AccountEntryWhereUniqueInput
  }

  /**
   * AccountEntry findUniqueOrThrow
   */
  export type AccountEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountEntry
     */
    select?: AccountEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountEntry
     */
    omit?: AccountEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountEntryInclude<ExtArgs> | null
    /**
     * Filter, which AccountEntry to fetch.
     */
    where: AccountEntryWhereUniqueInput
  }

  /**
   * AccountEntry findFirst
   */
  export type AccountEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountEntry
     */
    select?: AccountEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountEntry
     */
    omit?: AccountEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountEntryInclude<ExtArgs> | null
    /**
     * Filter, which AccountEntry to fetch.
     */
    where?: AccountEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountEntries to fetch.
     */
    orderBy?: AccountEntryOrderByWithRelationInput | AccountEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountEntries.
     */
    cursor?: AccountEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountEntries.
     */
    distinct?: AccountEntryScalarFieldEnum | AccountEntryScalarFieldEnum[]
  }

  /**
   * AccountEntry findFirstOrThrow
   */
  export type AccountEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountEntry
     */
    select?: AccountEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountEntry
     */
    omit?: AccountEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountEntryInclude<ExtArgs> | null
    /**
     * Filter, which AccountEntry to fetch.
     */
    where?: AccountEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountEntries to fetch.
     */
    orderBy?: AccountEntryOrderByWithRelationInput | AccountEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountEntries.
     */
    cursor?: AccountEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountEntries.
     */
    distinct?: AccountEntryScalarFieldEnum | AccountEntryScalarFieldEnum[]
  }

  /**
   * AccountEntry findMany
   */
  export type AccountEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountEntry
     */
    select?: AccountEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountEntry
     */
    omit?: AccountEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountEntryInclude<ExtArgs> | null
    /**
     * Filter, which AccountEntries to fetch.
     */
    where?: AccountEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountEntries to fetch.
     */
    orderBy?: AccountEntryOrderByWithRelationInput | AccountEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountEntries.
     */
    cursor?: AccountEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountEntries.
     */
    skip?: number
    distinct?: AccountEntryScalarFieldEnum | AccountEntryScalarFieldEnum[]
  }

  /**
   * AccountEntry create
   */
  export type AccountEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountEntry
     */
    select?: AccountEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountEntry
     */
    omit?: AccountEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountEntry.
     */
    data: XOR<AccountEntryCreateInput, AccountEntryUncheckedCreateInput>
  }

  /**
   * AccountEntry createMany
   */
  export type AccountEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountEntries.
     */
    data: AccountEntryCreateManyInput | AccountEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccountEntry createManyAndReturn
   */
  export type AccountEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountEntry
     */
    select?: AccountEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccountEntry
     */
    omit?: AccountEntryOmit<ExtArgs> | null
    /**
     * The data used to create many AccountEntries.
     */
    data: AccountEntryCreateManyInput | AccountEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccountEntry update
   */
  export type AccountEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountEntry
     */
    select?: AccountEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountEntry
     */
    omit?: AccountEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountEntry.
     */
    data: XOR<AccountEntryUpdateInput, AccountEntryUncheckedUpdateInput>
    /**
     * Choose, which AccountEntry to update.
     */
    where: AccountEntryWhereUniqueInput
  }

  /**
   * AccountEntry updateMany
   */
  export type AccountEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountEntries.
     */
    data: XOR<AccountEntryUpdateManyMutationInput, AccountEntryUncheckedUpdateManyInput>
    /**
     * Filter which AccountEntries to update
     */
    where?: AccountEntryWhereInput
    /**
     * Limit how many AccountEntries to update.
     */
    limit?: number
  }

  /**
   * AccountEntry updateManyAndReturn
   */
  export type AccountEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountEntry
     */
    select?: AccountEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccountEntry
     */
    omit?: AccountEntryOmit<ExtArgs> | null
    /**
     * The data used to update AccountEntries.
     */
    data: XOR<AccountEntryUpdateManyMutationInput, AccountEntryUncheckedUpdateManyInput>
    /**
     * Filter which AccountEntries to update
     */
    where?: AccountEntryWhereInput
    /**
     * Limit how many AccountEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccountEntry upsert
   */
  export type AccountEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountEntry
     */
    select?: AccountEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountEntry
     */
    omit?: AccountEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountEntry to update in case it exists.
     */
    where: AccountEntryWhereUniqueInput
    /**
     * In case the AccountEntry found by the `where` argument doesn't exist, create a new AccountEntry with this data.
     */
    create: XOR<AccountEntryCreateInput, AccountEntryUncheckedCreateInput>
    /**
     * In case the AccountEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountEntryUpdateInput, AccountEntryUncheckedUpdateInput>
  }

  /**
   * AccountEntry delete
   */
  export type AccountEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountEntry
     */
    select?: AccountEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountEntry
     */
    omit?: AccountEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountEntryInclude<ExtArgs> | null
    /**
     * Filter which AccountEntry to delete.
     */
    where: AccountEntryWhereUniqueInput
  }

  /**
   * AccountEntry deleteMany
   */
  export type AccountEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountEntries to delete
     */
    where?: AccountEntryWhereInput
    /**
     * Limit how many AccountEntries to delete.
     */
    limit?: number
  }

  /**
   * AccountEntry without action
   */
  export type AccountEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountEntry
     */
    select?: AccountEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountEntry
     */
    omit?: AccountEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountEntryInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    customerId: number | null
    vendorId: number | null
    transactionId: number | null
    companyId: number | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    amount: number | null
    customerId: number | null
    vendorId: number | null
    transactionId: number | null
    companyId: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    receiptNumber: string | null
    date: Date | null
    amount: number | null
    mode: $Enums.PaymentMode | null
    reference: string | null
    customerId: number | null
    vendorId: number | null
    transactionId: number | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    division: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    receiptNumber: string | null
    date: Date | null
    amount: number | null
    mode: $Enums.PaymentMode | null
    reference: string | null
    customerId: number | null
    vendorId: number | null
    transactionId: number | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    division: string | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    receiptNumber: number
    date: number
    amount: number
    mode: number
    reference: number
    customerId: number
    vendorId: number
    transactionId: number
    companyId: number
    createdAt: number
    updatedAt: number
    division: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    amount?: true
    customerId?: true
    vendorId?: true
    transactionId?: true
    companyId?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    amount?: true
    customerId?: true
    vendorId?: true
    transactionId?: true
    companyId?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    receiptNumber?: true
    date?: true
    amount?: true
    mode?: true
    reference?: true
    customerId?: true
    vendorId?: true
    transactionId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    division?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    receiptNumber?: true
    date?: true
    amount?: true
    mode?: true
    reference?: true
    customerId?: true
    vendorId?: true
    transactionId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    division?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    receiptNumber?: true
    date?: true
    amount?: true
    mode?: true
    reference?: true
    customerId?: true
    vendorId?: true
    transactionId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    division?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    receiptNumber: string
    date: Date
    amount: number
    mode: $Enums.PaymentMode
    reference: string | null
    customerId: number | null
    vendorId: number | null
    transactionId: number
    companyId: number
    createdAt: Date
    updatedAt: Date
    division: string | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptNumber?: boolean
    date?: boolean
    amount?: boolean
    mode?: boolean
    reference?: boolean
    customerId?: boolean
    vendorId?: boolean
    transactionId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    division?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | Payment$customerArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    vendor?: boolean | Payment$vendorArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptNumber?: boolean
    date?: boolean
    amount?: boolean
    mode?: boolean
    reference?: boolean
    customerId?: boolean
    vendorId?: boolean
    transactionId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    division?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | Payment$customerArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    vendor?: boolean | Payment$vendorArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptNumber?: boolean
    date?: boolean
    amount?: boolean
    mode?: boolean
    reference?: boolean
    customerId?: boolean
    vendorId?: boolean
    transactionId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    division?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | Payment$customerArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    vendor?: boolean | Payment$vendorArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    receiptNumber?: boolean
    date?: boolean
    amount?: boolean
    mode?: boolean
    reference?: boolean
    customerId?: boolean
    vendorId?: boolean
    transactionId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    division?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "receiptNumber" | "date" | "amount" | "mode" | "reference" | "customerId" | "vendorId" | "transactionId" | "companyId" | "createdAt" | "updatedAt" | "division", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | Payment$customerArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    vendor?: boolean | Payment$vendorArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | Payment$customerArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    vendor?: boolean | Payment$vendorArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | Payment$customerArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    vendor?: boolean | Payment$vendorArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      transaction: Prisma.$TransactionPayload<ExtArgs>
      vendor: Prisma.$VendorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      receiptNumber: string
      date: Date
      amount: number
      mode: $Enums.PaymentMode
      reference: string | null
      customerId: number | null
      vendorId: number | null
      transactionId: number
      companyId: number
      createdAt: Date
      updatedAt: Date
      division: string | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends Payment$customerArgs<ExtArgs> = {}>(args?: Subset<T, Payment$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vendor<T extends Payment$vendorArgs<ExtArgs> = {}>(args?: Subset<T, Payment$vendorArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'Int'>
    readonly receiptNumber: FieldRef<"Payment", 'String'>
    readonly date: FieldRef<"Payment", 'DateTime'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly mode: FieldRef<"Payment", 'PaymentMode'>
    readonly reference: FieldRef<"Payment", 'String'>
    readonly customerId: FieldRef<"Payment", 'Int'>
    readonly vendorId: FieldRef<"Payment", 'Int'>
    readonly transactionId: FieldRef<"Payment", 'Int'>
    readonly companyId: FieldRef<"Payment", 'Int'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
    readonly division: FieldRef<"Payment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.customer
   */
  export type Payment$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Payment.vendor
   */
  export type Payment$vendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    entityId: number | null
    companyId: number | null
  }

  export type AuditLogSumAggregateOutputType = {
    id: number | null
    userId: number | null
    entityId: number | null
    companyId: number | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: number | null
    userId: number | null
    action: string | null
    module: string | null
    entityId: number | null
    ipAddress: string | null
    createdAt: Date | null
    companyId: number | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    action: string | null
    module: string | null
    entityId: number | null
    ipAddress: string | null
    createdAt: Date | null
    companyId: number | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    module: number
    entityId: number
    payload: number
    ipAddress: number
    createdAt: number
    companyId: number
    _all: number
  }


  export type AuditLogAvgAggregateInputType = {
    id?: true
    userId?: true
    entityId?: true
    companyId?: true
  }

  export type AuditLogSumAggregateInputType = {
    id?: true
    userId?: true
    entityId?: true
    companyId?: true
  }

  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    module?: true
    entityId?: true
    ipAddress?: true
    createdAt?: true
    companyId?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    module?: true
    entityId?: true
    ipAddress?: true
    createdAt?: true
    companyId?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    module?: true
    entityId?: true
    payload?: true
    ipAddress?: true
    createdAt?: true
    companyId?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _avg?: AuditLogAvgAggregateInputType
    _sum?: AuditLogSumAggregateInputType
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: number
    userId: number
    action: string
    module: string
    entityId: number | null
    payload: JsonValue | null
    ipAddress: string | null
    createdAt: Date
    companyId: number
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    module?: boolean
    entityId?: boolean
    payload?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    module?: boolean
    entityId?: boolean
    payload?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    module?: boolean
    entityId?: boolean
    payload?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    module?: boolean
    entityId?: boolean
    payload?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    companyId?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "module" | "entityId" | "payload" | "ipAddress" | "createdAt" | "companyId", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      action: string
      module: string
      entityId: number | null
      payload: Prisma.JsonValue | null
      ipAddress: string | null
      createdAt: Date
      companyId: number
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'Int'>
    readonly userId: FieldRef<"AuditLog", 'Int'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly module: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'Int'>
    readonly payload: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
    readonly companyId: FieldRef<"AuditLog", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model FinancialPeriod
   */

  export type AggregateFinancialPeriod = {
    _count: FinancialPeriodCountAggregateOutputType | null
    _avg: FinancialPeriodAvgAggregateOutputType | null
    _sum: FinancialPeriodSumAggregateOutputType | null
    _min: FinancialPeriodMinAggregateOutputType | null
    _max: FinancialPeriodMaxAggregateOutputType | null
  }

  export type FinancialPeriodAvgAggregateOutputType = {
    id: number | null
    month: number | null
    year: number | null
    closedById: number | null
    companyId: number | null
  }

  export type FinancialPeriodSumAggregateOutputType = {
    id: number | null
    month: number | null
    year: number | null
    closedById: number | null
    companyId: number | null
  }

  export type FinancialPeriodMinAggregateOutputType = {
    id: number | null
    month: number | null
    year: number | null
    isClosed: boolean | null
    closedById: number | null
    closedAt: Date | null
    companyId: number | null
  }

  export type FinancialPeriodMaxAggregateOutputType = {
    id: number | null
    month: number | null
    year: number | null
    isClosed: boolean | null
    closedById: number | null
    closedAt: Date | null
    companyId: number | null
  }

  export type FinancialPeriodCountAggregateOutputType = {
    id: number
    month: number
    year: number
    isClosed: number
    closedById: number
    closedAt: number
    companyId: number
    _all: number
  }


  export type FinancialPeriodAvgAggregateInputType = {
    id?: true
    month?: true
    year?: true
    closedById?: true
    companyId?: true
  }

  export type FinancialPeriodSumAggregateInputType = {
    id?: true
    month?: true
    year?: true
    closedById?: true
    companyId?: true
  }

  export type FinancialPeriodMinAggregateInputType = {
    id?: true
    month?: true
    year?: true
    isClosed?: true
    closedById?: true
    closedAt?: true
    companyId?: true
  }

  export type FinancialPeriodMaxAggregateInputType = {
    id?: true
    month?: true
    year?: true
    isClosed?: true
    closedById?: true
    closedAt?: true
    companyId?: true
  }

  export type FinancialPeriodCountAggregateInputType = {
    id?: true
    month?: true
    year?: true
    isClosed?: true
    closedById?: true
    closedAt?: true
    companyId?: true
    _all?: true
  }

  export type FinancialPeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialPeriod to aggregate.
     */
    where?: FinancialPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialPeriods to fetch.
     */
    orderBy?: FinancialPeriodOrderByWithRelationInput | FinancialPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinancialPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinancialPeriods
    **/
    _count?: true | FinancialPeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinancialPeriodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinancialPeriodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinancialPeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinancialPeriodMaxAggregateInputType
  }

  export type GetFinancialPeriodAggregateType<T extends FinancialPeriodAggregateArgs> = {
        [P in keyof T & keyof AggregateFinancialPeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinancialPeriod[P]>
      : GetScalarType<T[P], AggregateFinancialPeriod[P]>
  }




  export type FinancialPeriodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialPeriodWhereInput
    orderBy?: FinancialPeriodOrderByWithAggregationInput | FinancialPeriodOrderByWithAggregationInput[]
    by: FinancialPeriodScalarFieldEnum[] | FinancialPeriodScalarFieldEnum
    having?: FinancialPeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinancialPeriodCountAggregateInputType | true
    _avg?: FinancialPeriodAvgAggregateInputType
    _sum?: FinancialPeriodSumAggregateInputType
    _min?: FinancialPeriodMinAggregateInputType
    _max?: FinancialPeriodMaxAggregateInputType
  }

  export type FinancialPeriodGroupByOutputType = {
    id: number
    month: number
    year: number
    isClosed: boolean
    closedById: number | null
    closedAt: Date | null
    companyId: number
    _count: FinancialPeriodCountAggregateOutputType | null
    _avg: FinancialPeriodAvgAggregateOutputType | null
    _sum: FinancialPeriodSumAggregateOutputType | null
    _min: FinancialPeriodMinAggregateOutputType | null
    _max: FinancialPeriodMaxAggregateOutputType | null
  }

  type GetFinancialPeriodGroupByPayload<T extends FinancialPeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinancialPeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinancialPeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinancialPeriodGroupByOutputType[P]>
            : GetScalarType<T[P], FinancialPeriodGroupByOutputType[P]>
        }
      >
    >


  export type FinancialPeriodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    year?: boolean
    isClosed?: boolean
    closedById?: boolean
    closedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialPeriod"]>

  export type FinancialPeriodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    year?: boolean
    isClosed?: boolean
    closedById?: boolean
    closedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialPeriod"]>

  export type FinancialPeriodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    year?: boolean
    isClosed?: boolean
    closedById?: boolean
    closedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialPeriod"]>

  export type FinancialPeriodSelectScalar = {
    id?: boolean
    month?: boolean
    year?: boolean
    isClosed?: boolean
    closedById?: boolean
    closedAt?: boolean
    companyId?: boolean
  }

  export type FinancialPeriodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "month" | "year" | "isClosed" | "closedById" | "closedAt" | "companyId", ExtArgs["result"]["financialPeriod"]>
  export type FinancialPeriodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type FinancialPeriodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type FinancialPeriodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $FinancialPeriodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinancialPeriod"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      month: number
      year: number
      isClosed: boolean
      closedById: number | null
      closedAt: Date | null
      companyId: number
    }, ExtArgs["result"]["financialPeriod"]>
    composites: {}
  }

  type FinancialPeriodGetPayload<S extends boolean | null | undefined | FinancialPeriodDefaultArgs> = $Result.GetResult<Prisma.$FinancialPeriodPayload, S>

  type FinancialPeriodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FinancialPeriodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FinancialPeriodCountAggregateInputType | true
    }

  export interface FinancialPeriodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinancialPeriod'], meta: { name: 'FinancialPeriod' } }
    /**
     * Find zero or one FinancialPeriod that matches the filter.
     * @param {FinancialPeriodFindUniqueArgs} args - Arguments to find a FinancialPeriod
     * @example
     * // Get one FinancialPeriod
     * const financialPeriod = await prisma.financialPeriod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinancialPeriodFindUniqueArgs>(args: SelectSubset<T, FinancialPeriodFindUniqueArgs<ExtArgs>>): Prisma__FinancialPeriodClient<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FinancialPeriod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FinancialPeriodFindUniqueOrThrowArgs} args - Arguments to find a FinancialPeriod
     * @example
     * // Get one FinancialPeriod
     * const financialPeriod = await prisma.financialPeriod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinancialPeriodFindUniqueOrThrowArgs>(args: SelectSubset<T, FinancialPeriodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinancialPeriodClient<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinancialPeriod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialPeriodFindFirstArgs} args - Arguments to find a FinancialPeriod
     * @example
     * // Get one FinancialPeriod
     * const financialPeriod = await prisma.financialPeriod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinancialPeriodFindFirstArgs>(args?: SelectSubset<T, FinancialPeriodFindFirstArgs<ExtArgs>>): Prisma__FinancialPeriodClient<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinancialPeriod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialPeriodFindFirstOrThrowArgs} args - Arguments to find a FinancialPeriod
     * @example
     * // Get one FinancialPeriod
     * const financialPeriod = await prisma.financialPeriod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinancialPeriodFindFirstOrThrowArgs>(args?: SelectSubset<T, FinancialPeriodFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinancialPeriodClient<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FinancialPeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialPeriodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinancialPeriods
     * const financialPeriods = await prisma.financialPeriod.findMany()
     * 
     * // Get first 10 FinancialPeriods
     * const financialPeriods = await prisma.financialPeriod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const financialPeriodWithIdOnly = await prisma.financialPeriod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FinancialPeriodFindManyArgs>(args?: SelectSubset<T, FinancialPeriodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FinancialPeriod.
     * @param {FinancialPeriodCreateArgs} args - Arguments to create a FinancialPeriod.
     * @example
     * // Create one FinancialPeriod
     * const FinancialPeriod = await prisma.financialPeriod.create({
     *   data: {
     *     // ... data to create a FinancialPeriod
     *   }
     * })
     * 
     */
    create<T extends FinancialPeriodCreateArgs>(args: SelectSubset<T, FinancialPeriodCreateArgs<ExtArgs>>): Prisma__FinancialPeriodClient<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FinancialPeriods.
     * @param {FinancialPeriodCreateManyArgs} args - Arguments to create many FinancialPeriods.
     * @example
     * // Create many FinancialPeriods
     * const financialPeriod = await prisma.financialPeriod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinancialPeriodCreateManyArgs>(args?: SelectSubset<T, FinancialPeriodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FinancialPeriods and returns the data saved in the database.
     * @param {FinancialPeriodCreateManyAndReturnArgs} args - Arguments to create many FinancialPeriods.
     * @example
     * // Create many FinancialPeriods
     * const financialPeriod = await prisma.financialPeriod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FinancialPeriods and only return the `id`
     * const financialPeriodWithIdOnly = await prisma.financialPeriod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FinancialPeriodCreateManyAndReturnArgs>(args?: SelectSubset<T, FinancialPeriodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FinancialPeriod.
     * @param {FinancialPeriodDeleteArgs} args - Arguments to delete one FinancialPeriod.
     * @example
     * // Delete one FinancialPeriod
     * const FinancialPeriod = await prisma.financialPeriod.delete({
     *   where: {
     *     // ... filter to delete one FinancialPeriod
     *   }
     * })
     * 
     */
    delete<T extends FinancialPeriodDeleteArgs>(args: SelectSubset<T, FinancialPeriodDeleteArgs<ExtArgs>>): Prisma__FinancialPeriodClient<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FinancialPeriod.
     * @param {FinancialPeriodUpdateArgs} args - Arguments to update one FinancialPeriod.
     * @example
     * // Update one FinancialPeriod
     * const financialPeriod = await prisma.financialPeriod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinancialPeriodUpdateArgs>(args: SelectSubset<T, FinancialPeriodUpdateArgs<ExtArgs>>): Prisma__FinancialPeriodClient<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FinancialPeriods.
     * @param {FinancialPeriodDeleteManyArgs} args - Arguments to filter FinancialPeriods to delete.
     * @example
     * // Delete a few FinancialPeriods
     * const { count } = await prisma.financialPeriod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinancialPeriodDeleteManyArgs>(args?: SelectSubset<T, FinancialPeriodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialPeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinancialPeriods
     * const financialPeriod = await prisma.financialPeriod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinancialPeriodUpdateManyArgs>(args: SelectSubset<T, FinancialPeriodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialPeriods and returns the data updated in the database.
     * @param {FinancialPeriodUpdateManyAndReturnArgs} args - Arguments to update many FinancialPeriods.
     * @example
     * // Update many FinancialPeriods
     * const financialPeriod = await prisma.financialPeriod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FinancialPeriods and only return the `id`
     * const financialPeriodWithIdOnly = await prisma.financialPeriod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FinancialPeriodUpdateManyAndReturnArgs>(args: SelectSubset<T, FinancialPeriodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FinancialPeriod.
     * @param {FinancialPeriodUpsertArgs} args - Arguments to update or create a FinancialPeriod.
     * @example
     * // Update or create a FinancialPeriod
     * const financialPeriod = await prisma.financialPeriod.upsert({
     *   create: {
     *     // ... data to create a FinancialPeriod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinancialPeriod we want to update
     *   }
     * })
     */
    upsert<T extends FinancialPeriodUpsertArgs>(args: SelectSubset<T, FinancialPeriodUpsertArgs<ExtArgs>>): Prisma__FinancialPeriodClient<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FinancialPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialPeriodCountArgs} args - Arguments to filter FinancialPeriods to count.
     * @example
     * // Count the number of FinancialPeriods
     * const count = await prisma.financialPeriod.count({
     *   where: {
     *     // ... the filter for the FinancialPeriods we want to count
     *   }
     * })
    **/
    count<T extends FinancialPeriodCountArgs>(
      args?: Subset<T, FinancialPeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinancialPeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinancialPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialPeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinancialPeriodAggregateArgs>(args: Subset<T, FinancialPeriodAggregateArgs>): Prisma.PrismaPromise<GetFinancialPeriodAggregateType<T>>

    /**
     * Group by FinancialPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialPeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinancialPeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinancialPeriodGroupByArgs['orderBy'] }
        : { orderBy?: FinancialPeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinancialPeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinancialPeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinancialPeriod model
   */
  readonly fields: FinancialPeriodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinancialPeriod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinancialPeriodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinancialPeriod model
   */
  interface FinancialPeriodFieldRefs {
    readonly id: FieldRef<"FinancialPeriod", 'Int'>
    readonly month: FieldRef<"FinancialPeriod", 'Int'>
    readonly year: FieldRef<"FinancialPeriod", 'Int'>
    readonly isClosed: FieldRef<"FinancialPeriod", 'Boolean'>
    readonly closedById: FieldRef<"FinancialPeriod", 'Int'>
    readonly closedAt: FieldRef<"FinancialPeriod", 'DateTime'>
    readonly companyId: FieldRef<"FinancialPeriod", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FinancialPeriod findUnique
   */
  export type FinancialPeriodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialPeriod
     */
    omit?: FinancialPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodInclude<ExtArgs> | null
    /**
     * Filter, which FinancialPeriod to fetch.
     */
    where: FinancialPeriodWhereUniqueInput
  }

  /**
   * FinancialPeriod findUniqueOrThrow
   */
  export type FinancialPeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialPeriod
     */
    omit?: FinancialPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodInclude<ExtArgs> | null
    /**
     * Filter, which FinancialPeriod to fetch.
     */
    where: FinancialPeriodWhereUniqueInput
  }

  /**
   * FinancialPeriod findFirst
   */
  export type FinancialPeriodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialPeriod
     */
    omit?: FinancialPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodInclude<ExtArgs> | null
    /**
     * Filter, which FinancialPeriod to fetch.
     */
    where?: FinancialPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialPeriods to fetch.
     */
    orderBy?: FinancialPeriodOrderByWithRelationInput | FinancialPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialPeriods.
     */
    cursor?: FinancialPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialPeriods.
     */
    distinct?: FinancialPeriodScalarFieldEnum | FinancialPeriodScalarFieldEnum[]
  }

  /**
   * FinancialPeriod findFirstOrThrow
   */
  export type FinancialPeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialPeriod
     */
    omit?: FinancialPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodInclude<ExtArgs> | null
    /**
     * Filter, which FinancialPeriod to fetch.
     */
    where?: FinancialPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialPeriods to fetch.
     */
    orderBy?: FinancialPeriodOrderByWithRelationInput | FinancialPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialPeriods.
     */
    cursor?: FinancialPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialPeriods.
     */
    distinct?: FinancialPeriodScalarFieldEnum | FinancialPeriodScalarFieldEnum[]
  }

  /**
   * FinancialPeriod findMany
   */
  export type FinancialPeriodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialPeriod
     */
    omit?: FinancialPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodInclude<ExtArgs> | null
    /**
     * Filter, which FinancialPeriods to fetch.
     */
    where?: FinancialPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialPeriods to fetch.
     */
    orderBy?: FinancialPeriodOrderByWithRelationInput | FinancialPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinancialPeriods.
     */
    cursor?: FinancialPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialPeriods.
     */
    skip?: number
    distinct?: FinancialPeriodScalarFieldEnum | FinancialPeriodScalarFieldEnum[]
  }

  /**
   * FinancialPeriod create
   */
  export type FinancialPeriodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialPeriod
     */
    omit?: FinancialPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodInclude<ExtArgs> | null
    /**
     * The data needed to create a FinancialPeriod.
     */
    data: XOR<FinancialPeriodCreateInput, FinancialPeriodUncheckedCreateInput>
  }

  /**
   * FinancialPeriod createMany
   */
  export type FinancialPeriodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinancialPeriods.
     */
    data: FinancialPeriodCreateManyInput | FinancialPeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FinancialPeriod createManyAndReturn
   */
  export type FinancialPeriodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialPeriod
     */
    omit?: FinancialPeriodOmit<ExtArgs> | null
    /**
     * The data used to create many FinancialPeriods.
     */
    data: FinancialPeriodCreateManyInput | FinancialPeriodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinancialPeriod update
   */
  export type FinancialPeriodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialPeriod
     */
    omit?: FinancialPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodInclude<ExtArgs> | null
    /**
     * The data needed to update a FinancialPeriod.
     */
    data: XOR<FinancialPeriodUpdateInput, FinancialPeriodUncheckedUpdateInput>
    /**
     * Choose, which FinancialPeriod to update.
     */
    where: FinancialPeriodWhereUniqueInput
  }

  /**
   * FinancialPeriod updateMany
   */
  export type FinancialPeriodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinancialPeriods.
     */
    data: XOR<FinancialPeriodUpdateManyMutationInput, FinancialPeriodUncheckedUpdateManyInput>
    /**
     * Filter which FinancialPeriods to update
     */
    where?: FinancialPeriodWhereInput
    /**
     * Limit how many FinancialPeriods to update.
     */
    limit?: number
  }

  /**
   * FinancialPeriod updateManyAndReturn
   */
  export type FinancialPeriodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialPeriod
     */
    omit?: FinancialPeriodOmit<ExtArgs> | null
    /**
     * The data used to update FinancialPeriods.
     */
    data: XOR<FinancialPeriodUpdateManyMutationInput, FinancialPeriodUncheckedUpdateManyInput>
    /**
     * Filter which FinancialPeriods to update
     */
    where?: FinancialPeriodWhereInput
    /**
     * Limit how many FinancialPeriods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinancialPeriod upsert
   */
  export type FinancialPeriodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialPeriod
     */
    omit?: FinancialPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodInclude<ExtArgs> | null
    /**
     * The filter to search for the FinancialPeriod to update in case it exists.
     */
    where: FinancialPeriodWhereUniqueInput
    /**
     * In case the FinancialPeriod found by the `where` argument doesn't exist, create a new FinancialPeriod with this data.
     */
    create: XOR<FinancialPeriodCreateInput, FinancialPeriodUncheckedCreateInput>
    /**
     * In case the FinancialPeriod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinancialPeriodUpdateInput, FinancialPeriodUncheckedUpdateInput>
  }

  /**
   * FinancialPeriod delete
   */
  export type FinancialPeriodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialPeriod
     */
    omit?: FinancialPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodInclude<ExtArgs> | null
    /**
     * Filter which FinancialPeriod to delete.
     */
    where: FinancialPeriodWhereUniqueInput
  }

  /**
   * FinancialPeriod deleteMany
   */
  export type FinancialPeriodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialPeriods to delete
     */
    where?: FinancialPeriodWhereInput
    /**
     * Limit how many FinancialPeriods to delete.
     */
    limit?: number
  }

  /**
   * FinancialPeriod without action
   */
  export type FinancialPeriodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialPeriod
     */
    omit?: FinancialPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodInclude<ExtArgs> | null
  }


  /**
   * Model Port
   */

  export type AggregatePort = {
    _count: PortCountAggregateOutputType | null
    _avg: PortAvgAggregateOutputType | null
    _sum: PortSumAggregateOutputType | null
    _min: PortMinAggregateOutputType | null
    _max: PortMaxAggregateOutputType | null
  }

  export type PortAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type PortSumAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type PortMinAggregateOutputType = {
    id: number | null
    name: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortMaxAggregateOutputType = {
    id: number | null
    name: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortCountAggregateOutputType = {
    id: number
    name: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PortAvgAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type PortSumAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type PortMinAggregateInputType = {
    id?: true
    name?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortMaxAggregateInputType = {
    id?: true
    name?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortCountAggregateInputType = {
    id?: true
    name?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PortAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Port to aggregate.
     */
    where?: PortWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ports to fetch.
     */
    orderBy?: PortOrderByWithRelationInput | PortOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PortWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ports
    **/
    _count?: true | PortCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PortAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PortSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PortMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PortMaxAggregateInputType
  }

  export type GetPortAggregateType<T extends PortAggregateArgs> = {
        [P in keyof T & keyof AggregatePort]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePort[P]>
      : GetScalarType<T[P], AggregatePort[P]>
  }




  export type PortGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortWhereInput
    orderBy?: PortOrderByWithAggregationInput | PortOrderByWithAggregationInput[]
    by: PortScalarFieldEnum[] | PortScalarFieldEnum
    having?: PortScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortCountAggregateInputType | true
    _avg?: PortAvgAggregateInputType
    _sum?: PortSumAggregateInputType
    _min?: PortMinAggregateInputType
    _max?: PortMaxAggregateInputType
  }

  export type PortGroupByOutputType = {
    id: number
    name: string
    companyId: number
    createdAt: Date
    updatedAt: Date
    _count: PortCountAggregateOutputType | null
    _avg: PortAvgAggregateOutputType | null
    _sum: PortSumAggregateOutputType | null
    _min: PortMinAggregateOutputType | null
    _max: PortMaxAggregateOutputType | null
  }

  type GetPortGroupByPayload<T extends PortGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PortGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PortGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PortGroupByOutputType[P]>
            : GetScalarType<T[P], PortGroupByOutputType[P]>
        }
      >
    >


  export type PortSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    jobs?: boolean | Port$jobsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | PortCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["port"]>

  export type PortSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["port"]>

  export type PortSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["port"]>

  export type PortSelectScalar = {
    id?: boolean
    name?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PortOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "companyId" | "createdAt" | "updatedAt", ExtArgs["result"]["port"]>
  export type PortInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | Port$jobsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | PortCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PortIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type PortIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $PortPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Port"
    objects: {
      jobs: Prisma.$JobPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      companyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["port"]>
    composites: {}
  }

  type PortGetPayload<S extends boolean | null | undefined | PortDefaultArgs> = $Result.GetResult<Prisma.$PortPayload, S>

  type PortCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PortFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PortCountAggregateInputType | true
    }

  export interface PortDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Port'], meta: { name: 'Port' } }
    /**
     * Find zero or one Port that matches the filter.
     * @param {PortFindUniqueArgs} args - Arguments to find a Port
     * @example
     * // Get one Port
     * const port = await prisma.port.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PortFindUniqueArgs>(args: SelectSubset<T, PortFindUniqueArgs<ExtArgs>>): Prisma__PortClient<$Result.GetResult<Prisma.$PortPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Port that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PortFindUniqueOrThrowArgs} args - Arguments to find a Port
     * @example
     * // Get one Port
     * const port = await prisma.port.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PortFindUniqueOrThrowArgs>(args: SelectSubset<T, PortFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PortClient<$Result.GetResult<Prisma.$PortPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Port that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortFindFirstArgs} args - Arguments to find a Port
     * @example
     * // Get one Port
     * const port = await prisma.port.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PortFindFirstArgs>(args?: SelectSubset<T, PortFindFirstArgs<ExtArgs>>): Prisma__PortClient<$Result.GetResult<Prisma.$PortPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Port that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortFindFirstOrThrowArgs} args - Arguments to find a Port
     * @example
     * // Get one Port
     * const port = await prisma.port.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PortFindFirstOrThrowArgs>(args?: SelectSubset<T, PortFindFirstOrThrowArgs<ExtArgs>>): Prisma__PortClient<$Result.GetResult<Prisma.$PortPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ports
     * const ports = await prisma.port.findMany()
     * 
     * // Get first 10 Ports
     * const ports = await prisma.port.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const portWithIdOnly = await prisma.port.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PortFindManyArgs>(args?: SelectSubset<T, PortFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Port.
     * @param {PortCreateArgs} args - Arguments to create a Port.
     * @example
     * // Create one Port
     * const Port = await prisma.port.create({
     *   data: {
     *     // ... data to create a Port
     *   }
     * })
     * 
     */
    create<T extends PortCreateArgs>(args: SelectSubset<T, PortCreateArgs<ExtArgs>>): Prisma__PortClient<$Result.GetResult<Prisma.$PortPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ports.
     * @param {PortCreateManyArgs} args - Arguments to create many Ports.
     * @example
     * // Create many Ports
     * const port = await prisma.port.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PortCreateManyArgs>(args?: SelectSubset<T, PortCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ports and returns the data saved in the database.
     * @param {PortCreateManyAndReturnArgs} args - Arguments to create many Ports.
     * @example
     * // Create many Ports
     * const port = await prisma.port.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ports and only return the `id`
     * const portWithIdOnly = await prisma.port.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PortCreateManyAndReturnArgs>(args?: SelectSubset<T, PortCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Port.
     * @param {PortDeleteArgs} args - Arguments to delete one Port.
     * @example
     * // Delete one Port
     * const Port = await prisma.port.delete({
     *   where: {
     *     // ... filter to delete one Port
     *   }
     * })
     * 
     */
    delete<T extends PortDeleteArgs>(args: SelectSubset<T, PortDeleteArgs<ExtArgs>>): Prisma__PortClient<$Result.GetResult<Prisma.$PortPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Port.
     * @param {PortUpdateArgs} args - Arguments to update one Port.
     * @example
     * // Update one Port
     * const port = await prisma.port.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PortUpdateArgs>(args: SelectSubset<T, PortUpdateArgs<ExtArgs>>): Prisma__PortClient<$Result.GetResult<Prisma.$PortPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ports.
     * @param {PortDeleteManyArgs} args - Arguments to filter Ports to delete.
     * @example
     * // Delete a few Ports
     * const { count } = await prisma.port.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PortDeleteManyArgs>(args?: SelectSubset<T, PortDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ports
     * const port = await prisma.port.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PortUpdateManyArgs>(args: SelectSubset<T, PortUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ports and returns the data updated in the database.
     * @param {PortUpdateManyAndReturnArgs} args - Arguments to update many Ports.
     * @example
     * // Update many Ports
     * const port = await prisma.port.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ports and only return the `id`
     * const portWithIdOnly = await prisma.port.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PortUpdateManyAndReturnArgs>(args: SelectSubset<T, PortUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Port.
     * @param {PortUpsertArgs} args - Arguments to update or create a Port.
     * @example
     * // Update or create a Port
     * const port = await prisma.port.upsert({
     *   create: {
     *     // ... data to create a Port
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Port we want to update
     *   }
     * })
     */
    upsert<T extends PortUpsertArgs>(args: SelectSubset<T, PortUpsertArgs<ExtArgs>>): Prisma__PortClient<$Result.GetResult<Prisma.$PortPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortCountArgs} args - Arguments to filter Ports to count.
     * @example
     * // Count the number of Ports
     * const count = await prisma.port.count({
     *   where: {
     *     // ... the filter for the Ports we want to count
     *   }
     * })
    **/
    count<T extends PortCountArgs>(
      args?: Subset<T, PortCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Port.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PortAggregateArgs>(args: Subset<T, PortAggregateArgs>): Prisma.PrismaPromise<GetPortAggregateType<T>>

    /**
     * Group by Port.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PortGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PortGroupByArgs['orderBy'] }
        : { orderBy?: PortGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PortGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPortGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Port model
   */
  readonly fields: PortFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Port.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PortClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobs<T extends Port$jobsArgs<ExtArgs> = {}>(args?: Subset<T, Port$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Port model
   */
  interface PortFieldRefs {
    readonly id: FieldRef<"Port", 'Int'>
    readonly name: FieldRef<"Port", 'String'>
    readonly companyId: FieldRef<"Port", 'Int'>
    readonly createdAt: FieldRef<"Port", 'DateTime'>
    readonly updatedAt: FieldRef<"Port", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Port findUnique
   */
  export type PortFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Port
     */
    omit?: PortOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortInclude<ExtArgs> | null
    /**
     * Filter, which Port to fetch.
     */
    where: PortWhereUniqueInput
  }

  /**
   * Port findUniqueOrThrow
   */
  export type PortFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Port
     */
    omit?: PortOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortInclude<ExtArgs> | null
    /**
     * Filter, which Port to fetch.
     */
    where: PortWhereUniqueInput
  }

  /**
   * Port findFirst
   */
  export type PortFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Port
     */
    omit?: PortOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortInclude<ExtArgs> | null
    /**
     * Filter, which Port to fetch.
     */
    where?: PortWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ports to fetch.
     */
    orderBy?: PortOrderByWithRelationInput | PortOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ports.
     */
    cursor?: PortWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ports.
     */
    distinct?: PortScalarFieldEnum | PortScalarFieldEnum[]
  }

  /**
   * Port findFirstOrThrow
   */
  export type PortFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Port
     */
    omit?: PortOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortInclude<ExtArgs> | null
    /**
     * Filter, which Port to fetch.
     */
    where?: PortWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ports to fetch.
     */
    orderBy?: PortOrderByWithRelationInput | PortOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ports.
     */
    cursor?: PortWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ports.
     */
    distinct?: PortScalarFieldEnum | PortScalarFieldEnum[]
  }

  /**
   * Port findMany
   */
  export type PortFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Port
     */
    omit?: PortOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortInclude<ExtArgs> | null
    /**
     * Filter, which Ports to fetch.
     */
    where?: PortWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ports to fetch.
     */
    orderBy?: PortOrderByWithRelationInput | PortOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ports.
     */
    cursor?: PortWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ports.
     */
    skip?: number
    distinct?: PortScalarFieldEnum | PortScalarFieldEnum[]
  }

  /**
   * Port create
   */
  export type PortCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Port
     */
    omit?: PortOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortInclude<ExtArgs> | null
    /**
     * The data needed to create a Port.
     */
    data: XOR<PortCreateInput, PortUncheckedCreateInput>
  }

  /**
   * Port createMany
   */
  export type PortCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ports.
     */
    data: PortCreateManyInput | PortCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Port createManyAndReturn
   */
  export type PortCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Port
     */
    omit?: PortOmit<ExtArgs> | null
    /**
     * The data used to create many Ports.
     */
    data: PortCreateManyInput | PortCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Port update
   */
  export type PortUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Port
     */
    omit?: PortOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortInclude<ExtArgs> | null
    /**
     * The data needed to update a Port.
     */
    data: XOR<PortUpdateInput, PortUncheckedUpdateInput>
    /**
     * Choose, which Port to update.
     */
    where: PortWhereUniqueInput
  }

  /**
   * Port updateMany
   */
  export type PortUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ports.
     */
    data: XOR<PortUpdateManyMutationInput, PortUncheckedUpdateManyInput>
    /**
     * Filter which Ports to update
     */
    where?: PortWhereInput
    /**
     * Limit how many Ports to update.
     */
    limit?: number
  }

  /**
   * Port updateManyAndReturn
   */
  export type PortUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Port
     */
    omit?: PortOmit<ExtArgs> | null
    /**
     * The data used to update Ports.
     */
    data: XOR<PortUpdateManyMutationInput, PortUncheckedUpdateManyInput>
    /**
     * Filter which Ports to update
     */
    where?: PortWhereInput
    /**
     * Limit how many Ports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Port upsert
   */
  export type PortUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Port
     */
    omit?: PortOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortInclude<ExtArgs> | null
    /**
     * The filter to search for the Port to update in case it exists.
     */
    where: PortWhereUniqueInput
    /**
     * In case the Port found by the `where` argument doesn't exist, create a new Port with this data.
     */
    create: XOR<PortCreateInput, PortUncheckedCreateInput>
    /**
     * In case the Port was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PortUpdateInput, PortUncheckedUpdateInput>
  }

  /**
   * Port delete
   */
  export type PortDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Port
     */
    omit?: PortOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortInclude<ExtArgs> | null
    /**
     * Filter which Port to delete.
     */
    where: PortWhereUniqueInput
  }

  /**
   * Port deleteMany
   */
  export type PortDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ports to delete
     */
    where?: PortWhereInput
    /**
     * Limit how many Ports to delete.
     */
    limit?: number
  }

  /**
   * Port.jobs
   */
  export type Port$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    cursor?: JobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Port without action
   */
  export type PortDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Port
     */
    omit?: PortOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortInclude<ExtArgs> | null
  }


  /**
   * Model Voucher
   */

  export type AggregateVoucher = {
    _count: VoucherCountAggregateOutputType | null
    _avg: VoucherAvgAggregateOutputType | null
    _sum: VoucherSumAggregateOutputType | null
    _min: VoucherMinAggregateOutputType | null
    _max: VoucherMaxAggregateOutputType | null
  }

  export type VoucherAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
    postedById: number | null
  }

  export type VoucherSumAggregateOutputType = {
    id: number | null
    companyId: number | null
    postedById: number | null
  }

  export type VoucherMinAggregateOutputType = {
    id: number | null
    voucherNumber: string | null
    voucherType: $Enums.VoucherType | null
    status: $Enums.VoucherStatus | null
    date: Date | null
    postingDate: Date | null
    paymentMode: $Enums.PaymentMode | null
    instrumentNo: string | null
    instrumentDate: Date | null
    bankName: string | null
    narration: string | null
    companyId: number | null
    division: string | null
    isPosted: boolean | null
    postedAt: Date | null
    postedById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VoucherMaxAggregateOutputType = {
    id: number | null
    voucherNumber: string | null
    voucherType: $Enums.VoucherType | null
    status: $Enums.VoucherStatus | null
    date: Date | null
    postingDate: Date | null
    paymentMode: $Enums.PaymentMode | null
    instrumentNo: string | null
    instrumentDate: Date | null
    bankName: string | null
    narration: string | null
    companyId: number | null
    division: string | null
    isPosted: boolean | null
    postedAt: Date | null
    postedById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VoucherCountAggregateOutputType = {
    id: number
    voucherNumber: number
    voucherType: number
    status: number
    date: number
    postingDate: number
    paymentMode: number
    instrumentNo: number
    instrumentDate: number
    bankName: number
    narration: number
    companyId: number
    division: number
    isPosted: number
    postedAt: number
    postedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VoucherAvgAggregateInputType = {
    id?: true
    companyId?: true
    postedById?: true
  }

  export type VoucherSumAggregateInputType = {
    id?: true
    companyId?: true
    postedById?: true
  }

  export type VoucherMinAggregateInputType = {
    id?: true
    voucherNumber?: true
    voucherType?: true
    status?: true
    date?: true
    postingDate?: true
    paymentMode?: true
    instrumentNo?: true
    instrumentDate?: true
    bankName?: true
    narration?: true
    companyId?: true
    division?: true
    isPosted?: true
    postedAt?: true
    postedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VoucherMaxAggregateInputType = {
    id?: true
    voucherNumber?: true
    voucherType?: true
    status?: true
    date?: true
    postingDate?: true
    paymentMode?: true
    instrumentNo?: true
    instrumentDate?: true
    bankName?: true
    narration?: true
    companyId?: true
    division?: true
    isPosted?: true
    postedAt?: true
    postedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VoucherCountAggregateInputType = {
    id?: true
    voucherNumber?: true
    voucherType?: true
    status?: true
    date?: true
    postingDate?: true
    paymentMode?: true
    instrumentNo?: true
    instrumentDate?: true
    bankName?: true
    narration?: true
    companyId?: true
    division?: true
    isPosted?: true
    postedAt?: true
    postedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VoucherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Voucher to aggregate.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vouchers
    **/
    _count?: true | VoucherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VoucherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VoucherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoucherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoucherMaxAggregateInputType
  }

  export type GetVoucherAggregateType<T extends VoucherAggregateArgs> = {
        [P in keyof T & keyof AggregateVoucher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoucher[P]>
      : GetScalarType<T[P], AggregateVoucher[P]>
  }




  export type VoucherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherWhereInput
    orderBy?: VoucherOrderByWithAggregationInput | VoucherOrderByWithAggregationInput[]
    by: VoucherScalarFieldEnum[] | VoucherScalarFieldEnum
    having?: VoucherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoucherCountAggregateInputType | true
    _avg?: VoucherAvgAggregateInputType
    _sum?: VoucherSumAggregateInputType
    _min?: VoucherMinAggregateInputType
    _max?: VoucherMaxAggregateInputType
  }

  export type VoucherGroupByOutputType = {
    id: number
    voucherNumber: string
    voucherType: $Enums.VoucherType
    status: $Enums.VoucherStatus
    date: Date
    postingDate: Date | null
    paymentMode: $Enums.PaymentMode | null
    instrumentNo: string | null
    instrumentDate: Date | null
    bankName: string | null
    narration: string | null
    companyId: number
    division: string | null
    isPosted: boolean
    postedAt: Date | null
    postedById: number | null
    createdAt: Date
    updatedAt: Date
    _count: VoucherCountAggregateOutputType | null
    _avg: VoucherAvgAggregateOutputType | null
    _sum: VoucherSumAggregateOutputType | null
    _min: VoucherMinAggregateOutputType | null
    _max: VoucherMaxAggregateOutputType | null
  }

  type GetVoucherGroupByPayload<T extends VoucherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoucherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoucherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoucherGroupByOutputType[P]>
            : GetScalarType<T[P], VoucherGroupByOutputType[P]>
        }
      >
    >


  export type VoucherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voucherNumber?: boolean
    voucherType?: boolean
    status?: boolean
    date?: boolean
    postingDate?: boolean
    paymentMode?: boolean
    instrumentNo?: boolean
    instrumentDate?: boolean
    bankName?: boolean
    narration?: boolean
    companyId?: boolean
    division?: boolean
    isPosted?: boolean
    postedAt?: boolean
    postedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    postedBy?: boolean | Voucher$postedByArgs<ExtArgs>
    entries?: boolean | Voucher$entriesArgs<ExtArgs>
    _count?: boolean | VoucherCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucher"]>

  export type VoucherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voucherNumber?: boolean
    voucherType?: boolean
    status?: boolean
    date?: boolean
    postingDate?: boolean
    paymentMode?: boolean
    instrumentNo?: boolean
    instrumentDate?: boolean
    bankName?: boolean
    narration?: boolean
    companyId?: boolean
    division?: boolean
    isPosted?: boolean
    postedAt?: boolean
    postedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    postedBy?: boolean | Voucher$postedByArgs<ExtArgs>
  }, ExtArgs["result"]["voucher"]>

  export type VoucherSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voucherNumber?: boolean
    voucherType?: boolean
    status?: boolean
    date?: boolean
    postingDate?: boolean
    paymentMode?: boolean
    instrumentNo?: boolean
    instrumentDate?: boolean
    bankName?: boolean
    narration?: boolean
    companyId?: boolean
    division?: boolean
    isPosted?: boolean
    postedAt?: boolean
    postedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    postedBy?: boolean | Voucher$postedByArgs<ExtArgs>
  }, ExtArgs["result"]["voucher"]>

  export type VoucherSelectScalar = {
    id?: boolean
    voucherNumber?: boolean
    voucherType?: boolean
    status?: boolean
    date?: boolean
    postingDate?: boolean
    paymentMode?: boolean
    instrumentNo?: boolean
    instrumentDate?: boolean
    bankName?: boolean
    narration?: boolean
    companyId?: boolean
    division?: boolean
    isPosted?: boolean
    postedAt?: boolean
    postedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VoucherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "voucherNumber" | "voucherType" | "status" | "date" | "postingDate" | "paymentMode" | "instrumentNo" | "instrumentDate" | "bankName" | "narration" | "companyId" | "division" | "isPosted" | "postedAt" | "postedById" | "createdAt" | "updatedAt", ExtArgs["result"]["voucher"]>
  export type VoucherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    postedBy?: boolean | Voucher$postedByArgs<ExtArgs>
    entries?: boolean | Voucher$entriesArgs<ExtArgs>
    _count?: boolean | VoucherCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VoucherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    postedBy?: boolean | Voucher$postedByArgs<ExtArgs>
  }
  export type VoucherIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    postedBy?: boolean | Voucher$postedByArgs<ExtArgs>
  }

  export type $VoucherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Voucher"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      postedBy: Prisma.$UserPayload<ExtArgs> | null
      entries: Prisma.$VoucherEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      voucherNumber: string
      voucherType: $Enums.VoucherType
      status: $Enums.VoucherStatus
      date: Date
      postingDate: Date | null
      paymentMode: $Enums.PaymentMode | null
      instrumentNo: string | null
      instrumentDate: Date | null
      bankName: string | null
      narration: string | null
      companyId: number
      division: string | null
      isPosted: boolean
      postedAt: Date | null
      postedById: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["voucher"]>
    composites: {}
  }

  type VoucherGetPayload<S extends boolean | null | undefined | VoucherDefaultArgs> = $Result.GetResult<Prisma.$VoucherPayload, S>

  type VoucherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoucherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoucherCountAggregateInputType | true
    }

  export interface VoucherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Voucher'], meta: { name: 'Voucher' } }
    /**
     * Find zero or one Voucher that matches the filter.
     * @param {VoucherFindUniqueArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoucherFindUniqueArgs>(args: SelectSubset<T, VoucherFindUniqueArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Voucher that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoucherFindUniqueOrThrowArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoucherFindUniqueOrThrowArgs>(args: SelectSubset<T, VoucherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Voucher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindFirstArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoucherFindFirstArgs>(args?: SelectSubset<T, VoucherFindFirstArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Voucher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindFirstOrThrowArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoucherFindFirstOrThrowArgs>(args?: SelectSubset<T, VoucherFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vouchers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vouchers
     * const vouchers = await prisma.voucher.findMany()
     * 
     * // Get first 10 Vouchers
     * const vouchers = await prisma.voucher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voucherWithIdOnly = await prisma.voucher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoucherFindManyArgs>(args?: SelectSubset<T, VoucherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Voucher.
     * @param {VoucherCreateArgs} args - Arguments to create a Voucher.
     * @example
     * // Create one Voucher
     * const Voucher = await prisma.voucher.create({
     *   data: {
     *     // ... data to create a Voucher
     *   }
     * })
     * 
     */
    create<T extends VoucherCreateArgs>(args: SelectSubset<T, VoucherCreateArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vouchers.
     * @param {VoucherCreateManyArgs} args - Arguments to create many Vouchers.
     * @example
     * // Create many Vouchers
     * const voucher = await prisma.voucher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoucherCreateManyArgs>(args?: SelectSubset<T, VoucherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vouchers and returns the data saved in the database.
     * @param {VoucherCreateManyAndReturnArgs} args - Arguments to create many Vouchers.
     * @example
     * // Create many Vouchers
     * const voucher = await prisma.voucher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vouchers and only return the `id`
     * const voucherWithIdOnly = await prisma.voucher.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoucherCreateManyAndReturnArgs>(args?: SelectSubset<T, VoucherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Voucher.
     * @param {VoucherDeleteArgs} args - Arguments to delete one Voucher.
     * @example
     * // Delete one Voucher
     * const Voucher = await prisma.voucher.delete({
     *   where: {
     *     // ... filter to delete one Voucher
     *   }
     * })
     * 
     */
    delete<T extends VoucherDeleteArgs>(args: SelectSubset<T, VoucherDeleteArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Voucher.
     * @param {VoucherUpdateArgs} args - Arguments to update one Voucher.
     * @example
     * // Update one Voucher
     * const voucher = await prisma.voucher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoucherUpdateArgs>(args: SelectSubset<T, VoucherUpdateArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vouchers.
     * @param {VoucherDeleteManyArgs} args - Arguments to filter Vouchers to delete.
     * @example
     * // Delete a few Vouchers
     * const { count } = await prisma.voucher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoucherDeleteManyArgs>(args?: SelectSubset<T, VoucherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vouchers
     * const voucher = await prisma.voucher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoucherUpdateManyArgs>(args: SelectSubset<T, VoucherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vouchers and returns the data updated in the database.
     * @param {VoucherUpdateManyAndReturnArgs} args - Arguments to update many Vouchers.
     * @example
     * // Update many Vouchers
     * const voucher = await prisma.voucher.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vouchers and only return the `id`
     * const voucherWithIdOnly = await prisma.voucher.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VoucherUpdateManyAndReturnArgs>(args: SelectSubset<T, VoucherUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Voucher.
     * @param {VoucherUpsertArgs} args - Arguments to update or create a Voucher.
     * @example
     * // Update or create a Voucher
     * const voucher = await prisma.voucher.upsert({
     *   create: {
     *     // ... data to create a Voucher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Voucher we want to update
     *   }
     * })
     */
    upsert<T extends VoucherUpsertArgs>(args: SelectSubset<T, VoucherUpsertArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherCountArgs} args - Arguments to filter Vouchers to count.
     * @example
     * // Count the number of Vouchers
     * const count = await prisma.voucher.count({
     *   where: {
     *     // ... the filter for the Vouchers we want to count
     *   }
     * })
    **/
    count<T extends VoucherCountArgs>(
      args?: Subset<T, VoucherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoucherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Voucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoucherAggregateArgs>(args: Subset<T, VoucherAggregateArgs>): Prisma.PrismaPromise<GetVoucherAggregateType<T>>

    /**
     * Group by Voucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoucherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoucherGroupByArgs['orderBy'] }
        : { orderBy?: VoucherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoucherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoucherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Voucher model
   */
  readonly fields: VoucherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Voucher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoucherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    postedBy<T extends Voucher$postedByArgs<ExtArgs> = {}>(args?: Subset<T, Voucher$postedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    entries<T extends Voucher$entriesArgs<ExtArgs> = {}>(args?: Subset<T, Voucher$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Voucher model
   */
  interface VoucherFieldRefs {
    readonly id: FieldRef<"Voucher", 'Int'>
    readonly voucherNumber: FieldRef<"Voucher", 'String'>
    readonly voucherType: FieldRef<"Voucher", 'VoucherType'>
    readonly status: FieldRef<"Voucher", 'VoucherStatus'>
    readonly date: FieldRef<"Voucher", 'DateTime'>
    readonly postingDate: FieldRef<"Voucher", 'DateTime'>
    readonly paymentMode: FieldRef<"Voucher", 'PaymentMode'>
    readonly instrumentNo: FieldRef<"Voucher", 'String'>
    readonly instrumentDate: FieldRef<"Voucher", 'DateTime'>
    readonly bankName: FieldRef<"Voucher", 'String'>
    readonly narration: FieldRef<"Voucher", 'String'>
    readonly companyId: FieldRef<"Voucher", 'Int'>
    readonly division: FieldRef<"Voucher", 'String'>
    readonly isPosted: FieldRef<"Voucher", 'Boolean'>
    readonly postedAt: FieldRef<"Voucher", 'DateTime'>
    readonly postedById: FieldRef<"Voucher", 'Int'>
    readonly createdAt: FieldRef<"Voucher", 'DateTime'>
    readonly updatedAt: FieldRef<"Voucher", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Voucher findUnique
   */
  export type VoucherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher findUniqueOrThrow
   */
  export type VoucherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher findFirst
   */
  export type VoucherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vouchers.
     */
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher findFirstOrThrow
   */
  export type VoucherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vouchers.
     */
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher findMany
   */
  export type VoucherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Vouchers to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher create
   */
  export type VoucherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The data needed to create a Voucher.
     */
    data: XOR<VoucherCreateInput, VoucherUncheckedCreateInput>
  }

  /**
   * Voucher createMany
   */
  export type VoucherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vouchers.
     */
    data: VoucherCreateManyInput | VoucherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Voucher createManyAndReturn
   */
  export type VoucherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * The data used to create many Vouchers.
     */
    data: VoucherCreateManyInput | VoucherCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Voucher update
   */
  export type VoucherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The data needed to update a Voucher.
     */
    data: XOR<VoucherUpdateInput, VoucherUncheckedUpdateInput>
    /**
     * Choose, which Voucher to update.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher updateMany
   */
  export type VoucherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vouchers.
     */
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyInput>
    /**
     * Filter which Vouchers to update
     */
    where?: VoucherWhereInput
    /**
     * Limit how many Vouchers to update.
     */
    limit?: number
  }

  /**
   * Voucher updateManyAndReturn
   */
  export type VoucherUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * The data used to update Vouchers.
     */
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyInput>
    /**
     * Filter which Vouchers to update
     */
    where?: VoucherWhereInput
    /**
     * Limit how many Vouchers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Voucher upsert
   */
  export type VoucherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The filter to search for the Voucher to update in case it exists.
     */
    where: VoucherWhereUniqueInput
    /**
     * In case the Voucher found by the `where` argument doesn't exist, create a new Voucher with this data.
     */
    create: XOR<VoucherCreateInput, VoucherUncheckedCreateInput>
    /**
     * In case the Voucher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoucherUpdateInput, VoucherUncheckedUpdateInput>
  }

  /**
   * Voucher delete
   */
  export type VoucherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter which Voucher to delete.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher deleteMany
   */
  export type VoucherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vouchers to delete
     */
    where?: VoucherWhereInput
    /**
     * Limit how many Vouchers to delete.
     */
    limit?: number
  }

  /**
   * Voucher.postedBy
   */
  export type Voucher$postedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Voucher.entries
   */
  export type Voucher$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherEntry
     */
    select?: VoucherEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherEntry
     */
    omit?: VoucherEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherEntryInclude<ExtArgs> | null
    where?: VoucherEntryWhereInput
    orderBy?: VoucherEntryOrderByWithRelationInput | VoucherEntryOrderByWithRelationInput[]
    cursor?: VoucherEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherEntryScalarFieldEnum | VoucherEntryScalarFieldEnum[]
  }

  /**
   * Voucher without action
   */
  export type VoucherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
  }


  /**
   * Model VoucherEntry
   */

  export type AggregateVoucherEntry = {
    _count: VoucherEntryCountAggregateOutputType | null
    _avg: VoucherEntryAvgAggregateOutputType | null
    _sum: VoucherEntrySumAggregateOutputType | null
    _min: VoucherEntryMinAggregateOutputType | null
    _max: VoucherEntryMaxAggregateOutputType | null
  }

  export type VoucherEntryAvgAggregateOutputType = {
    id: number | null
    voucherId: number | null
    accountId: number | null
    debit: number | null
    credit: number | null
  }

  export type VoucherEntrySumAggregateOutputType = {
    id: number | null
    voucherId: number | null
    accountId: number | null
    debit: number | null
    credit: number | null
  }

  export type VoucherEntryMinAggregateOutputType = {
    id: number | null
    voucherId: number | null
    accountId: number | null
    debit: number | null
    credit: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VoucherEntryMaxAggregateOutputType = {
    id: number | null
    voucherId: number | null
    accountId: number | null
    debit: number | null
    credit: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VoucherEntryCountAggregateOutputType = {
    id: number
    voucherId: number
    accountId: number
    debit: number
    credit: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VoucherEntryAvgAggregateInputType = {
    id?: true
    voucherId?: true
    accountId?: true
    debit?: true
    credit?: true
  }

  export type VoucherEntrySumAggregateInputType = {
    id?: true
    voucherId?: true
    accountId?: true
    debit?: true
    credit?: true
  }

  export type VoucherEntryMinAggregateInputType = {
    id?: true
    voucherId?: true
    accountId?: true
    debit?: true
    credit?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VoucherEntryMaxAggregateInputType = {
    id?: true
    voucherId?: true
    accountId?: true
    debit?: true
    credit?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VoucherEntryCountAggregateInputType = {
    id?: true
    voucherId?: true
    accountId?: true
    debit?: true
    credit?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VoucherEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoucherEntry to aggregate.
     */
    where?: VoucherEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherEntries to fetch.
     */
    orderBy?: VoucherEntryOrderByWithRelationInput | VoucherEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoucherEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VoucherEntries
    **/
    _count?: true | VoucherEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VoucherEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VoucherEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoucherEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoucherEntryMaxAggregateInputType
  }

  export type GetVoucherEntryAggregateType<T extends VoucherEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateVoucherEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoucherEntry[P]>
      : GetScalarType<T[P], AggregateVoucherEntry[P]>
  }




  export type VoucherEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherEntryWhereInput
    orderBy?: VoucherEntryOrderByWithAggregationInput | VoucherEntryOrderByWithAggregationInput[]
    by: VoucherEntryScalarFieldEnum[] | VoucherEntryScalarFieldEnum
    having?: VoucherEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoucherEntryCountAggregateInputType | true
    _avg?: VoucherEntryAvgAggregateInputType
    _sum?: VoucherEntrySumAggregateInputType
    _min?: VoucherEntryMinAggregateInputType
    _max?: VoucherEntryMaxAggregateInputType
  }

  export type VoucherEntryGroupByOutputType = {
    id: number
    voucherId: number
    accountId: number
    debit: number
    credit: number
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: VoucherEntryCountAggregateOutputType | null
    _avg: VoucherEntryAvgAggregateOutputType | null
    _sum: VoucherEntrySumAggregateOutputType | null
    _min: VoucherEntryMinAggregateOutputType | null
    _max: VoucherEntryMaxAggregateOutputType | null
  }

  type GetVoucherEntryGroupByPayload<T extends VoucherEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoucherEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoucherEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoucherEntryGroupByOutputType[P]>
            : GetScalarType<T[P], VoucherEntryGroupByOutputType[P]>
        }
      >
    >


  export type VoucherEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voucherId?: boolean
    accountId?: boolean
    debit?: boolean
    credit?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucherEntry"]>

  export type VoucherEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voucherId?: boolean
    accountId?: boolean
    debit?: boolean
    credit?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucherEntry"]>

  export type VoucherEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voucherId?: boolean
    accountId?: boolean
    debit?: boolean
    credit?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucherEntry"]>

  export type VoucherEntrySelectScalar = {
    id?: boolean
    voucherId?: boolean
    accountId?: boolean
    debit?: boolean
    credit?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VoucherEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "voucherId" | "accountId" | "debit" | "credit" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["voucherEntry"]>
  export type VoucherEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
  }
  export type VoucherEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
  }
  export type VoucherEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
  }

  export type $VoucherEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VoucherEntry"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      voucher: Prisma.$VoucherPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      voucherId: number
      accountId: number
      debit: number
      credit: number
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["voucherEntry"]>
    composites: {}
  }

  type VoucherEntryGetPayload<S extends boolean | null | undefined | VoucherEntryDefaultArgs> = $Result.GetResult<Prisma.$VoucherEntryPayload, S>

  type VoucherEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoucherEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoucherEntryCountAggregateInputType | true
    }

  export interface VoucherEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VoucherEntry'], meta: { name: 'VoucherEntry' } }
    /**
     * Find zero or one VoucherEntry that matches the filter.
     * @param {VoucherEntryFindUniqueArgs} args - Arguments to find a VoucherEntry
     * @example
     * // Get one VoucherEntry
     * const voucherEntry = await prisma.voucherEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoucherEntryFindUniqueArgs>(args: SelectSubset<T, VoucherEntryFindUniqueArgs<ExtArgs>>): Prisma__VoucherEntryClient<$Result.GetResult<Prisma.$VoucherEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VoucherEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoucherEntryFindUniqueOrThrowArgs} args - Arguments to find a VoucherEntry
     * @example
     * // Get one VoucherEntry
     * const voucherEntry = await prisma.voucherEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoucherEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, VoucherEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoucherEntryClient<$Result.GetResult<Prisma.$VoucherEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VoucherEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherEntryFindFirstArgs} args - Arguments to find a VoucherEntry
     * @example
     * // Get one VoucherEntry
     * const voucherEntry = await prisma.voucherEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoucherEntryFindFirstArgs>(args?: SelectSubset<T, VoucherEntryFindFirstArgs<ExtArgs>>): Prisma__VoucherEntryClient<$Result.GetResult<Prisma.$VoucherEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VoucherEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherEntryFindFirstOrThrowArgs} args - Arguments to find a VoucherEntry
     * @example
     * // Get one VoucherEntry
     * const voucherEntry = await prisma.voucherEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoucherEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, VoucherEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoucherEntryClient<$Result.GetResult<Prisma.$VoucherEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VoucherEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VoucherEntries
     * const voucherEntries = await prisma.voucherEntry.findMany()
     * 
     * // Get first 10 VoucherEntries
     * const voucherEntries = await prisma.voucherEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voucherEntryWithIdOnly = await prisma.voucherEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoucherEntryFindManyArgs>(args?: SelectSubset<T, VoucherEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VoucherEntry.
     * @param {VoucherEntryCreateArgs} args - Arguments to create a VoucherEntry.
     * @example
     * // Create one VoucherEntry
     * const VoucherEntry = await prisma.voucherEntry.create({
     *   data: {
     *     // ... data to create a VoucherEntry
     *   }
     * })
     * 
     */
    create<T extends VoucherEntryCreateArgs>(args: SelectSubset<T, VoucherEntryCreateArgs<ExtArgs>>): Prisma__VoucherEntryClient<$Result.GetResult<Prisma.$VoucherEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VoucherEntries.
     * @param {VoucherEntryCreateManyArgs} args - Arguments to create many VoucherEntries.
     * @example
     * // Create many VoucherEntries
     * const voucherEntry = await prisma.voucherEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoucherEntryCreateManyArgs>(args?: SelectSubset<T, VoucherEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VoucherEntries and returns the data saved in the database.
     * @param {VoucherEntryCreateManyAndReturnArgs} args - Arguments to create many VoucherEntries.
     * @example
     * // Create many VoucherEntries
     * const voucherEntry = await prisma.voucherEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VoucherEntries and only return the `id`
     * const voucherEntryWithIdOnly = await prisma.voucherEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoucherEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, VoucherEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VoucherEntry.
     * @param {VoucherEntryDeleteArgs} args - Arguments to delete one VoucherEntry.
     * @example
     * // Delete one VoucherEntry
     * const VoucherEntry = await prisma.voucherEntry.delete({
     *   where: {
     *     // ... filter to delete one VoucherEntry
     *   }
     * })
     * 
     */
    delete<T extends VoucherEntryDeleteArgs>(args: SelectSubset<T, VoucherEntryDeleteArgs<ExtArgs>>): Prisma__VoucherEntryClient<$Result.GetResult<Prisma.$VoucherEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VoucherEntry.
     * @param {VoucherEntryUpdateArgs} args - Arguments to update one VoucherEntry.
     * @example
     * // Update one VoucherEntry
     * const voucherEntry = await prisma.voucherEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoucherEntryUpdateArgs>(args: SelectSubset<T, VoucherEntryUpdateArgs<ExtArgs>>): Prisma__VoucherEntryClient<$Result.GetResult<Prisma.$VoucherEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VoucherEntries.
     * @param {VoucherEntryDeleteManyArgs} args - Arguments to filter VoucherEntries to delete.
     * @example
     * // Delete a few VoucherEntries
     * const { count } = await prisma.voucherEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoucherEntryDeleteManyArgs>(args?: SelectSubset<T, VoucherEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoucherEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VoucherEntries
     * const voucherEntry = await prisma.voucherEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoucherEntryUpdateManyArgs>(args: SelectSubset<T, VoucherEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoucherEntries and returns the data updated in the database.
     * @param {VoucherEntryUpdateManyAndReturnArgs} args - Arguments to update many VoucherEntries.
     * @example
     * // Update many VoucherEntries
     * const voucherEntry = await prisma.voucherEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VoucherEntries and only return the `id`
     * const voucherEntryWithIdOnly = await prisma.voucherEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VoucherEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, VoucherEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VoucherEntry.
     * @param {VoucherEntryUpsertArgs} args - Arguments to update or create a VoucherEntry.
     * @example
     * // Update or create a VoucherEntry
     * const voucherEntry = await prisma.voucherEntry.upsert({
     *   create: {
     *     // ... data to create a VoucherEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VoucherEntry we want to update
     *   }
     * })
     */
    upsert<T extends VoucherEntryUpsertArgs>(args: SelectSubset<T, VoucherEntryUpsertArgs<ExtArgs>>): Prisma__VoucherEntryClient<$Result.GetResult<Prisma.$VoucherEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VoucherEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherEntryCountArgs} args - Arguments to filter VoucherEntries to count.
     * @example
     * // Count the number of VoucherEntries
     * const count = await prisma.voucherEntry.count({
     *   where: {
     *     // ... the filter for the VoucherEntries we want to count
     *   }
     * })
    **/
    count<T extends VoucherEntryCountArgs>(
      args?: Subset<T, VoucherEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoucherEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VoucherEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoucherEntryAggregateArgs>(args: Subset<T, VoucherEntryAggregateArgs>): Prisma.PrismaPromise<GetVoucherEntryAggregateType<T>>

    /**
     * Group by VoucherEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoucherEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoucherEntryGroupByArgs['orderBy'] }
        : { orderBy?: VoucherEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoucherEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoucherEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VoucherEntry model
   */
  readonly fields: VoucherEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VoucherEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoucherEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    voucher<T extends VoucherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VoucherDefaultArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VoucherEntry model
   */
  interface VoucherEntryFieldRefs {
    readonly id: FieldRef<"VoucherEntry", 'Int'>
    readonly voucherId: FieldRef<"VoucherEntry", 'Int'>
    readonly accountId: FieldRef<"VoucherEntry", 'Int'>
    readonly debit: FieldRef<"VoucherEntry", 'Float'>
    readonly credit: FieldRef<"VoucherEntry", 'Float'>
    readonly description: FieldRef<"VoucherEntry", 'String'>
    readonly createdAt: FieldRef<"VoucherEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"VoucherEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VoucherEntry findUnique
   */
  export type VoucherEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherEntry
     */
    select?: VoucherEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherEntry
     */
    omit?: VoucherEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherEntryInclude<ExtArgs> | null
    /**
     * Filter, which VoucherEntry to fetch.
     */
    where: VoucherEntryWhereUniqueInput
  }

  /**
   * VoucherEntry findUniqueOrThrow
   */
  export type VoucherEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherEntry
     */
    select?: VoucherEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherEntry
     */
    omit?: VoucherEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherEntryInclude<ExtArgs> | null
    /**
     * Filter, which VoucherEntry to fetch.
     */
    where: VoucherEntryWhereUniqueInput
  }

  /**
   * VoucherEntry findFirst
   */
  export type VoucherEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherEntry
     */
    select?: VoucherEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherEntry
     */
    omit?: VoucherEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherEntryInclude<ExtArgs> | null
    /**
     * Filter, which VoucherEntry to fetch.
     */
    where?: VoucherEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherEntries to fetch.
     */
    orderBy?: VoucherEntryOrderByWithRelationInput | VoucherEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoucherEntries.
     */
    cursor?: VoucherEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoucherEntries.
     */
    distinct?: VoucherEntryScalarFieldEnum | VoucherEntryScalarFieldEnum[]
  }

  /**
   * VoucherEntry findFirstOrThrow
   */
  export type VoucherEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherEntry
     */
    select?: VoucherEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherEntry
     */
    omit?: VoucherEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherEntryInclude<ExtArgs> | null
    /**
     * Filter, which VoucherEntry to fetch.
     */
    where?: VoucherEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherEntries to fetch.
     */
    orderBy?: VoucherEntryOrderByWithRelationInput | VoucherEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoucherEntries.
     */
    cursor?: VoucherEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoucherEntries.
     */
    distinct?: VoucherEntryScalarFieldEnum | VoucherEntryScalarFieldEnum[]
  }

  /**
   * VoucherEntry findMany
   */
  export type VoucherEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherEntry
     */
    select?: VoucherEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherEntry
     */
    omit?: VoucherEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherEntryInclude<ExtArgs> | null
    /**
     * Filter, which VoucherEntries to fetch.
     */
    where?: VoucherEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherEntries to fetch.
     */
    orderBy?: VoucherEntryOrderByWithRelationInput | VoucherEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VoucherEntries.
     */
    cursor?: VoucherEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherEntries.
     */
    skip?: number
    distinct?: VoucherEntryScalarFieldEnum | VoucherEntryScalarFieldEnum[]
  }

  /**
   * VoucherEntry create
   */
  export type VoucherEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherEntry
     */
    select?: VoucherEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherEntry
     */
    omit?: VoucherEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a VoucherEntry.
     */
    data: XOR<VoucherEntryCreateInput, VoucherEntryUncheckedCreateInput>
  }

  /**
   * VoucherEntry createMany
   */
  export type VoucherEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VoucherEntries.
     */
    data: VoucherEntryCreateManyInput | VoucherEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VoucherEntry createManyAndReturn
   */
  export type VoucherEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherEntry
     */
    select?: VoucherEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherEntry
     */
    omit?: VoucherEntryOmit<ExtArgs> | null
    /**
     * The data used to create many VoucherEntries.
     */
    data: VoucherEntryCreateManyInput | VoucherEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VoucherEntry update
   */
  export type VoucherEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherEntry
     */
    select?: VoucherEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherEntry
     */
    omit?: VoucherEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a VoucherEntry.
     */
    data: XOR<VoucherEntryUpdateInput, VoucherEntryUncheckedUpdateInput>
    /**
     * Choose, which VoucherEntry to update.
     */
    where: VoucherEntryWhereUniqueInput
  }

  /**
   * VoucherEntry updateMany
   */
  export type VoucherEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VoucherEntries.
     */
    data: XOR<VoucherEntryUpdateManyMutationInput, VoucherEntryUncheckedUpdateManyInput>
    /**
     * Filter which VoucherEntries to update
     */
    where?: VoucherEntryWhereInput
    /**
     * Limit how many VoucherEntries to update.
     */
    limit?: number
  }

  /**
   * VoucherEntry updateManyAndReturn
   */
  export type VoucherEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherEntry
     */
    select?: VoucherEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherEntry
     */
    omit?: VoucherEntryOmit<ExtArgs> | null
    /**
     * The data used to update VoucherEntries.
     */
    data: XOR<VoucherEntryUpdateManyMutationInput, VoucherEntryUncheckedUpdateManyInput>
    /**
     * Filter which VoucherEntries to update
     */
    where?: VoucherEntryWhereInput
    /**
     * Limit how many VoucherEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VoucherEntry upsert
   */
  export type VoucherEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherEntry
     */
    select?: VoucherEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherEntry
     */
    omit?: VoucherEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the VoucherEntry to update in case it exists.
     */
    where: VoucherEntryWhereUniqueInput
    /**
     * In case the VoucherEntry found by the `where` argument doesn't exist, create a new VoucherEntry with this data.
     */
    create: XOR<VoucherEntryCreateInput, VoucherEntryUncheckedCreateInput>
    /**
     * In case the VoucherEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoucherEntryUpdateInput, VoucherEntryUncheckedUpdateInput>
  }

  /**
   * VoucherEntry delete
   */
  export type VoucherEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherEntry
     */
    select?: VoucherEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherEntry
     */
    omit?: VoucherEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherEntryInclude<ExtArgs> | null
    /**
     * Filter which VoucherEntry to delete.
     */
    where: VoucherEntryWhereUniqueInput
  }

  /**
   * VoucherEntry deleteMany
   */
  export type VoucherEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoucherEntries to delete
     */
    where?: VoucherEntryWhereInput
    /**
     * Limit how many VoucherEntries to delete.
     */
    limit?: number
  }

  /**
   * VoucherEntry without action
   */
  export type VoucherEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherEntry
     */
    select?: VoucherEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherEntry
     */
    omit?: VoucherEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherEntryInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    uniqueId: 'uniqueId',
    address: 'address',
    phone: 'phone',
    email: 'email',
    industry: 'industry',
    logo: 'logo',
    themeConfig: 'themeConfig',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    city: 'city',
    country: 'country',
    fiscalYearEnd: 'fiscalYearEnd',
    fiscalYearStart: 'fiscalYearStart',
    postalCode: 'postalCode',
    registrationNo: 'registrationNo',
    state: 'state',
    tagline: 'tagline',
    taxNumber: 'taxNumber',
    website: 'website'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const BranchScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]


  export const CurrencyScalarFieldEnum: {
    id: 'id',
    code: 'code',
    symbol: 'symbol',
    name: 'name'
  };

  export type CurrencyScalarFieldEnum = (typeof CurrencyScalarFieldEnum)[keyof typeof CurrencyScalarFieldEnum]


  export const CompanyCurrencyScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    currencyId: 'currencyId',
    exchangeRate: 'exchangeRate',
    isDefault: 'isDefault'
  };

  export type CompanyCurrencyScalarFieldEnum = (typeof CompanyCurrencyScalarFieldEnum)[keyof typeof CompanyCurrencyScalarFieldEnum]


  export const TaxSettingScalarFieldEnum: {
    id: 'id',
    name: 'name',
    percentage: 'percentage',
    type: 'type',
    companyId: 'companyId',
    branchId: 'branchId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaxSettingScalarFieldEnum = (typeof TaxSettingScalarFieldEnum)[keyof typeof TaxSettingScalarFieldEnum]


  export const SystemSettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    type: 'type',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemSettingScalarFieldEnum = (typeof SystemSettingScalarFieldEnum)[keyof typeof SystemSettingScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    role: 'role',
    companyId: 'companyId',
    branch: 'branch',
    department: 'department',
    region: 'region',
    division: 'division',
    resetToken: 'resetToken',
    resetTokenExpiry: 'resetTokenExpiry',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    address: 'address',
    phone: 'phone',
    email: 'email',
    taxNumber: 'taxNumber',
    accountId: 'accountId',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    division: 'division'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const VendorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    type: 'type',
    address: 'address',
    phone: 'phone',
    email: 'email',
    taxNumber: 'taxNumber',
    accountId: 'accountId',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    division: 'division'
  };

  export type VendorScalarFieldEnum = (typeof VendorScalarFieldEnum)[keyof typeof VendorScalarFieldEnum]


  export const JobScalarFieldEnum: {
    id: 'id',
    jobNumber: 'jobNumber',
    date: 'date',
    jobDate: 'jobDate',
    jobType: 'jobType',
    status: 'status',
    customerId: 'customerId',
    vessel: 'vessel',
    place: 'place',
    shipperRef: 'shipperRef',
    gdNo: 'gdNo',
    gdDate: 'gdDate',
    formE: 'formE',
    formEDate: 'formEDate',
    commodity: 'commodity',
    volume: 'volume',
    containerNo: 'containerNo',
    podId: 'podId',
    packages: 'packages',
    weight: 'weight',
    hawbBl: 'hawbBl',
    handledBy: 'handledBy',
    salesPerson: 'salesPerson',
    companyId: 'companyId',
    branchId: 'branchId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    division: 'division'
  };

  export type JobScalarFieldEnum = (typeof JobScalarFieldEnum)[keyof typeof JobScalarFieldEnum]


  export const ExpenseMasterScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExpenseMasterScalarFieldEnum = (typeof ExpenseMasterScalarFieldEnum)[keyof typeof ExpenseMasterScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    jobId: 'jobId',
    vendorId: 'vendorId',
    description: 'description',
    costPrice: 'costPrice',
    sellingPrice: 'sellingPrice',
    currencyCode: 'currencyCode',
    exchangeRate: 'exchangeRate',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const ServiceInvoiceScalarFieldEnum: {
    id: 'id',
    invoiceNumber: 'invoiceNumber',
    date: 'date',
    jobId: 'jobId',
    customerId: 'customerId',
    type: 'type',
    status: 'status',
    masterNumber: 'masterNumber',
    agentCode: 'agentCode',
    shippingLine: 'shippingLine',
    origin: 'origin',
    destination: 'destination',
    creditDays: 'creditDays',
    vendorType: 'vendorType',
    totalAmount: 'totalAmount',
    taxAmount: 'taxAmount',
    grandTotal: 'grandTotal',
    currencyCode: 'currencyCode',
    exchangeRate: 'exchangeRate',
    isApproved: 'isApproved',
    approvedById: 'approvedById',
    isLocked: 'isLocked',
    lockedAt: 'lockedAt',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    transactionId: 'transactionId',
    division: 'division'
  };

  export type ServiceInvoiceScalarFieldEnum = (typeof ServiceInvoiceScalarFieldEnum)[keyof typeof ServiceInvoiceScalarFieldEnum]


  export const ServiceInvoiceItemScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    description: 'description',
    quantity: 'quantity',
    rate: 'rate',
    amount: 'amount',
    taxPercentage: 'taxPercentage',
    taxAmount: 'taxAmount',
    total: 'total',
    productId: 'productId'
  };

  export type ServiceInvoiceItemScalarFieldEnum = (typeof ServiceInvoiceItemScalarFieldEnum)[keyof typeof ServiceInvoiceItemScalarFieldEnum]


  export const FreightInvoiceScalarFieldEnum: {
    id: 'id',
    invoiceNumber: 'invoiceNumber',
    date: 'date',
    jobId: 'jobId',
    customerId: 'customerId',
    type: 'type',
    status: 'status',
    usdRate: 'usdRate',
    exchangeRate: 'exchangeRate',
    totalAmount: 'totalAmount',
    taxAmount: 'taxAmount',
    grandTotal: 'grandTotal',
    currencyCode: 'currencyCode',
    isApproved: 'isApproved',
    approvedById: 'approvedById',
    isLocked: 'isLocked',
    lockedAt: 'lockedAt',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    transactionId: 'transactionId',
    division: 'division'
  };

  export type FreightInvoiceScalarFieldEnum = (typeof FreightInvoiceScalarFieldEnum)[keyof typeof FreightInvoiceScalarFieldEnum]


  export const FreightInvoiceItemScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    description: 'description',
    quantity: 'quantity',
    rate: 'rate',
    amount: 'amount',
    taxPercentage: 'taxPercentage',
    taxAmount: 'taxAmount',
    total: 'total',
    vendorId: 'vendorId'
  };

  export type FreightInvoiceItemScalarFieldEnum = (typeof FreightInvoiceItemScalarFieldEnum)[keyof typeof FreightInvoiceItemScalarFieldEnum]


  export const ProductCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductCategoryScalarFieldEnum = (typeof ProductCategoryScalarFieldEnum)[keyof typeof ProductCategoryScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    sku: 'sku',
    name: 'name',
    description: 'description',
    unit: 'unit',
    purchasePrice: 'purchasePrice',
    sellingPrice: 'sellingPrice',
    categoryId: 'categoryId',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const WarehouseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WarehouseScalarFieldEnum = (typeof WarehouseScalarFieldEnum)[keyof typeof WarehouseScalarFieldEnum]


  export const StockMovementScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    warehouseId: 'warehouseId',
    quantity: 'quantity',
    type: 'type',
    reference: 'reference',
    companyId: 'companyId',
    createdAt: 'createdAt'
  };

  export type StockMovementScalarFieldEnum = (typeof StockMovementScalarFieldEnum)[keyof typeof StockMovementScalarFieldEnum]


  export const PurchaseInvoiceScalarFieldEnum: {
    id: 'id',
    purchaseNumber: 'purchaseNumber',
    date: 'date',
    vendorId: 'vendorId',
    status: 'status',
    totalAmount: 'totalAmount',
    taxAmount: 'taxAmount',
    grandTotal: 'grandTotal',
    currencyCode: 'currencyCode',
    isApproved: 'isApproved',
    approvedById: 'approvedById',
    isLocked: 'isLocked',
    lockedAt: 'lockedAt',
    companyId: 'companyId',
    transactionId: 'transactionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type PurchaseInvoiceScalarFieldEnum = (typeof PurchaseInvoiceScalarFieldEnum)[keyof typeof PurchaseInvoiceScalarFieldEnum]


  export const PurchaseInvoiceItemScalarFieldEnum: {
    id: 'id',
    purchaseInvoiceId: 'purchaseInvoiceId',
    productId: 'productId',
    description: 'description',
    quantity: 'quantity',
    rate: 'rate',
    amount: 'amount',
    taxPercentage: 'taxPercentage',
    taxAmount: 'taxAmount',
    total: 'total'
  };

  export type PurchaseInvoiceItemScalarFieldEnum = (typeof PurchaseInvoiceItemScalarFieldEnum)[keyof typeof PurchaseInvoiceItemScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    type: 'type',
    description: 'description',
    parentId: 'parentId',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    division: 'division'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    reference: 'reference',
    date: 'date',
    description: 'description',
    type: 'type',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isLocked: 'isLocked'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const AccountEntryScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    accountId: 'accountId',
    description: 'description',
    debit: 'debit',
    credit: 'credit',
    createdAt: 'createdAt'
  };

  export type AccountEntryScalarFieldEnum = (typeof AccountEntryScalarFieldEnum)[keyof typeof AccountEntryScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    receiptNumber: 'receiptNumber',
    date: 'date',
    amount: 'amount',
    mode: 'mode',
    reference: 'reference',
    customerId: 'customerId',
    vendorId: 'vendorId',
    transactionId: 'transactionId',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    division: 'division'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    module: 'module',
    entityId: 'entityId',
    payload: 'payload',
    ipAddress: 'ipAddress',
    createdAt: 'createdAt',
    companyId: 'companyId'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const FinancialPeriodScalarFieldEnum: {
    id: 'id',
    month: 'month',
    year: 'year',
    isClosed: 'isClosed',
    closedById: 'closedById',
    closedAt: 'closedAt',
    companyId: 'companyId'
  };

  export type FinancialPeriodScalarFieldEnum = (typeof FinancialPeriodScalarFieldEnum)[keyof typeof FinancialPeriodScalarFieldEnum]


  export const PortScalarFieldEnum: {
    id: 'id',
    name: 'name',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PortScalarFieldEnum = (typeof PortScalarFieldEnum)[keyof typeof PortScalarFieldEnum]


  export const VoucherScalarFieldEnum: {
    id: 'id',
    voucherNumber: 'voucherNumber',
    voucherType: 'voucherType',
    status: 'status',
    date: 'date',
    postingDate: 'postingDate',
    paymentMode: 'paymentMode',
    instrumentNo: 'instrumentNo',
    instrumentDate: 'instrumentDate',
    bankName: 'bankName',
    narration: 'narration',
    companyId: 'companyId',
    division: 'division',
    isPosted: 'isPosted',
    postedAt: 'postedAt',
    postedById: 'postedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VoucherScalarFieldEnum = (typeof VoucherScalarFieldEnum)[keyof typeof VoucherScalarFieldEnum]


  export const VoucherEntryScalarFieldEnum: {
    id: 'id',
    voucherId: 'voucherId',
    accountId: 'accountId',
    debit: 'debit',
    credit: 'credit',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VoucherEntryScalarFieldEnum = (typeof VoucherEntryScalarFieldEnum)[keyof typeof VoucherEntryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'JobType'
   */
  export type EnumJobTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobType'>
    


  /**
   * Reference to a field of type 'JobType[]'
   */
  export type ListEnumJobTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobType[]'>
    


  /**
   * Reference to a field of type 'JobStatus'
   */
  export type EnumJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobStatus'>
    


  /**
   * Reference to a field of type 'JobStatus[]'
   */
  export type ListEnumJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobStatus[]'>
    


  /**
   * Reference to a field of type 'InvoiceType'
   */
  export type EnumInvoiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceType'>
    


  /**
   * Reference to a field of type 'InvoiceType[]'
   */
  export type ListEnumInvoiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceType[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'AccountType'
   */
  export type EnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType'>
    


  /**
   * Reference to a field of type 'AccountType[]'
   */
  export type ListEnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'PaymentMode'
   */
  export type EnumPaymentModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMode'>
    


  /**
   * Reference to a field of type 'PaymentMode[]'
   */
  export type ListEnumPaymentModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMode[]'>
    


  /**
   * Reference to a field of type 'VoucherType'
   */
  export type EnumVoucherTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoucherType'>
    


  /**
   * Reference to a field of type 'VoucherType[]'
   */
  export type ListEnumVoucherTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoucherType[]'>
    


  /**
   * Reference to a field of type 'VoucherStatus'
   */
  export type EnumVoucherStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoucherStatus'>
    


  /**
   * Reference to a field of type 'VoucherStatus[]'
   */
  export type ListEnumVoucherStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoucherStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: IntFilter<"Company"> | number
    name?: StringFilter<"Company"> | string
    uniqueId?: StringFilter<"Company"> | string
    address?: StringNullableFilter<"Company"> | string | null
    phone?: StringNullableFilter<"Company"> | string | null
    email?: StringNullableFilter<"Company"> | string | null
    industry?: StringNullableFilter<"Company"> | string | null
    logo?: StringNullableFilter<"Company"> | string | null
    themeConfig?: JsonNullableFilter<"Company">
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    city?: StringNullableFilter<"Company"> | string | null
    country?: StringNullableFilter<"Company"> | string | null
    fiscalYearEnd?: DateTimeNullableFilter<"Company"> | Date | string | null
    fiscalYearStart?: DateTimeNullableFilter<"Company"> | Date | string | null
    postalCode?: StringNullableFilter<"Company"> | string | null
    registrationNo?: StringNullableFilter<"Company"> | string | null
    state?: StringNullableFilter<"Company"> | string | null
    tagline?: StringNullableFilter<"Company"> | string | null
    taxNumber?: StringNullableFilter<"Company"> | string | null
    website?: StringNullableFilter<"Company"> | string | null
    accounts?: AccountListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    branches?: BranchListRelationFilter
    currencies?: CompanyCurrencyListRelationFilter
    customers?: CustomerListRelationFilter
    expenses?: ExpenseListRelationFilter
    expensesMaster?: ExpenseMasterListRelationFilter
    financialPeriods?: FinancialPeriodListRelationFilter
    serviceInvoices?: ServiceInvoiceListRelationFilter
    freightInvoices?: FreightInvoiceListRelationFilter
    jobs?: JobListRelationFilter
    payments?: PaymentListRelationFilter
    ports?: PortListRelationFilter
    products?: ProductListRelationFilter
    productCategories?: ProductCategoryListRelationFilter
    purchaseInvoices?: PurchaseInvoiceListRelationFilter
    stockMovements?: StockMovementListRelationFilter
    systemSettings?: SystemSettingListRelationFilter
    taxSettings?: TaxSettingListRelationFilter
    transactions?: TransactionListRelationFilter
    users?: UserListRelationFilter
    vendors?: VendorListRelationFilter
    vouchers?: VoucherListRelationFilter
    warehouses?: WarehouseListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    uniqueId?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    themeConfig?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    fiscalYearEnd?: SortOrderInput | SortOrder
    fiscalYearStart?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    registrationNo?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    tagline?: SortOrderInput | SortOrder
    taxNumber?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    branches?: BranchOrderByRelationAggregateInput
    currencies?: CompanyCurrencyOrderByRelationAggregateInput
    customers?: CustomerOrderByRelationAggregateInput
    expenses?: ExpenseOrderByRelationAggregateInput
    expensesMaster?: ExpenseMasterOrderByRelationAggregateInput
    financialPeriods?: FinancialPeriodOrderByRelationAggregateInput
    serviceInvoices?: ServiceInvoiceOrderByRelationAggregateInput
    freightInvoices?: FreightInvoiceOrderByRelationAggregateInput
    jobs?: JobOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    ports?: PortOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    productCategories?: ProductCategoryOrderByRelationAggregateInput
    purchaseInvoices?: PurchaseInvoiceOrderByRelationAggregateInput
    stockMovements?: StockMovementOrderByRelationAggregateInput
    systemSettings?: SystemSettingOrderByRelationAggregateInput
    taxSettings?: TaxSettingOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    vendors?: VendorOrderByRelationAggregateInput
    vouchers?: VoucherOrderByRelationAggregateInput
    warehouses?: WarehouseOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uniqueId?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    address?: StringNullableFilter<"Company"> | string | null
    phone?: StringNullableFilter<"Company"> | string | null
    email?: StringNullableFilter<"Company"> | string | null
    industry?: StringNullableFilter<"Company"> | string | null
    logo?: StringNullableFilter<"Company"> | string | null
    themeConfig?: JsonNullableFilter<"Company">
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    city?: StringNullableFilter<"Company"> | string | null
    country?: StringNullableFilter<"Company"> | string | null
    fiscalYearEnd?: DateTimeNullableFilter<"Company"> | Date | string | null
    fiscalYearStart?: DateTimeNullableFilter<"Company"> | Date | string | null
    postalCode?: StringNullableFilter<"Company"> | string | null
    registrationNo?: StringNullableFilter<"Company"> | string | null
    state?: StringNullableFilter<"Company"> | string | null
    tagline?: StringNullableFilter<"Company"> | string | null
    taxNumber?: StringNullableFilter<"Company"> | string | null
    website?: StringNullableFilter<"Company"> | string | null
    accounts?: AccountListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    branches?: BranchListRelationFilter
    currencies?: CompanyCurrencyListRelationFilter
    customers?: CustomerListRelationFilter
    expenses?: ExpenseListRelationFilter
    expensesMaster?: ExpenseMasterListRelationFilter
    financialPeriods?: FinancialPeriodListRelationFilter
    serviceInvoices?: ServiceInvoiceListRelationFilter
    freightInvoices?: FreightInvoiceListRelationFilter
    jobs?: JobListRelationFilter
    payments?: PaymentListRelationFilter
    ports?: PortListRelationFilter
    products?: ProductListRelationFilter
    productCategories?: ProductCategoryListRelationFilter
    purchaseInvoices?: PurchaseInvoiceListRelationFilter
    stockMovements?: StockMovementListRelationFilter
    systemSettings?: SystemSettingListRelationFilter
    taxSettings?: TaxSettingListRelationFilter
    transactions?: TransactionListRelationFilter
    users?: UserListRelationFilter
    vendors?: VendorListRelationFilter
    vouchers?: VoucherListRelationFilter
    warehouses?: WarehouseListRelationFilter
  }, "id" | "uniqueId">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    uniqueId?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    themeConfig?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    fiscalYearEnd?: SortOrderInput | SortOrder
    fiscalYearStart?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    registrationNo?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    tagline?: SortOrderInput | SortOrder
    taxNumber?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _avg?: CompanyAvgOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
    _sum?: CompanySumOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Company"> | number
    name?: StringWithAggregatesFilter<"Company"> | string
    uniqueId?: StringWithAggregatesFilter<"Company"> | string
    address?: StringNullableWithAggregatesFilter<"Company"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Company"> | string | null
    email?: StringNullableWithAggregatesFilter<"Company"> | string | null
    industry?: StringNullableWithAggregatesFilter<"Company"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Company"> | string | null
    themeConfig?: JsonNullableWithAggregatesFilter<"Company">
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    city?: StringNullableWithAggregatesFilter<"Company"> | string | null
    country?: StringNullableWithAggregatesFilter<"Company"> | string | null
    fiscalYearEnd?: DateTimeNullableWithAggregatesFilter<"Company"> | Date | string | null
    fiscalYearStart?: DateTimeNullableWithAggregatesFilter<"Company"> | Date | string | null
    postalCode?: StringNullableWithAggregatesFilter<"Company"> | string | null
    registrationNo?: StringNullableWithAggregatesFilter<"Company"> | string | null
    state?: StringNullableWithAggregatesFilter<"Company"> | string | null
    tagline?: StringNullableWithAggregatesFilter<"Company"> | string | null
    taxNumber?: StringNullableWithAggregatesFilter<"Company"> | string | null
    website?: StringNullableWithAggregatesFilter<"Company"> | string | null
  }

  export type BranchWhereInput = {
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    id?: IntFilter<"Branch"> | number
    name?: StringFilter<"Branch"> | string
    location?: StringNullableFilter<"Branch"> | string | null
    companyId?: IntFilter<"Branch"> | number
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    jobs?: JobListRelationFilter
    taxSettings?: TaxSettingListRelationFilter
  }

  export type BranchOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    jobs?: JobOrderByRelationAggregateInput
    taxSettings?: TaxSettingOrderByRelationAggregateInput
  }

  export type BranchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    name?: StringFilter<"Branch"> | string
    location?: StringNullableFilter<"Branch"> | string | null
    companyId?: IntFilter<"Branch"> | number
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    jobs?: JobListRelationFilter
    taxSettings?: TaxSettingListRelationFilter
  }, "id">

  export type BranchOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BranchCountOrderByAggregateInput
    _avg?: BranchAvgOrderByAggregateInput
    _max?: BranchMaxOrderByAggregateInput
    _min?: BranchMinOrderByAggregateInput
    _sum?: BranchSumOrderByAggregateInput
  }

  export type BranchScalarWhereWithAggregatesInput = {
    AND?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    OR?: BranchScalarWhereWithAggregatesInput[]
    NOT?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Branch"> | number
    name?: StringWithAggregatesFilter<"Branch"> | string
    location?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    companyId?: IntWithAggregatesFilter<"Branch"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
  }

  export type CurrencyWhereInput = {
    AND?: CurrencyWhereInput | CurrencyWhereInput[]
    OR?: CurrencyWhereInput[]
    NOT?: CurrencyWhereInput | CurrencyWhereInput[]
    id?: IntFilter<"Currency"> | number
    code?: StringFilter<"Currency"> | string
    symbol?: StringFilter<"Currency"> | string
    name?: StringFilter<"Currency"> | string
    companies?: CompanyCurrencyListRelationFilter
  }

  export type CurrencyOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    companies?: CompanyCurrencyOrderByRelationAggregateInput
  }

  export type CurrencyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: CurrencyWhereInput | CurrencyWhereInput[]
    OR?: CurrencyWhereInput[]
    NOT?: CurrencyWhereInput | CurrencyWhereInput[]
    symbol?: StringFilter<"Currency"> | string
    name?: StringFilter<"Currency"> | string
    companies?: CompanyCurrencyListRelationFilter
  }, "id" | "code">

  export type CurrencyOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    _count?: CurrencyCountOrderByAggregateInput
    _avg?: CurrencyAvgOrderByAggregateInput
    _max?: CurrencyMaxOrderByAggregateInput
    _min?: CurrencyMinOrderByAggregateInput
    _sum?: CurrencySumOrderByAggregateInput
  }

  export type CurrencyScalarWhereWithAggregatesInput = {
    AND?: CurrencyScalarWhereWithAggregatesInput | CurrencyScalarWhereWithAggregatesInput[]
    OR?: CurrencyScalarWhereWithAggregatesInput[]
    NOT?: CurrencyScalarWhereWithAggregatesInput | CurrencyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Currency"> | number
    code?: StringWithAggregatesFilter<"Currency"> | string
    symbol?: StringWithAggregatesFilter<"Currency"> | string
    name?: StringWithAggregatesFilter<"Currency"> | string
  }

  export type CompanyCurrencyWhereInput = {
    AND?: CompanyCurrencyWhereInput | CompanyCurrencyWhereInput[]
    OR?: CompanyCurrencyWhereInput[]
    NOT?: CompanyCurrencyWhereInput | CompanyCurrencyWhereInput[]
    id?: IntFilter<"CompanyCurrency"> | number
    companyId?: IntFilter<"CompanyCurrency"> | number
    currencyId?: IntFilter<"CompanyCurrency"> | number
    exchangeRate?: FloatFilter<"CompanyCurrency"> | number
    isDefault?: BoolFilter<"CompanyCurrency"> | boolean
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    currency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
  }

  export type CompanyCurrencyOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    currencyId?: SortOrder
    exchangeRate?: SortOrder
    isDefault?: SortOrder
    company?: CompanyOrderByWithRelationInput
    currency?: CurrencyOrderByWithRelationInput
  }

  export type CompanyCurrencyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    companyId_currencyId?: CompanyCurrencyCompanyIdCurrencyIdCompoundUniqueInput
    AND?: CompanyCurrencyWhereInput | CompanyCurrencyWhereInput[]
    OR?: CompanyCurrencyWhereInput[]
    NOT?: CompanyCurrencyWhereInput | CompanyCurrencyWhereInput[]
    companyId?: IntFilter<"CompanyCurrency"> | number
    currencyId?: IntFilter<"CompanyCurrency"> | number
    exchangeRate?: FloatFilter<"CompanyCurrency"> | number
    isDefault?: BoolFilter<"CompanyCurrency"> | boolean
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    currency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
  }, "id" | "companyId_currencyId">

  export type CompanyCurrencyOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    currencyId?: SortOrder
    exchangeRate?: SortOrder
    isDefault?: SortOrder
    _count?: CompanyCurrencyCountOrderByAggregateInput
    _avg?: CompanyCurrencyAvgOrderByAggregateInput
    _max?: CompanyCurrencyMaxOrderByAggregateInput
    _min?: CompanyCurrencyMinOrderByAggregateInput
    _sum?: CompanyCurrencySumOrderByAggregateInput
  }

  export type CompanyCurrencyScalarWhereWithAggregatesInput = {
    AND?: CompanyCurrencyScalarWhereWithAggregatesInput | CompanyCurrencyScalarWhereWithAggregatesInput[]
    OR?: CompanyCurrencyScalarWhereWithAggregatesInput[]
    NOT?: CompanyCurrencyScalarWhereWithAggregatesInput | CompanyCurrencyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CompanyCurrency"> | number
    companyId?: IntWithAggregatesFilter<"CompanyCurrency"> | number
    currencyId?: IntWithAggregatesFilter<"CompanyCurrency"> | number
    exchangeRate?: FloatWithAggregatesFilter<"CompanyCurrency"> | number
    isDefault?: BoolWithAggregatesFilter<"CompanyCurrency"> | boolean
  }

  export type TaxSettingWhereInput = {
    AND?: TaxSettingWhereInput | TaxSettingWhereInput[]
    OR?: TaxSettingWhereInput[]
    NOT?: TaxSettingWhereInput | TaxSettingWhereInput[]
    id?: IntFilter<"TaxSetting"> | number
    name?: StringFilter<"TaxSetting"> | string
    percentage?: FloatFilter<"TaxSetting"> | number
    type?: StringFilter<"TaxSetting"> | string
    companyId?: IntFilter<"TaxSetting"> | number
    branchId?: IntNullableFilter<"TaxSetting"> | number | null
    createdAt?: DateTimeFilter<"TaxSetting"> | Date | string
    updatedAt?: DateTimeFilter<"TaxSetting"> | Date | string
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type TaxSettingOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    percentage?: SortOrder
    type?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type TaxSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TaxSettingWhereInput | TaxSettingWhereInput[]
    OR?: TaxSettingWhereInput[]
    NOT?: TaxSettingWhereInput | TaxSettingWhereInput[]
    name?: StringFilter<"TaxSetting"> | string
    percentage?: FloatFilter<"TaxSetting"> | number
    type?: StringFilter<"TaxSetting"> | string
    companyId?: IntFilter<"TaxSetting"> | number
    branchId?: IntNullableFilter<"TaxSetting"> | number | null
    createdAt?: DateTimeFilter<"TaxSetting"> | Date | string
    updatedAt?: DateTimeFilter<"TaxSetting"> | Date | string
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id">

  export type TaxSettingOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    percentage?: SortOrder
    type?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaxSettingCountOrderByAggregateInput
    _avg?: TaxSettingAvgOrderByAggregateInput
    _max?: TaxSettingMaxOrderByAggregateInput
    _min?: TaxSettingMinOrderByAggregateInput
    _sum?: TaxSettingSumOrderByAggregateInput
  }

  export type TaxSettingScalarWhereWithAggregatesInput = {
    AND?: TaxSettingScalarWhereWithAggregatesInput | TaxSettingScalarWhereWithAggregatesInput[]
    OR?: TaxSettingScalarWhereWithAggregatesInput[]
    NOT?: TaxSettingScalarWhereWithAggregatesInput | TaxSettingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaxSetting"> | number
    name?: StringWithAggregatesFilter<"TaxSetting"> | string
    percentage?: FloatWithAggregatesFilter<"TaxSetting"> | number
    type?: StringWithAggregatesFilter<"TaxSetting"> | string
    companyId?: IntWithAggregatesFilter<"TaxSetting"> | number
    branchId?: IntNullableWithAggregatesFilter<"TaxSetting"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"TaxSetting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TaxSetting"> | Date | string
  }

  export type SystemSettingWhereInput = {
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    id?: IntFilter<"SystemSetting"> | number
    key?: StringFilter<"SystemSetting"> | string
    value?: StringFilter<"SystemSetting"> | string
    type?: StringFilter<"SystemSetting"> | string
    companyId?: IntFilter<"SystemSetting"> | number
    createdAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type SystemSettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type SystemSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    companyId_key?: SystemSettingCompanyIdKeyCompoundUniqueInput
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    key?: StringFilter<"SystemSetting"> | string
    value?: StringFilter<"SystemSetting"> | string
    type?: StringFilter<"SystemSetting"> | string
    companyId?: IntFilter<"SystemSetting"> | number
    createdAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "companyId_key">

  export type SystemSettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemSettingCountOrderByAggregateInput
    _avg?: SystemSettingAvgOrderByAggregateInput
    _max?: SystemSettingMaxOrderByAggregateInput
    _min?: SystemSettingMinOrderByAggregateInput
    _sum?: SystemSettingSumOrderByAggregateInput
  }

  export type SystemSettingScalarWhereWithAggregatesInput = {
    AND?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    OR?: SystemSettingScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SystemSetting"> | number
    key?: StringWithAggregatesFilter<"SystemSetting"> | string
    value?: StringWithAggregatesFilter<"SystemSetting"> | string
    type?: StringWithAggregatesFilter<"SystemSetting"> | string
    companyId?: IntWithAggregatesFilter<"SystemSetting"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    companyId?: IntNullableFilter<"User"> | number | null
    branch?: StringNullableFilter<"User"> | string | null
    department?: StringNullableFilter<"User"> | string | null
    region?: StringNullableFilter<"User"> | string | null
    division?: StringNullableFilter<"User"> | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    auditLogs?: AuditLogListRelationFilter
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    postedVouchers?: VoucherListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    password?: SortOrder
    role?: SortOrder
    companyId?: SortOrderInput | SortOrder
    branch?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    division?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    auditLogs?: AuditLogOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
    postedVouchers?: VoucherOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    companyId?: IntNullableFilter<"User"> | number | null
    branch?: StringNullableFilter<"User"> | string | null
    department?: StringNullableFilter<"User"> | string | null
    region?: StringNullableFilter<"User"> | string | null
    division?: StringNullableFilter<"User"> | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    auditLogs?: AuditLogListRelationFilter
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    postedVouchers?: VoucherListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    password?: SortOrder
    role?: SortOrder
    companyId?: SortOrderInput | SortOrder
    branch?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    division?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    companyId?: IntNullableWithAggregatesFilter<"User"> | number | null
    branch?: StringNullableWithAggregatesFilter<"User"> | string | null
    department?: StringNullableWithAggregatesFilter<"User"> | string | null
    region?: StringNullableWithAggregatesFilter<"User"> | string | null
    division?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: IntFilter<"Customer"> | number
    name?: StringFilter<"Customer"> | string
    code?: StringFilter<"Customer"> | string
    address?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    taxNumber?: StringNullableFilter<"Customer"> | string | null
    accountId?: IntNullableFilter<"Customer"> | number | null
    companyId?: IntFilter<"Customer"> | number
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    division?: StringNullableFilter<"Customer"> | string | null
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    serviceInvoices?: ServiceInvoiceListRelationFilter
    freightInvoices?: FreightInvoiceListRelationFilter
    jobs?: JobListRelationFilter
    payments?: PaymentListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    taxNumber?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    division?: SortOrderInput | SortOrder
    account?: AccountOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    serviceInvoices?: ServiceInvoiceOrderByRelationAggregateInput
    freightInvoices?: FreightInvoiceOrderByRelationAggregateInput
    jobs?: JobOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    accountId?: number
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringFilter<"Customer"> | string
    address?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    taxNumber?: StringNullableFilter<"Customer"> | string | null
    companyId?: IntFilter<"Customer"> | number
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    division?: StringNullableFilter<"Customer"> | string | null
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    serviceInvoices?: ServiceInvoiceListRelationFilter
    freightInvoices?: FreightInvoiceListRelationFilter
    jobs?: JobListRelationFilter
    payments?: PaymentListRelationFilter
  }, "id" | "code" | "accountId">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    taxNumber?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    division?: SortOrderInput | SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Customer"> | number
    name?: StringWithAggregatesFilter<"Customer"> | string
    code?: StringWithAggregatesFilter<"Customer"> | string
    address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    taxNumber?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    accountId?: IntNullableWithAggregatesFilter<"Customer"> | number | null
    companyId?: IntWithAggregatesFilter<"Customer"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    division?: StringNullableWithAggregatesFilter<"Customer"> | string | null
  }

  export type VendorWhereInput = {
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    id?: IntFilter<"Vendor"> | number
    name?: StringFilter<"Vendor"> | string
    code?: StringFilter<"Vendor"> | string
    type?: StringNullableFilter<"Vendor"> | string | null
    address?: StringNullableFilter<"Vendor"> | string | null
    phone?: StringNullableFilter<"Vendor"> | string | null
    email?: StringNullableFilter<"Vendor"> | string | null
    taxNumber?: StringNullableFilter<"Vendor"> | string | null
    accountId?: IntNullableFilter<"Vendor"> | number | null
    companyId?: IntFilter<"Vendor"> | number
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
    division?: StringNullableFilter<"Vendor"> | string | null
    expenses?: ExpenseListRelationFilter
    payments?: PaymentListRelationFilter
    purchaseInvoices?: PurchaseInvoiceListRelationFilter
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    freightItems?: FreightInvoiceItemListRelationFilter
  }

  export type VendorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    type?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    taxNumber?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    division?: SortOrderInput | SortOrder
    expenses?: ExpenseOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    purchaseInvoices?: PurchaseInvoiceOrderByRelationAggregateInput
    account?: AccountOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    freightItems?: FreightInvoiceItemOrderByRelationAggregateInput
  }

  export type VendorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    accountId?: number
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    name?: StringFilter<"Vendor"> | string
    type?: StringNullableFilter<"Vendor"> | string | null
    address?: StringNullableFilter<"Vendor"> | string | null
    phone?: StringNullableFilter<"Vendor"> | string | null
    email?: StringNullableFilter<"Vendor"> | string | null
    taxNumber?: StringNullableFilter<"Vendor"> | string | null
    companyId?: IntFilter<"Vendor"> | number
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
    division?: StringNullableFilter<"Vendor"> | string | null
    expenses?: ExpenseListRelationFilter
    payments?: PaymentListRelationFilter
    purchaseInvoices?: PurchaseInvoiceListRelationFilter
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    freightItems?: FreightInvoiceItemListRelationFilter
  }, "id" | "code" | "accountId">

  export type VendorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    type?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    taxNumber?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    division?: SortOrderInput | SortOrder
    _count?: VendorCountOrderByAggregateInput
    _avg?: VendorAvgOrderByAggregateInput
    _max?: VendorMaxOrderByAggregateInput
    _min?: VendorMinOrderByAggregateInput
    _sum?: VendorSumOrderByAggregateInput
  }

  export type VendorScalarWhereWithAggregatesInput = {
    AND?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    OR?: VendorScalarWhereWithAggregatesInput[]
    NOT?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Vendor"> | number
    name?: StringWithAggregatesFilter<"Vendor"> | string
    code?: StringWithAggregatesFilter<"Vendor"> | string
    type?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    address?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    email?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    taxNumber?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    accountId?: IntNullableWithAggregatesFilter<"Vendor"> | number | null
    companyId?: IntWithAggregatesFilter<"Vendor"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
    division?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
  }

  export type JobWhereInput = {
    AND?: JobWhereInput | JobWhereInput[]
    OR?: JobWhereInput[]
    NOT?: JobWhereInput | JobWhereInput[]
    id?: IntFilter<"Job"> | number
    jobNumber?: StringFilter<"Job"> | string
    date?: DateTimeFilter<"Job"> | Date | string
    jobDate?: DateTimeFilter<"Job"> | Date | string
    jobType?: EnumJobTypeFilter<"Job"> | $Enums.JobType
    status?: EnumJobStatusFilter<"Job"> | $Enums.JobStatus
    customerId?: IntFilter<"Job"> | number
    vessel?: StringNullableFilter<"Job"> | string | null
    place?: StringNullableFilter<"Job"> | string | null
    shipperRef?: StringNullableFilter<"Job"> | string | null
    gdNo?: StringNullableFilter<"Job"> | string | null
    gdDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    formE?: StringNullableFilter<"Job"> | string | null
    formEDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    commodity?: StringNullableFilter<"Job"> | string | null
    volume?: StringNullableFilter<"Job"> | string | null
    containerNo?: StringNullableFilter<"Job"> | string | null
    podId?: IntNullableFilter<"Job"> | number | null
    packages?: IntNullableFilter<"Job"> | number | null
    weight?: FloatNullableFilter<"Job"> | number | null
    hawbBl?: StringNullableFilter<"Job"> | string | null
    handledBy?: StringNullableFilter<"Job"> | string | null
    salesPerson?: StringNullableFilter<"Job"> | string | null
    companyId?: IntFilter<"Job"> | number
    branchId?: IntNullableFilter<"Job"> | number | null
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    division?: StringNullableFilter<"Job"> | string | null
    expenses?: ExpenseListRelationFilter
    serviceInvoice?: XOR<ServiceInvoiceNullableScalarRelationFilter, ServiceInvoiceWhereInput> | null
    freightInvoice?: XOR<FreightInvoiceNullableScalarRelationFilter, FreightInvoiceWhereInput> | null
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    pod?: XOR<PortNullableScalarRelationFilter, PortWhereInput> | null
  }

  export type JobOrderByWithRelationInput = {
    id?: SortOrder
    jobNumber?: SortOrder
    date?: SortOrder
    jobDate?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    customerId?: SortOrder
    vessel?: SortOrderInput | SortOrder
    place?: SortOrderInput | SortOrder
    shipperRef?: SortOrderInput | SortOrder
    gdNo?: SortOrderInput | SortOrder
    gdDate?: SortOrderInput | SortOrder
    formE?: SortOrderInput | SortOrder
    formEDate?: SortOrderInput | SortOrder
    commodity?: SortOrderInput | SortOrder
    volume?: SortOrderInput | SortOrder
    containerNo?: SortOrderInput | SortOrder
    podId?: SortOrderInput | SortOrder
    packages?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    hawbBl?: SortOrderInput | SortOrder
    handledBy?: SortOrderInput | SortOrder
    salesPerson?: SortOrderInput | SortOrder
    companyId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    division?: SortOrderInput | SortOrder
    expenses?: ExpenseOrderByRelationAggregateInput
    serviceInvoice?: ServiceInvoiceOrderByWithRelationInput
    freightInvoice?: FreightInvoiceOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    pod?: PortOrderByWithRelationInput
  }

  export type JobWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    jobNumber?: string
    AND?: JobWhereInput | JobWhereInput[]
    OR?: JobWhereInput[]
    NOT?: JobWhereInput | JobWhereInput[]
    date?: DateTimeFilter<"Job"> | Date | string
    jobDate?: DateTimeFilter<"Job"> | Date | string
    jobType?: EnumJobTypeFilter<"Job"> | $Enums.JobType
    status?: EnumJobStatusFilter<"Job"> | $Enums.JobStatus
    customerId?: IntFilter<"Job"> | number
    vessel?: StringNullableFilter<"Job"> | string | null
    place?: StringNullableFilter<"Job"> | string | null
    shipperRef?: StringNullableFilter<"Job"> | string | null
    gdNo?: StringNullableFilter<"Job"> | string | null
    gdDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    formE?: StringNullableFilter<"Job"> | string | null
    formEDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    commodity?: StringNullableFilter<"Job"> | string | null
    volume?: StringNullableFilter<"Job"> | string | null
    containerNo?: StringNullableFilter<"Job"> | string | null
    podId?: IntNullableFilter<"Job"> | number | null
    packages?: IntNullableFilter<"Job"> | number | null
    weight?: FloatNullableFilter<"Job"> | number | null
    hawbBl?: StringNullableFilter<"Job"> | string | null
    handledBy?: StringNullableFilter<"Job"> | string | null
    salesPerson?: StringNullableFilter<"Job"> | string | null
    companyId?: IntFilter<"Job"> | number
    branchId?: IntNullableFilter<"Job"> | number | null
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    division?: StringNullableFilter<"Job"> | string | null
    expenses?: ExpenseListRelationFilter
    serviceInvoice?: XOR<ServiceInvoiceNullableScalarRelationFilter, ServiceInvoiceWhereInput> | null
    freightInvoice?: XOR<FreightInvoiceNullableScalarRelationFilter, FreightInvoiceWhereInput> | null
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    pod?: XOR<PortNullableScalarRelationFilter, PortWhereInput> | null
  }, "id" | "jobNumber">

  export type JobOrderByWithAggregationInput = {
    id?: SortOrder
    jobNumber?: SortOrder
    date?: SortOrder
    jobDate?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    customerId?: SortOrder
    vessel?: SortOrderInput | SortOrder
    place?: SortOrderInput | SortOrder
    shipperRef?: SortOrderInput | SortOrder
    gdNo?: SortOrderInput | SortOrder
    gdDate?: SortOrderInput | SortOrder
    formE?: SortOrderInput | SortOrder
    formEDate?: SortOrderInput | SortOrder
    commodity?: SortOrderInput | SortOrder
    volume?: SortOrderInput | SortOrder
    containerNo?: SortOrderInput | SortOrder
    podId?: SortOrderInput | SortOrder
    packages?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    hawbBl?: SortOrderInput | SortOrder
    handledBy?: SortOrderInput | SortOrder
    salesPerson?: SortOrderInput | SortOrder
    companyId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    division?: SortOrderInput | SortOrder
    _count?: JobCountOrderByAggregateInput
    _avg?: JobAvgOrderByAggregateInput
    _max?: JobMaxOrderByAggregateInput
    _min?: JobMinOrderByAggregateInput
    _sum?: JobSumOrderByAggregateInput
  }

  export type JobScalarWhereWithAggregatesInput = {
    AND?: JobScalarWhereWithAggregatesInput | JobScalarWhereWithAggregatesInput[]
    OR?: JobScalarWhereWithAggregatesInput[]
    NOT?: JobScalarWhereWithAggregatesInput | JobScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Job"> | number
    jobNumber?: StringWithAggregatesFilter<"Job"> | string
    date?: DateTimeWithAggregatesFilter<"Job"> | Date | string
    jobDate?: DateTimeWithAggregatesFilter<"Job"> | Date | string
    jobType?: EnumJobTypeWithAggregatesFilter<"Job"> | $Enums.JobType
    status?: EnumJobStatusWithAggregatesFilter<"Job"> | $Enums.JobStatus
    customerId?: IntWithAggregatesFilter<"Job"> | number
    vessel?: StringNullableWithAggregatesFilter<"Job"> | string | null
    place?: StringNullableWithAggregatesFilter<"Job"> | string | null
    shipperRef?: StringNullableWithAggregatesFilter<"Job"> | string | null
    gdNo?: StringNullableWithAggregatesFilter<"Job"> | string | null
    gdDate?: DateTimeNullableWithAggregatesFilter<"Job"> | Date | string | null
    formE?: StringNullableWithAggregatesFilter<"Job"> | string | null
    formEDate?: DateTimeNullableWithAggregatesFilter<"Job"> | Date | string | null
    commodity?: StringNullableWithAggregatesFilter<"Job"> | string | null
    volume?: StringNullableWithAggregatesFilter<"Job"> | string | null
    containerNo?: StringNullableWithAggregatesFilter<"Job"> | string | null
    podId?: IntNullableWithAggregatesFilter<"Job"> | number | null
    packages?: IntNullableWithAggregatesFilter<"Job"> | number | null
    weight?: FloatNullableWithAggregatesFilter<"Job"> | number | null
    hawbBl?: StringNullableWithAggregatesFilter<"Job"> | string | null
    handledBy?: StringNullableWithAggregatesFilter<"Job"> | string | null
    salesPerson?: StringNullableWithAggregatesFilter<"Job"> | string | null
    companyId?: IntWithAggregatesFilter<"Job"> | number
    branchId?: IntNullableWithAggregatesFilter<"Job"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Job"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Job"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Job"> | Date | string | null
    division?: StringNullableWithAggregatesFilter<"Job"> | string | null
  }

  export type ExpenseMasterWhereInput = {
    AND?: ExpenseMasterWhereInput | ExpenseMasterWhereInput[]
    OR?: ExpenseMasterWhereInput[]
    NOT?: ExpenseMasterWhereInput | ExpenseMasterWhereInput[]
    id?: IntFilter<"ExpenseMaster"> | number
    code?: StringFilter<"ExpenseMaster"> | string
    name?: StringFilter<"ExpenseMaster"> | string
    companyId?: IntFilter<"ExpenseMaster"> | number
    createdAt?: DateTimeFilter<"ExpenseMaster"> | Date | string
    updatedAt?: DateTimeFilter<"ExpenseMaster"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type ExpenseMasterOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type ExpenseMasterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    companyId_code?: ExpenseMasterCompanyIdCodeCompoundUniqueInput
    AND?: ExpenseMasterWhereInput | ExpenseMasterWhereInput[]
    OR?: ExpenseMasterWhereInput[]
    NOT?: ExpenseMasterWhereInput | ExpenseMasterWhereInput[]
    code?: StringFilter<"ExpenseMaster"> | string
    name?: StringFilter<"ExpenseMaster"> | string
    companyId?: IntFilter<"ExpenseMaster"> | number
    createdAt?: DateTimeFilter<"ExpenseMaster"> | Date | string
    updatedAt?: DateTimeFilter<"ExpenseMaster"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "companyId_code">

  export type ExpenseMasterOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExpenseMasterCountOrderByAggregateInput
    _avg?: ExpenseMasterAvgOrderByAggregateInput
    _max?: ExpenseMasterMaxOrderByAggregateInput
    _min?: ExpenseMasterMinOrderByAggregateInput
    _sum?: ExpenseMasterSumOrderByAggregateInput
  }

  export type ExpenseMasterScalarWhereWithAggregatesInput = {
    AND?: ExpenseMasterScalarWhereWithAggregatesInput | ExpenseMasterScalarWhereWithAggregatesInput[]
    OR?: ExpenseMasterScalarWhereWithAggregatesInput[]
    NOT?: ExpenseMasterScalarWhereWithAggregatesInput | ExpenseMasterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ExpenseMaster"> | number
    code?: StringWithAggregatesFilter<"ExpenseMaster"> | string
    name?: StringWithAggregatesFilter<"ExpenseMaster"> | string
    companyId?: IntWithAggregatesFilter<"ExpenseMaster"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ExpenseMaster"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExpenseMaster"> | Date | string
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    id?: IntFilter<"Expense"> | number
    jobId?: IntFilter<"Expense"> | number
    vendorId?: IntNullableFilter<"Expense"> | number | null
    description?: StringFilter<"Expense"> | string
    costPrice?: FloatFilter<"Expense"> | number
    sellingPrice?: FloatFilter<"Expense"> | number
    currencyCode?: StringFilter<"Expense"> | string
    exchangeRate?: FloatFilter<"Expense"> | number
    companyId?: IntFilter<"Expense"> | number
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    job?: XOR<JobScalarRelationFilter, JobWhereInput>
    vendor?: XOR<VendorNullableScalarRelationFilter, VendorWhereInput> | null
  }

  export type ExpenseOrderByWithRelationInput = {
    id?: SortOrder
    jobId?: SortOrder
    vendorId?: SortOrderInput | SortOrder
    description?: SortOrder
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    currencyCode?: SortOrder
    exchangeRate?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    job?: JobOrderByWithRelationInput
    vendor?: VendorOrderByWithRelationInput
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    jobId?: IntFilter<"Expense"> | number
    vendorId?: IntNullableFilter<"Expense"> | number | null
    description?: StringFilter<"Expense"> | string
    costPrice?: FloatFilter<"Expense"> | number
    sellingPrice?: FloatFilter<"Expense"> | number
    currencyCode?: StringFilter<"Expense"> | string
    exchangeRate?: FloatFilter<"Expense"> | number
    companyId?: IntFilter<"Expense"> | number
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    job?: XOR<JobScalarRelationFilter, JobWhereInput>
    vendor?: XOR<VendorNullableScalarRelationFilter, VendorWhereInput> | null
  }, "id">

  export type ExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    jobId?: SortOrder
    vendorId?: SortOrderInput | SortOrder
    description?: SortOrder
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    currencyCode?: SortOrder
    exchangeRate?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Expense"> | number
    jobId?: IntWithAggregatesFilter<"Expense"> | number
    vendorId?: IntNullableWithAggregatesFilter<"Expense"> | number | null
    description?: StringWithAggregatesFilter<"Expense"> | string
    costPrice?: FloatWithAggregatesFilter<"Expense"> | number
    sellingPrice?: FloatWithAggregatesFilter<"Expense"> | number
    currencyCode?: StringWithAggregatesFilter<"Expense"> | string
    exchangeRate?: FloatWithAggregatesFilter<"Expense"> | number
    companyId?: IntWithAggregatesFilter<"Expense"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
  }

  export type ServiceInvoiceWhereInput = {
    AND?: ServiceInvoiceWhereInput | ServiceInvoiceWhereInput[]
    OR?: ServiceInvoiceWhereInput[]
    NOT?: ServiceInvoiceWhereInput | ServiceInvoiceWhereInput[]
    id?: IntFilter<"ServiceInvoice"> | number
    invoiceNumber?: StringFilter<"ServiceInvoice"> | string
    date?: DateTimeFilter<"ServiceInvoice"> | Date | string
    jobId?: IntFilter<"ServiceInvoice"> | number
    customerId?: IntFilter<"ServiceInvoice"> | number
    type?: EnumInvoiceTypeFilter<"ServiceInvoice"> | $Enums.InvoiceType
    status?: EnumInvoiceStatusFilter<"ServiceInvoice"> | $Enums.InvoiceStatus
    masterNumber?: StringNullableFilter<"ServiceInvoice"> | string | null
    agentCode?: StringNullableFilter<"ServiceInvoice"> | string | null
    shippingLine?: StringNullableFilter<"ServiceInvoice"> | string | null
    origin?: StringNullableFilter<"ServiceInvoice"> | string | null
    destination?: StringNullableFilter<"ServiceInvoice"> | string | null
    creditDays?: IntNullableFilter<"ServiceInvoice"> | number | null
    vendorType?: StringNullableFilter<"ServiceInvoice"> | string | null
    totalAmount?: FloatFilter<"ServiceInvoice"> | number
    taxAmount?: FloatFilter<"ServiceInvoice"> | number
    grandTotal?: FloatFilter<"ServiceInvoice"> | number
    currencyCode?: StringFilter<"ServiceInvoice"> | string
    exchangeRate?: FloatFilter<"ServiceInvoice"> | number
    isApproved?: BoolFilter<"ServiceInvoice"> | boolean
    approvedById?: IntNullableFilter<"ServiceInvoice"> | number | null
    isLocked?: BoolFilter<"ServiceInvoice"> | boolean
    lockedAt?: DateTimeNullableFilter<"ServiceInvoice"> | Date | string | null
    companyId?: IntFilter<"ServiceInvoice"> | number
    createdAt?: DateTimeFilter<"ServiceInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceInvoice"> | Date | string
    transactionId?: IntNullableFilter<"ServiceInvoice"> | number | null
    division?: StringNullableFilter<"ServiceInvoice"> | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    job?: XOR<JobScalarRelationFilter, JobWhereInput>
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
    items?: ServiceInvoiceItemListRelationFilter
  }

  export type ServiceInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    date?: SortOrder
    jobId?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    masterNumber?: SortOrderInput | SortOrder
    agentCode?: SortOrderInput | SortOrder
    shippingLine?: SortOrderInput | SortOrder
    origin?: SortOrderInput | SortOrder
    destination?: SortOrderInput | SortOrder
    creditDays?: SortOrderInput | SortOrder
    vendorType?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    grandTotal?: SortOrder
    currencyCode?: SortOrder
    exchangeRate?: SortOrder
    isApproved?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    isLocked?: SortOrder
    lockedAt?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    division?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    job?: JobOrderByWithRelationInput
    transaction?: TransactionOrderByWithRelationInput
    items?: ServiceInvoiceItemOrderByRelationAggregateInput
  }

  export type ServiceInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    jobId?: number
    transactionId?: number
    companyId_invoiceNumber?: ServiceInvoiceCompanyIdInvoiceNumberCompoundUniqueInput
    AND?: ServiceInvoiceWhereInput | ServiceInvoiceWhereInput[]
    OR?: ServiceInvoiceWhereInput[]
    NOT?: ServiceInvoiceWhereInput | ServiceInvoiceWhereInput[]
    invoiceNumber?: StringFilter<"ServiceInvoice"> | string
    date?: DateTimeFilter<"ServiceInvoice"> | Date | string
    customerId?: IntFilter<"ServiceInvoice"> | number
    type?: EnumInvoiceTypeFilter<"ServiceInvoice"> | $Enums.InvoiceType
    status?: EnumInvoiceStatusFilter<"ServiceInvoice"> | $Enums.InvoiceStatus
    masterNumber?: StringNullableFilter<"ServiceInvoice"> | string | null
    agentCode?: StringNullableFilter<"ServiceInvoice"> | string | null
    shippingLine?: StringNullableFilter<"ServiceInvoice"> | string | null
    origin?: StringNullableFilter<"ServiceInvoice"> | string | null
    destination?: StringNullableFilter<"ServiceInvoice"> | string | null
    creditDays?: IntNullableFilter<"ServiceInvoice"> | number | null
    vendorType?: StringNullableFilter<"ServiceInvoice"> | string | null
    totalAmount?: FloatFilter<"ServiceInvoice"> | number
    taxAmount?: FloatFilter<"ServiceInvoice"> | number
    grandTotal?: FloatFilter<"ServiceInvoice"> | number
    currencyCode?: StringFilter<"ServiceInvoice"> | string
    exchangeRate?: FloatFilter<"ServiceInvoice"> | number
    isApproved?: BoolFilter<"ServiceInvoice"> | boolean
    approvedById?: IntNullableFilter<"ServiceInvoice"> | number | null
    isLocked?: BoolFilter<"ServiceInvoice"> | boolean
    lockedAt?: DateTimeNullableFilter<"ServiceInvoice"> | Date | string | null
    companyId?: IntFilter<"ServiceInvoice"> | number
    createdAt?: DateTimeFilter<"ServiceInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceInvoice"> | Date | string
    division?: StringNullableFilter<"ServiceInvoice"> | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    job?: XOR<JobScalarRelationFilter, JobWhereInput>
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
    items?: ServiceInvoiceItemListRelationFilter
  }, "id" | "jobId" | "transactionId" | "companyId_invoiceNumber">

  export type ServiceInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    date?: SortOrder
    jobId?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    masterNumber?: SortOrderInput | SortOrder
    agentCode?: SortOrderInput | SortOrder
    shippingLine?: SortOrderInput | SortOrder
    origin?: SortOrderInput | SortOrder
    destination?: SortOrderInput | SortOrder
    creditDays?: SortOrderInput | SortOrder
    vendorType?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    grandTotal?: SortOrder
    currencyCode?: SortOrder
    exchangeRate?: SortOrder
    isApproved?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    isLocked?: SortOrder
    lockedAt?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    division?: SortOrderInput | SortOrder
    _count?: ServiceInvoiceCountOrderByAggregateInput
    _avg?: ServiceInvoiceAvgOrderByAggregateInput
    _max?: ServiceInvoiceMaxOrderByAggregateInput
    _min?: ServiceInvoiceMinOrderByAggregateInput
    _sum?: ServiceInvoiceSumOrderByAggregateInput
  }

  export type ServiceInvoiceScalarWhereWithAggregatesInput = {
    AND?: ServiceInvoiceScalarWhereWithAggregatesInput | ServiceInvoiceScalarWhereWithAggregatesInput[]
    OR?: ServiceInvoiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceInvoiceScalarWhereWithAggregatesInput | ServiceInvoiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ServiceInvoice"> | number
    invoiceNumber?: StringWithAggregatesFilter<"ServiceInvoice"> | string
    date?: DateTimeWithAggregatesFilter<"ServiceInvoice"> | Date | string
    jobId?: IntWithAggregatesFilter<"ServiceInvoice"> | number
    customerId?: IntWithAggregatesFilter<"ServiceInvoice"> | number
    type?: EnumInvoiceTypeWithAggregatesFilter<"ServiceInvoice"> | $Enums.InvoiceType
    status?: EnumInvoiceStatusWithAggregatesFilter<"ServiceInvoice"> | $Enums.InvoiceStatus
    masterNumber?: StringNullableWithAggregatesFilter<"ServiceInvoice"> | string | null
    agentCode?: StringNullableWithAggregatesFilter<"ServiceInvoice"> | string | null
    shippingLine?: StringNullableWithAggregatesFilter<"ServiceInvoice"> | string | null
    origin?: StringNullableWithAggregatesFilter<"ServiceInvoice"> | string | null
    destination?: StringNullableWithAggregatesFilter<"ServiceInvoice"> | string | null
    creditDays?: IntNullableWithAggregatesFilter<"ServiceInvoice"> | number | null
    vendorType?: StringNullableWithAggregatesFilter<"ServiceInvoice"> | string | null
    totalAmount?: FloatWithAggregatesFilter<"ServiceInvoice"> | number
    taxAmount?: FloatWithAggregatesFilter<"ServiceInvoice"> | number
    grandTotal?: FloatWithAggregatesFilter<"ServiceInvoice"> | number
    currencyCode?: StringWithAggregatesFilter<"ServiceInvoice"> | string
    exchangeRate?: FloatWithAggregatesFilter<"ServiceInvoice"> | number
    isApproved?: BoolWithAggregatesFilter<"ServiceInvoice"> | boolean
    approvedById?: IntNullableWithAggregatesFilter<"ServiceInvoice"> | number | null
    isLocked?: BoolWithAggregatesFilter<"ServiceInvoice"> | boolean
    lockedAt?: DateTimeNullableWithAggregatesFilter<"ServiceInvoice"> | Date | string | null
    companyId?: IntWithAggregatesFilter<"ServiceInvoice"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ServiceInvoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceInvoice"> | Date | string
    transactionId?: IntNullableWithAggregatesFilter<"ServiceInvoice"> | number | null
    division?: StringNullableWithAggregatesFilter<"ServiceInvoice"> | string | null
  }

  export type ServiceInvoiceItemWhereInput = {
    AND?: ServiceInvoiceItemWhereInput | ServiceInvoiceItemWhereInput[]
    OR?: ServiceInvoiceItemWhereInput[]
    NOT?: ServiceInvoiceItemWhereInput | ServiceInvoiceItemWhereInput[]
    id?: IntFilter<"ServiceInvoiceItem"> | number
    invoiceId?: IntFilter<"ServiceInvoiceItem"> | number
    description?: StringFilter<"ServiceInvoiceItem"> | string
    quantity?: FloatFilter<"ServiceInvoiceItem"> | number
    rate?: FloatFilter<"ServiceInvoiceItem"> | number
    amount?: FloatFilter<"ServiceInvoiceItem"> | number
    taxPercentage?: FloatFilter<"ServiceInvoiceItem"> | number
    taxAmount?: FloatFilter<"ServiceInvoiceItem"> | number
    total?: FloatFilter<"ServiceInvoiceItem"> | number
    productId?: IntNullableFilter<"ServiceInvoiceItem"> | number | null
    invoice?: XOR<ServiceInvoiceScalarRelationFilter, ServiceInvoiceWhereInput>
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
  }

  export type ServiceInvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    taxPercentage?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    productId?: SortOrderInput | SortOrder
    invoice?: ServiceInvoiceOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type ServiceInvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ServiceInvoiceItemWhereInput | ServiceInvoiceItemWhereInput[]
    OR?: ServiceInvoiceItemWhereInput[]
    NOT?: ServiceInvoiceItemWhereInput | ServiceInvoiceItemWhereInput[]
    invoiceId?: IntFilter<"ServiceInvoiceItem"> | number
    description?: StringFilter<"ServiceInvoiceItem"> | string
    quantity?: FloatFilter<"ServiceInvoiceItem"> | number
    rate?: FloatFilter<"ServiceInvoiceItem"> | number
    amount?: FloatFilter<"ServiceInvoiceItem"> | number
    taxPercentage?: FloatFilter<"ServiceInvoiceItem"> | number
    taxAmount?: FloatFilter<"ServiceInvoiceItem"> | number
    total?: FloatFilter<"ServiceInvoiceItem"> | number
    productId?: IntNullableFilter<"ServiceInvoiceItem"> | number | null
    invoice?: XOR<ServiceInvoiceScalarRelationFilter, ServiceInvoiceWhereInput>
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
  }, "id">

  export type ServiceInvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    taxPercentage?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    productId?: SortOrderInput | SortOrder
    _count?: ServiceInvoiceItemCountOrderByAggregateInput
    _avg?: ServiceInvoiceItemAvgOrderByAggregateInput
    _max?: ServiceInvoiceItemMaxOrderByAggregateInput
    _min?: ServiceInvoiceItemMinOrderByAggregateInput
    _sum?: ServiceInvoiceItemSumOrderByAggregateInput
  }

  export type ServiceInvoiceItemScalarWhereWithAggregatesInput = {
    AND?: ServiceInvoiceItemScalarWhereWithAggregatesInput | ServiceInvoiceItemScalarWhereWithAggregatesInput[]
    OR?: ServiceInvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: ServiceInvoiceItemScalarWhereWithAggregatesInput | ServiceInvoiceItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ServiceInvoiceItem"> | number
    invoiceId?: IntWithAggregatesFilter<"ServiceInvoiceItem"> | number
    description?: StringWithAggregatesFilter<"ServiceInvoiceItem"> | string
    quantity?: FloatWithAggregatesFilter<"ServiceInvoiceItem"> | number
    rate?: FloatWithAggregatesFilter<"ServiceInvoiceItem"> | number
    amount?: FloatWithAggregatesFilter<"ServiceInvoiceItem"> | number
    taxPercentage?: FloatWithAggregatesFilter<"ServiceInvoiceItem"> | number
    taxAmount?: FloatWithAggregatesFilter<"ServiceInvoiceItem"> | number
    total?: FloatWithAggregatesFilter<"ServiceInvoiceItem"> | number
    productId?: IntNullableWithAggregatesFilter<"ServiceInvoiceItem"> | number | null
  }

  export type FreightInvoiceWhereInput = {
    AND?: FreightInvoiceWhereInput | FreightInvoiceWhereInput[]
    OR?: FreightInvoiceWhereInput[]
    NOT?: FreightInvoiceWhereInput | FreightInvoiceWhereInput[]
    id?: IntFilter<"FreightInvoice"> | number
    invoiceNumber?: StringFilter<"FreightInvoice"> | string
    date?: DateTimeFilter<"FreightInvoice"> | Date | string
    jobId?: IntNullableFilter<"FreightInvoice"> | number | null
    customerId?: IntFilter<"FreightInvoice"> | number
    type?: EnumInvoiceTypeFilter<"FreightInvoice"> | $Enums.InvoiceType
    status?: EnumInvoiceStatusFilter<"FreightInvoice"> | $Enums.InvoiceStatus
    usdRate?: FloatFilter<"FreightInvoice"> | number
    exchangeRate?: FloatFilter<"FreightInvoice"> | number
    totalAmount?: FloatFilter<"FreightInvoice"> | number
    taxAmount?: FloatFilter<"FreightInvoice"> | number
    grandTotal?: FloatFilter<"FreightInvoice"> | number
    currencyCode?: StringFilter<"FreightInvoice"> | string
    isApproved?: BoolFilter<"FreightInvoice"> | boolean
    approvedById?: IntNullableFilter<"FreightInvoice"> | number | null
    isLocked?: BoolFilter<"FreightInvoice"> | boolean
    lockedAt?: DateTimeNullableFilter<"FreightInvoice"> | Date | string | null
    companyId?: IntFilter<"FreightInvoice"> | number
    createdAt?: DateTimeFilter<"FreightInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"FreightInvoice"> | Date | string
    transactionId?: IntNullableFilter<"FreightInvoice"> | number | null
    division?: StringNullableFilter<"FreightInvoice"> | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
    job?: XOR<JobNullableScalarRelationFilter, JobWhereInput> | null
    items?: FreightInvoiceItemListRelationFilter
  }

  export type FreightInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    date?: SortOrder
    jobId?: SortOrderInput | SortOrder
    customerId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    usdRate?: SortOrder
    exchangeRate?: SortOrder
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    grandTotal?: SortOrder
    currencyCode?: SortOrder
    isApproved?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    isLocked?: SortOrder
    lockedAt?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    division?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    transaction?: TransactionOrderByWithRelationInput
    job?: JobOrderByWithRelationInput
    items?: FreightInvoiceItemOrderByRelationAggregateInput
  }

  export type FreightInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    jobId?: number
    transactionId?: number
    companyId_invoiceNumber?: FreightInvoiceCompanyIdInvoiceNumberCompoundUniqueInput
    AND?: FreightInvoiceWhereInput | FreightInvoiceWhereInput[]
    OR?: FreightInvoiceWhereInput[]
    NOT?: FreightInvoiceWhereInput | FreightInvoiceWhereInput[]
    invoiceNumber?: StringFilter<"FreightInvoice"> | string
    date?: DateTimeFilter<"FreightInvoice"> | Date | string
    customerId?: IntFilter<"FreightInvoice"> | number
    type?: EnumInvoiceTypeFilter<"FreightInvoice"> | $Enums.InvoiceType
    status?: EnumInvoiceStatusFilter<"FreightInvoice"> | $Enums.InvoiceStatus
    usdRate?: FloatFilter<"FreightInvoice"> | number
    exchangeRate?: FloatFilter<"FreightInvoice"> | number
    totalAmount?: FloatFilter<"FreightInvoice"> | number
    taxAmount?: FloatFilter<"FreightInvoice"> | number
    grandTotal?: FloatFilter<"FreightInvoice"> | number
    currencyCode?: StringFilter<"FreightInvoice"> | string
    isApproved?: BoolFilter<"FreightInvoice"> | boolean
    approvedById?: IntNullableFilter<"FreightInvoice"> | number | null
    isLocked?: BoolFilter<"FreightInvoice"> | boolean
    lockedAt?: DateTimeNullableFilter<"FreightInvoice"> | Date | string | null
    companyId?: IntFilter<"FreightInvoice"> | number
    createdAt?: DateTimeFilter<"FreightInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"FreightInvoice"> | Date | string
    division?: StringNullableFilter<"FreightInvoice"> | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
    job?: XOR<JobNullableScalarRelationFilter, JobWhereInput> | null
    items?: FreightInvoiceItemListRelationFilter
  }, "id" | "jobId" | "transactionId" | "companyId_invoiceNumber">

  export type FreightInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    date?: SortOrder
    jobId?: SortOrderInput | SortOrder
    customerId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    usdRate?: SortOrder
    exchangeRate?: SortOrder
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    grandTotal?: SortOrder
    currencyCode?: SortOrder
    isApproved?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    isLocked?: SortOrder
    lockedAt?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    division?: SortOrderInput | SortOrder
    _count?: FreightInvoiceCountOrderByAggregateInput
    _avg?: FreightInvoiceAvgOrderByAggregateInput
    _max?: FreightInvoiceMaxOrderByAggregateInput
    _min?: FreightInvoiceMinOrderByAggregateInput
    _sum?: FreightInvoiceSumOrderByAggregateInput
  }

  export type FreightInvoiceScalarWhereWithAggregatesInput = {
    AND?: FreightInvoiceScalarWhereWithAggregatesInput | FreightInvoiceScalarWhereWithAggregatesInput[]
    OR?: FreightInvoiceScalarWhereWithAggregatesInput[]
    NOT?: FreightInvoiceScalarWhereWithAggregatesInput | FreightInvoiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FreightInvoice"> | number
    invoiceNumber?: StringWithAggregatesFilter<"FreightInvoice"> | string
    date?: DateTimeWithAggregatesFilter<"FreightInvoice"> | Date | string
    jobId?: IntNullableWithAggregatesFilter<"FreightInvoice"> | number | null
    customerId?: IntWithAggregatesFilter<"FreightInvoice"> | number
    type?: EnumInvoiceTypeWithAggregatesFilter<"FreightInvoice"> | $Enums.InvoiceType
    status?: EnumInvoiceStatusWithAggregatesFilter<"FreightInvoice"> | $Enums.InvoiceStatus
    usdRate?: FloatWithAggregatesFilter<"FreightInvoice"> | number
    exchangeRate?: FloatWithAggregatesFilter<"FreightInvoice"> | number
    totalAmount?: FloatWithAggregatesFilter<"FreightInvoice"> | number
    taxAmount?: FloatWithAggregatesFilter<"FreightInvoice"> | number
    grandTotal?: FloatWithAggregatesFilter<"FreightInvoice"> | number
    currencyCode?: StringWithAggregatesFilter<"FreightInvoice"> | string
    isApproved?: BoolWithAggregatesFilter<"FreightInvoice"> | boolean
    approvedById?: IntNullableWithAggregatesFilter<"FreightInvoice"> | number | null
    isLocked?: BoolWithAggregatesFilter<"FreightInvoice"> | boolean
    lockedAt?: DateTimeNullableWithAggregatesFilter<"FreightInvoice"> | Date | string | null
    companyId?: IntWithAggregatesFilter<"FreightInvoice"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FreightInvoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FreightInvoice"> | Date | string
    transactionId?: IntNullableWithAggregatesFilter<"FreightInvoice"> | number | null
    division?: StringNullableWithAggregatesFilter<"FreightInvoice"> | string | null
  }

  export type FreightInvoiceItemWhereInput = {
    AND?: FreightInvoiceItemWhereInput | FreightInvoiceItemWhereInput[]
    OR?: FreightInvoiceItemWhereInput[]
    NOT?: FreightInvoiceItemWhereInput | FreightInvoiceItemWhereInput[]
    id?: IntFilter<"FreightInvoiceItem"> | number
    invoiceId?: IntFilter<"FreightInvoiceItem"> | number
    description?: StringFilter<"FreightInvoiceItem"> | string
    quantity?: FloatFilter<"FreightInvoiceItem"> | number
    rate?: FloatFilter<"FreightInvoiceItem"> | number
    amount?: FloatFilter<"FreightInvoiceItem"> | number
    taxPercentage?: FloatFilter<"FreightInvoiceItem"> | number
    taxAmount?: FloatFilter<"FreightInvoiceItem"> | number
    total?: FloatFilter<"FreightInvoiceItem"> | number
    vendorId?: IntNullableFilter<"FreightInvoiceItem"> | number | null
    invoice?: XOR<FreightInvoiceScalarRelationFilter, FreightInvoiceWhereInput>
    vendor?: XOR<VendorNullableScalarRelationFilter, VendorWhereInput> | null
  }

  export type FreightInvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    taxPercentage?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    vendorId?: SortOrderInput | SortOrder
    invoice?: FreightInvoiceOrderByWithRelationInput
    vendor?: VendorOrderByWithRelationInput
  }

  export type FreightInvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FreightInvoiceItemWhereInput | FreightInvoiceItemWhereInput[]
    OR?: FreightInvoiceItemWhereInput[]
    NOT?: FreightInvoiceItemWhereInput | FreightInvoiceItemWhereInput[]
    invoiceId?: IntFilter<"FreightInvoiceItem"> | number
    description?: StringFilter<"FreightInvoiceItem"> | string
    quantity?: FloatFilter<"FreightInvoiceItem"> | number
    rate?: FloatFilter<"FreightInvoiceItem"> | number
    amount?: FloatFilter<"FreightInvoiceItem"> | number
    taxPercentage?: FloatFilter<"FreightInvoiceItem"> | number
    taxAmount?: FloatFilter<"FreightInvoiceItem"> | number
    total?: FloatFilter<"FreightInvoiceItem"> | number
    vendorId?: IntNullableFilter<"FreightInvoiceItem"> | number | null
    invoice?: XOR<FreightInvoiceScalarRelationFilter, FreightInvoiceWhereInput>
    vendor?: XOR<VendorNullableScalarRelationFilter, VendorWhereInput> | null
  }, "id">

  export type FreightInvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    taxPercentage?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    vendorId?: SortOrderInput | SortOrder
    _count?: FreightInvoiceItemCountOrderByAggregateInput
    _avg?: FreightInvoiceItemAvgOrderByAggregateInput
    _max?: FreightInvoiceItemMaxOrderByAggregateInput
    _min?: FreightInvoiceItemMinOrderByAggregateInput
    _sum?: FreightInvoiceItemSumOrderByAggregateInput
  }

  export type FreightInvoiceItemScalarWhereWithAggregatesInput = {
    AND?: FreightInvoiceItemScalarWhereWithAggregatesInput | FreightInvoiceItemScalarWhereWithAggregatesInput[]
    OR?: FreightInvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: FreightInvoiceItemScalarWhereWithAggregatesInput | FreightInvoiceItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FreightInvoiceItem"> | number
    invoiceId?: IntWithAggregatesFilter<"FreightInvoiceItem"> | number
    description?: StringWithAggregatesFilter<"FreightInvoiceItem"> | string
    quantity?: FloatWithAggregatesFilter<"FreightInvoiceItem"> | number
    rate?: FloatWithAggregatesFilter<"FreightInvoiceItem"> | number
    amount?: FloatWithAggregatesFilter<"FreightInvoiceItem"> | number
    taxPercentage?: FloatWithAggregatesFilter<"FreightInvoiceItem"> | number
    taxAmount?: FloatWithAggregatesFilter<"FreightInvoiceItem"> | number
    total?: FloatWithAggregatesFilter<"FreightInvoiceItem"> | number
    vendorId?: IntNullableWithAggregatesFilter<"FreightInvoiceItem"> | number | null
  }

  export type ProductCategoryWhereInput = {
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    id?: IntFilter<"ProductCategory"> | number
    name?: StringFilter<"ProductCategory"> | string
    description?: StringNullableFilter<"ProductCategory"> | string | null
    companyId?: IntFilter<"ProductCategory"> | number
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
    products?: ProductListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type ProductCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
  }

  export type ProductCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    companyId_name?: ProductCategoryCompanyIdNameCompoundUniqueInput
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    name?: StringFilter<"ProductCategory"> | string
    description?: StringNullableFilter<"ProductCategory"> | string | null
    companyId?: IntFilter<"ProductCategory"> | number
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
    products?: ProductListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "companyId_name">

  export type ProductCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCategoryCountOrderByAggregateInput
    _avg?: ProductCategoryAvgOrderByAggregateInput
    _max?: ProductCategoryMaxOrderByAggregateInput
    _min?: ProductCategoryMinOrderByAggregateInput
    _sum?: ProductCategorySumOrderByAggregateInput
  }

  export type ProductCategoryScalarWhereWithAggregatesInput = {
    AND?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    OR?: ProductCategoryScalarWhereWithAggregatesInput[]
    NOT?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductCategory"> | number
    name?: StringWithAggregatesFilter<"ProductCategory"> | string
    description?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
    companyId?: IntWithAggregatesFilter<"ProductCategory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductCategory"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    sku?: StringNullableFilter<"Product"> | string | null
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    unit?: StringFilter<"Product"> | string
    purchasePrice?: FloatFilter<"Product"> | number
    sellingPrice?: FloatFilter<"Product"> | number
    categoryId?: IntFilter<"Product"> | number
    companyId?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    serviceItems?: ServiceInvoiceItemListRelationFilter
    category?: XOR<ProductCategoryScalarRelationFilter, ProductCategoryWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    purchaseItems?: PurchaseInvoiceItemListRelationFilter
    movements?: StockMovementListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    sku?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    unit?: SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
    categoryId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    serviceItems?: ServiceInvoiceItemOrderByRelationAggregateInput
    category?: ProductCategoryOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    purchaseItems?: PurchaseInvoiceItemOrderByRelationAggregateInput
    movements?: StockMovementOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sku?: string
    companyId_name?: ProductCompanyIdNameCompoundUniqueInput
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    unit?: StringFilter<"Product"> | string
    purchasePrice?: FloatFilter<"Product"> | number
    sellingPrice?: FloatFilter<"Product"> | number
    categoryId?: IntFilter<"Product"> | number
    companyId?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    serviceItems?: ServiceInvoiceItemListRelationFilter
    category?: XOR<ProductCategoryScalarRelationFilter, ProductCategoryWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    purchaseItems?: PurchaseInvoiceItemListRelationFilter
    movements?: StockMovementListRelationFilter
  }, "id" | "sku" | "companyId_name">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    sku?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    unit?: SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
    categoryId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    sku?: StringNullableWithAggregatesFilter<"Product"> | string | null
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    unit?: StringWithAggregatesFilter<"Product"> | string
    purchasePrice?: FloatWithAggregatesFilter<"Product"> | number
    sellingPrice?: FloatWithAggregatesFilter<"Product"> | number
    categoryId?: IntWithAggregatesFilter<"Product"> | number
    companyId?: IntWithAggregatesFilter<"Product"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
  }

  export type WarehouseWhereInput = {
    AND?: WarehouseWhereInput | WarehouseWhereInput[]
    OR?: WarehouseWhereInput[]
    NOT?: WarehouseWhereInput | WarehouseWhereInput[]
    id?: IntFilter<"Warehouse"> | number
    name?: StringFilter<"Warehouse"> | string
    location?: StringNullableFilter<"Warehouse"> | string | null
    companyId?: IntFilter<"Warehouse"> | number
    createdAt?: DateTimeFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeFilter<"Warehouse"> | Date | string
    stockMovements?: StockMovementListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type WarehouseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stockMovements?: StockMovementOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
  }

  export type WarehouseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    companyId_name?: WarehouseCompanyIdNameCompoundUniqueInput
    AND?: WarehouseWhereInput | WarehouseWhereInput[]
    OR?: WarehouseWhereInput[]
    NOT?: WarehouseWhereInput | WarehouseWhereInput[]
    name?: StringFilter<"Warehouse"> | string
    location?: StringNullableFilter<"Warehouse"> | string | null
    companyId?: IntFilter<"Warehouse"> | number
    createdAt?: DateTimeFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeFilter<"Warehouse"> | Date | string
    stockMovements?: StockMovementListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "companyId_name">

  export type WarehouseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WarehouseCountOrderByAggregateInput
    _avg?: WarehouseAvgOrderByAggregateInput
    _max?: WarehouseMaxOrderByAggregateInput
    _min?: WarehouseMinOrderByAggregateInput
    _sum?: WarehouseSumOrderByAggregateInput
  }

  export type WarehouseScalarWhereWithAggregatesInput = {
    AND?: WarehouseScalarWhereWithAggregatesInput | WarehouseScalarWhereWithAggregatesInput[]
    OR?: WarehouseScalarWhereWithAggregatesInput[]
    NOT?: WarehouseScalarWhereWithAggregatesInput | WarehouseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Warehouse"> | number
    name?: StringWithAggregatesFilter<"Warehouse"> | string
    location?: StringNullableWithAggregatesFilter<"Warehouse"> | string | null
    companyId?: IntWithAggregatesFilter<"Warehouse"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Warehouse"> | Date | string
  }

  export type StockMovementWhereInput = {
    AND?: StockMovementWhereInput | StockMovementWhereInput[]
    OR?: StockMovementWhereInput[]
    NOT?: StockMovementWhereInput | StockMovementWhereInput[]
    id?: IntFilter<"StockMovement"> | number
    productId?: IntFilter<"StockMovement"> | number
    warehouseId?: IntNullableFilter<"StockMovement"> | number | null
    quantity?: FloatFilter<"StockMovement"> | number
    type?: StringFilter<"StockMovement"> | string
    reference?: StringNullableFilter<"StockMovement"> | string | null
    companyId?: IntFilter<"StockMovement"> | number
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    warehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
  }

  export type StockMovementOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    type?: SortOrder
    reference?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    warehouse?: WarehouseOrderByWithRelationInput
  }

  export type StockMovementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StockMovementWhereInput | StockMovementWhereInput[]
    OR?: StockMovementWhereInput[]
    NOT?: StockMovementWhereInput | StockMovementWhereInput[]
    productId?: IntFilter<"StockMovement"> | number
    warehouseId?: IntNullableFilter<"StockMovement"> | number | null
    quantity?: FloatFilter<"StockMovement"> | number
    type?: StringFilter<"StockMovement"> | string
    reference?: StringNullableFilter<"StockMovement"> | string | null
    companyId?: IntFilter<"StockMovement"> | number
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    warehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
  }, "id">

  export type StockMovementOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    type?: SortOrder
    reference?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    _count?: StockMovementCountOrderByAggregateInput
    _avg?: StockMovementAvgOrderByAggregateInput
    _max?: StockMovementMaxOrderByAggregateInput
    _min?: StockMovementMinOrderByAggregateInput
    _sum?: StockMovementSumOrderByAggregateInput
  }

  export type StockMovementScalarWhereWithAggregatesInput = {
    AND?: StockMovementScalarWhereWithAggregatesInput | StockMovementScalarWhereWithAggregatesInput[]
    OR?: StockMovementScalarWhereWithAggregatesInput[]
    NOT?: StockMovementScalarWhereWithAggregatesInput | StockMovementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StockMovement"> | number
    productId?: IntWithAggregatesFilter<"StockMovement"> | number
    warehouseId?: IntNullableWithAggregatesFilter<"StockMovement"> | number | null
    quantity?: FloatWithAggregatesFilter<"StockMovement"> | number
    type?: StringWithAggregatesFilter<"StockMovement"> | string
    reference?: StringNullableWithAggregatesFilter<"StockMovement"> | string | null
    companyId?: IntWithAggregatesFilter<"StockMovement"> | number
    createdAt?: DateTimeWithAggregatesFilter<"StockMovement"> | Date | string
  }

  export type PurchaseInvoiceWhereInput = {
    AND?: PurchaseInvoiceWhereInput | PurchaseInvoiceWhereInput[]
    OR?: PurchaseInvoiceWhereInput[]
    NOT?: PurchaseInvoiceWhereInput | PurchaseInvoiceWhereInput[]
    id?: IntFilter<"PurchaseInvoice"> | number
    purchaseNumber?: StringFilter<"PurchaseInvoice"> | string
    date?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    vendorId?: IntFilter<"PurchaseInvoice"> | number
    status?: EnumInvoiceStatusFilter<"PurchaseInvoice"> | $Enums.InvoiceStatus
    totalAmount?: FloatFilter<"PurchaseInvoice"> | number
    taxAmount?: FloatFilter<"PurchaseInvoice"> | number
    grandTotal?: FloatFilter<"PurchaseInvoice"> | number
    currencyCode?: StringFilter<"PurchaseInvoice"> | string
    isApproved?: BoolFilter<"PurchaseInvoice"> | boolean
    approvedById?: IntNullableFilter<"PurchaseInvoice"> | number | null
    isLocked?: BoolFilter<"PurchaseInvoice"> | boolean
    lockedAt?: DateTimeNullableFilter<"PurchaseInvoice"> | Date | string | null
    companyId?: IntFilter<"PurchaseInvoice"> | number
    transactionId?: IntNullableFilter<"PurchaseInvoice"> | number | null
    createdAt?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PurchaseInvoice"> | Date | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    items?: PurchaseInvoiceItemListRelationFilter
  }

  export type PurchaseInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    purchaseNumber?: SortOrder
    date?: SortOrder
    vendorId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    grandTotal?: SortOrder
    currencyCode?: SortOrder
    isApproved?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    isLocked?: SortOrder
    lockedAt?: SortOrderInput | SortOrder
    companyId?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    transaction?: TransactionOrderByWithRelationInput
    vendor?: VendorOrderByWithRelationInput
    items?: PurchaseInvoiceItemOrderByRelationAggregateInput
  }

  export type PurchaseInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    purchaseNumber?: string
    transactionId?: number
    AND?: PurchaseInvoiceWhereInput | PurchaseInvoiceWhereInput[]
    OR?: PurchaseInvoiceWhereInput[]
    NOT?: PurchaseInvoiceWhereInput | PurchaseInvoiceWhereInput[]
    date?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    vendorId?: IntFilter<"PurchaseInvoice"> | number
    status?: EnumInvoiceStatusFilter<"PurchaseInvoice"> | $Enums.InvoiceStatus
    totalAmount?: FloatFilter<"PurchaseInvoice"> | number
    taxAmount?: FloatFilter<"PurchaseInvoice"> | number
    grandTotal?: FloatFilter<"PurchaseInvoice"> | number
    currencyCode?: StringFilter<"PurchaseInvoice"> | string
    isApproved?: BoolFilter<"PurchaseInvoice"> | boolean
    approvedById?: IntNullableFilter<"PurchaseInvoice"> | number | null
    isLocked?: BoolFilter<"PurchaseInvoice"> | boolean
    lockedAt?: DateTimeNullableFilter<"PurchaseInvoice"> | Date | string | null
    companyId?: IntFilter<"PurchaseInvoice"> | number
    createdAt?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PurchaseInvoice"> | Date | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    items?: PurchaseInvoiceItemListRelationFilter
  }, "id" | "purchaseNumber" | "transactionId">

  export type PurchaseInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseNumber?: SortOrder
    date?: SortOrder
    vendorId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    grandTotal?: SortOrder
    currencyCode?: SortOrder
    isApproved?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    isLocked?: SortOrder
    lockedAt?: SortOrderInput | SortOrder
    companyId?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PurchaseInvoiceCountOrderByAggregateInput
    _avg?: PurchaseInvoiceAvgOrderByAggregateInput
    _max?: PurchaseInvoiceMaxOrderByAggregateInput
    _min?: PurchaseInvoiceMinOrderByAggregateInput
    _sum?: PurchaseInvoiceSumOrderByAggregateInput
  }

  export type PurchaseInvoiceScalarWhereWithAggregatesInput = {
    AND?: PurchaseInvoiceScalarWhereWithAggregatesInput | PurchaseInvoiceScalarWhereWithAggregatesInput[]
    OR?: PurchaseInvoiceScalarWhereWithAggregatesInput[]
    NOT?: PurchaseInvoiceScalarWhereWithAggregatesInput | PurchaseInvoiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PurchaseInvoice"> | number
    purchaseNumber?: StringWithAggregatesFilter<"PurchaseInvoice"> | string
    date?: DateTimeWithAggregatesFilter<"PurchaseInvoice"> | Date | string
    vendorId?: IntWithAggregatesFilter<"PurchaseInvoice"> | number
    status?: EnumInvoiceStatusWithAggregatesFilter<"PurchaseInvoice"> | $Enums.InvoiceStatus
    totalAmount?: FloatWithAggregatesFilter<"PurchaseInvoice"> | number
    taxAmount?: FloatWithAggregatesFilter<"PurchaseInvoice"> | number
    grandTotal?: FloatWithAggregatesFilter<"PurchaseInvoice"> | number
    currencyCode?: StringWithAggregatesFilter<"PurchaseInvoice"> | string
    isApproved?: BoolWithAggregatesFilter<"PurchaseInvoice"> | boolean
    approvedById?: IntNullableWithAggregatesFilter<"PurchaseInvoice"> | number | null
    isLocked?: BoolWithAggregatesFilter<"PurchaseInvoice"> | boolean
    lockedAt?: DateTimeNullableWithAggregatesFilter<"PurchaseInvoice"> | Date | string | null
    companyId?: IntWithAggregatesFilter<"PurchaseInvoice"> | number
    transactionId?: IntNullableWithAggregatesFilter<"PurchaseInvoice"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseInvoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseInvoice"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"PurchaseInvoice"> | Date | string | null
  }

  export type PurchaseInvoiceItemWhereInput = {
    AND?: PurchaseInvoiceItemWhereInput | PurchaseInvoiceItemWhereInput[]
    OR?: PurchaseInvoiceItemWhereInput[]
    NOT?: PurchaseInvoiceItemWhereInput | PurchaseInvoiceItemWhereInput[]
    id?: IntFilter<"PurchaseInvoiceItem"> | number
    purchaseInvoiceId?: IntFilter<"PurchaseInvoiceItem"> | number
    productId?: IntFilter<"PurchaseInvoiceItem"> | number
    description?: StringNullableFilter<"PurchaseInvoiceItem"> | string | null
    quantity?: FloatFilter<"PurchaseInvoiceItem"> | number
    rate?: FloatFilter<"PurchaseInvoiceItem"> | number
    amount?: FloatFilter<"PurchaseInvoiceItem"> | number
    taxPercentage?: FloatFilter<"PurchaseInvoiceItem"> | number
    taxAmount?: FloatFilter<"PurchaseInvoiceItem"> | number
    total?: FloatFilter<"PurchaseInvoiceItem"> | number
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    purchaseInvoice?: XOR<PurchaseInvoiceScalarRelationFilter, PurchaseInvoiceWhereInput>
  }

  export type PurchaseInvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    purchaseInvoiceId?: SortOrder
    productId?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    taxPercentage?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    product?: ProductOrderByWithRelationInput
    purchaseInvoice?: PurchaseInvoiceOrderByWithRelationInput
  }

  export type PurchaseInvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PurchaseInvoiceItemWhereInput | PurchaseInvoiceItemWhereInput[]
    OR?: PurchaseInvoiceItemWhereInput[]
    NOT?: PurchaseInvoiceItemWhereInput | PurchaseInvoiceItemWhereInput[]
    purchaseInvoiceId?: IntFilter<"PurchaseInvoiceItem"> | number
    productId?: IntFilter<"PurchaseInvoiceItem"> | number
    description?: StringNullableFilter<"PurchaseInvoiceItem"> | string | null
    quantity?: FloatFilter<"PurchaseInvoiceItem"> | number
    rate?: FloatFilter<"PurchaseInvoiceItem"> | number
    amount?: FloatFilter<"PurchaseInvoiceItem"> | number
    taxPercentage?: FloatFilter<"PurchaseInvoiceItem"> | number
    taxAmount?: FloatFilter<"PurchaseInvoiceItem"> | number
    total?: FloatFilter<"PurchaseInvoiceItem"> | number
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    purchaseInvoice?: XOR<PurchaseInvoiceScalarRelationFilter, PurchaseInvoiceWhereInput>
  }, "id">

  export type PurchaseInvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseInvoiceId?: SortOrder
    productId?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    taxPercentage?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    _count?: PurchaseInvoiceItemCountOrderByAggregateInput
    _avg?: PurchaseInvoiceItemAvgOrderByAggregateInput
    _max?: PurchaseInvoiceItemMaxOrderByAggregateInput
    _min?: PurchaseInvoiceItemMinOrderByAggregateInput
    _sum?: PurchaseInvoiceItemSumOrderByAggregateInput
  }

  export type PurchaseInvoiceItemScalarWhereWithAggregatesInput = {
    AND?: PurchaseInvoiceItemScalarWhereWithAggregatesInput | PurchaseInvoiceItemScalarWhereWithAggregatesInput[]
    OR?: PurchaseInvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: PurchaseInvoiceItemScalarWhereWithAggregatesInput | PurchaseInvoiceItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PurchaseInvoiceItem"> | number
    purchaseInvoiceId?: IntWithAggregatesFilter<"PurchaseInvoiceItem"> | number
    productId?: IntWithAggregatesFilter<"PurchaseInvoiceItem"> | number
    description?: StringNullableWithAggregatesFilter<"PurchaseInvoiceItem"> | string | null
    quantity?: FloatWithAggregatesFilter<"PurchaseInvoiceItem"> | number
    rate?: FloatWithAggregatesFilter<"PurchaseInvoiceItem"> | number
    amount?: FloatWithAggregatesFilter<"PurchaseInvoiceItem"> | number
    taxPercentage?: FloatWithAggregatesFilter<"PurchaseInvoiceItem"> | number
    taxAmount?: FloatWithAggregatesFilter<"PurchaseInvoiceItem"> | number
    total?: FloatWithAggregatesFilter<"PurchaseInvoiceItem"> | number
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: IntFilter<"Account"> | number
    code?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    type?: EnumAccountTypeFilter<"Account"> | $Enums.AccountType
    description?: StringNullableFilter<"Account"> | string | null
    parentId?: IntNullableFilter<"Account"> | number | null
    companyId?: IntFilter<"Account"> | number
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    division?: StringNullableFilter<"Account"> | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    parent?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    children?: AccountListRelationFilter
    entries?: AccountEntryListRelationFilter
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    vendor?: XOR<VendorNullableScalarRelationFilter, VendorWhereInput> | null
    voucherEntries?: VoucherEntryListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    division?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    parent?: AccountOrderByWithRelationInput
    children?: AccountOrderByRelationAggregateInput
    entries?: AccountEntryOrderByRelationAggregateInput
    customer?: CustomerOrderByWithRelationInput
    vendor?: VendorOrderByWithRelationInput
    voucherEntries?: VoucherEntryOrderByRelationAggregateInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    companyId_code?: AccountCompanyIdCodeCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    code?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    type?: EnumAccountTypeFilter<"Account"> | $Enums.AccountType
    description?: StringNullableFilter<"Account"> | string | null
    parentId?: IntNullableFilter<"Account"> | number | null
    companyId?: IntFilter<"Account"> | number
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    division?: StringNullableFilter<"Account"> | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    parent?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    children?: AccountListRelationFilter
    entries?: AccountEntryListRelationFilter
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    vendor?: XOR<VendorNullableScalarRelationFilter, VendorWhereInput> | null
    voucherEntries?: VoucherEntryListRelationFilter
  }, "id" | "companyId_code">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    division?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Account"> | number
    code?: StringWithAggregatesFilter<"Account"> | string
    name?: StringWithAggregatesFilter<"Account"> | string
    type?: EnumAccountTypeWithAggregatesFilter<"Account"> | $Enums.AccountType
    description?: StringNullableWithAggregatesFilter<"Account"> | string | null
    parentId?: IntNullableWithAggregatesFilter<"Account"> | number | null
    companyId?: IntWithAggregatesFilter<"Account"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    division?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: IntFilter<"Transaction"> | number
    reference?: StringFilter<"Transaction"> | string
    date?: DateTimeFilter<"Transaction"> | Date | string
    description?: StringNullableFilter<"Transaction"> | string | null
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    companyId?: IntFilter<"Transaction"> | number
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    isLocked?: BoolFilter<"Transaction"> | boolean
    entries?: AccountEntryListRelationFilter
    service?: XOR<ServiceInvoiceNullableScalarRelationFilter, ServiceInvoiceWhereInput> | null
    freight?: XOR<FreightInvoiceNullableScalarRelationFilter, FreightInvoiceWhereInput> | null
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
    purchase?: XOR<PurchaseInvoiceNullableScalarRelationFilter, PurchaseInvoiceWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    reference?: SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isLocked?: SortOrder
    entries?: AccountEntryOrderByRelationAggregateInput
    service?: ServiceInvoiceOrderByWithRelationInput
    freight?: FreightInvoiceOrderByWithRelationInput
    payment?: PaymentOrderByWithRelationInput
    purchase?: PurchaseInvoiceOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    companyId_reference?: TransactionCompanyIdReferenceCompoundUniqueInput
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    reference?: StringFilter<"Transaction"> | string
    date?: DateTimeFilter<"Transaction"> | Date | string
    description?: StringNullableFilter<"Transaction"> | string | null
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    companyId?: IntFilter<"Transaction"> | number
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    isLocked?: BoolFilter<"Transaction"> | boolean
    entries?: AccountEntryListRelationFilter
    service?: XOR<ServiceInvoiceNullableScalarRelationFilter, ServiceInvoiceWhereInput> | null
    freight?: XOR<FreightInvoiceNullableScalarRelationFilter, FreightInvoiceWhereInput> | null
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
    purchase?: XOR<PurchaseInvoiceNullableScalarRelationFilter, PurchaseInvoiceWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "companyId_reference">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    reference?: SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isLocked?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Transaction"> | number
    reference?: StringWithAggregatesFilter<"Transaction"> | string
    date?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    type?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    companyId?: IntWithAggregatesFilter<"Transaction"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    isLocked?: BoolWithAggregatesFilter<"Transaction"> | boolean
  }

  export type AccountEntryWhereInput = {
    AND?: AccountEntryWhereInput | AccountEntryWhereInput[]
    OR?: AccountEntryWhereInput[]
    NOT?: AccountEntryWhereInput | AccountEntryWhereInput[]
    id?: IntFilter<"AccountEntry"> | number
    transactionId?: IntFilter<"AccountEntry"> | number
    accountId?: IntFilter<"AccountEntry"> | number
    description?: StringNullableFilter<"AccountEntry"> | string | null
    debit?: FloatFilter<"AccountEntry"> | number
    credit?: FloatFilter<"AccountEntry"> | number
    createdAt?: DateTimeFilter<"AccountEntry"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
  }

  export type AccountEntryOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    accountId?: SortOrder
    description?: SortOrderInput | SortOrder
    debit?: SortOrder
    credit?: SortOrder
    createdAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    transaction?: TransactionOrderByWithRelationInput
  }

  export type AccountEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AccountEntryWhereInput | AccountEntryWhereInput[]
    OR?: AccountEntryWhereInput[]
    NOT?: AccountEntryWhereInput | AccountEntryWhereInput[]
    transactionId?: IntFilter<"AccountEntry"> | number
    accountId?: IntFilter<"AccountEntry"> | number
    description?: StringNullableFilter<"AccountEntry"> | string | null
    debit?: FloatFilter<"AccountEntry"> | number
    credit?: FloatFilter<"AccountEntry"> | number
    createdAt?: DateTimeFilter<"AccountEntry"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
  }, "id">

  export type AccountEntryOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    accountId?: SortOrder
    description?: SortOrderInput | SortOrder
    debit?: SortOrder
    credit?: SortOrder
    createdAt?: SortOrder
    _count?: AccountEntryCountOrderByAggregateInput
    _avg?: AccountEntryAvgOrderByAggregateInput
    _max?: AccountEntryMaxOrderByAggregateInput
    _min?: AccountEntryMinOrderByAggregateInput
    _sum?: AccountEntrySumOrderByAggregateInput
  }

  export type AccountEntryScalarWhereWithAggregatesInput = {
    AND?: AccountEntryScalarWhereWithAggregatesInput | AccountEntryScalarWhereWithAggregatesInput[]
    OR?: AccountEntryScalarWhereWithAggregatesInput[]
    NOT?: AccountEntryScalarWhereWithAggregatesInput | AccountEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AccountEntry"> | number
    transactionId?: IntWithAggregatesFilter<"AccountEntry"> | number
    accountId?: IntWithAggregatesFilter<"AccountEntry"> | number
    description?: StringNullableWithAggregatesFilter<"AccountEntry"> | string | null
    debit?: FloatWithAggregatesFilter<"AccountEntry"> | number
    credit?: FloatWithAggregatesFilter<"AccountEntry"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AccountEntry"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: IntFilter<"Payment"> | number
    receiptNumber?: StringFilter<"Payment"> | string
    date?: DateTimeFilter<"Payment"> | Date | string
    amount?: FloatFilter<"Payment"> | number
    mode?: EnumPaymentModeFilter<"Payment"> | $Enums.PaymentMode
    reference?: StringNullableFilter<"Payment"> | string | null
    customerId?: IntNullableFilter<"Payment"> | number | null
    vendorId?: IntNullableFilter<"Payment"> | number | null
    transactionId?: IntFilter<"Payment"> | number
    companyId?: IntFilter<"Payment"> | number
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    division?: StringNullableFilter<"Payment"> | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    vendor?: XOR<VendorNullableScalarRelationFilter, VendorWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    receiptNumber?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    mode?: SortOrder
    reference?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    vendorId?: SortOrderInput | SortOrder
    transactionId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    division?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    transaction?: TransactionOrderByWithRelationInput
    vendor?: VendorOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    transactionId?: number
    companyId_receiptNumber?: PaymentCompanyIdReceiptNumberCompoundUniqueInput
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    receiptNumber?: StringFilter<"Payment"> | string
    date?: DateTimeFilter<"Payment"> | Date | string
    amount?: FloatFilter<"Payment"> | number
    mode?: EnumPaymentModeFilter<"Payment"> | $Enums.PaymentMode
    reference?: StringNullableFilter<"Payment"> | string | null
    customerId?: IntNullableFilter<"Payment"> | number | null
    vendorId?: IntNullableFilter<"Payment"> | number | null
    companyId?: IntFilter<"Payment"> | number
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    division?: StringNullableFilter<"Payment"> | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    vendor?: XOR<VendorNullableScalarRelationFilter, VendorWhereInput> | null
  }, "id" | "transactionId" | "companyId_receiptNumber">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    receiptNumber?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    mode?: SortOrder
    reference?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    vendorId?: SortOrderInput | SortOrder
    transactionId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    division?: SortOrderInput | SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payment"> | number
    receiptNumber?: StringWithAggregatesFilter<"Payment"> | string
    date?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    mode?: EnumPaymentModeWithAggregatesFilter<"Payment"> | $Enums.PaymentMode
    reference?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    customerId?: IntNullableWithAggregatesFilter<"Payment"> | number | null
    vendorId?: IntNullableWithAggregatesFilter<"Payment"> | number | null
    transactionId?: IntWithAggregatesFilter<"Payment"> | number
    companyId?: IntWithAggregatesFilter<"Payment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    division?: StringNullableWithAggregatesFilter<"Payment"> | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    userId?: IntFilter<"AuditLog"> | number
    action?: StringFilter<"AuditLog"> | string
    module?: StringFilter<"AuditLog"> | string
    entityId?: IntNullableFilter<"AuditLog"> | number | null
    payload?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    companyId?: IntFilter<"AuditLog"> | number
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    module?: SortOrder
    entityId?: SortOrderInput | SortOrder
    payload?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
    company?: CompanyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: IntFilter<"AuditLog"> | number
    action?: StringFilter<"AuditLog"> | string
    module?: StringFilter<"AuditLog"> | string
    entityId?: IntNullableFilter<"AuditLog"> | number | null
    payload?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    companyId?: IntFilter<"AuditLog"> | number
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    module?: SortOrder
    entityId?: SortOrderInput | SortOrder
    payload?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _avg?: AuditLogAvgOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
    _sum?: AuditLogSumOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditLog"> | number
    userId?: IntWithAggregatesFilter<"AuditLog"> | number
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    module?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: IntNullableWithAggregatesFilter<"AuditLog"> | number | null
    payload?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
    companyId?: IntWithAggregatesFilter<"AuditLog"> | number
  }

  export type FinancialPeriodWhereInput = {
    AND?: FinancialPeriodWhereInput | FinancialPeriodWhereInput[]
    OR?: FinancialPeriodWhereInput[]
    NOT?: FinancialPeriodWhereInput | FinancialPeriodWhereInput[]
    id?: IntFilter<"FinancialPeriod"> | number
    month?: IntFilter<"FinancialPeriod"> | number
    year?: IntFilter<"FinancialPeriod"> | number
    isClosed?: BoolFilter<"FinancialPeriod"> | boolean
    closedById?: IntNullableFilter<"FinancialPeriod"> | number | null
    closedAt?: DateTimeNullableFilter<"FinancialPeriod"> | Date | string | null
    companyId?: IntFilter<"FinancialPeriod"> | number
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type FinancialPeriodOrderByWithRelationInput = {
    id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    isClosed?: SortOrder
    closedById?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    companyId?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type FinancialPeriodWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    companyId_month_year?: FinancialPeriodCompanyIdMonthYearCompoundUniqueInput
    AND?: FinancialPeriodWhereInput | FinancialPeriodWhereInput[]
    OR?: FinancialPeriodWhereInput[]
    NOT?: FinancialPeriodWhereInput | FinancialPeriodWhereInput[]
    month?: IntFilter<"FinancialPeriod"> | number
    year?: IntFilter<"FinancialPeriod"> | number
    isClosed?: BoolFilter<"FinancialPeriod"> | boolean
    closedById?: IntNullableFilter<"FinancialPeriod"> | number | null
    closedAt?: DateTimeNullableFilter<"FinancialPeriod"> | Date | string | null
    companyId?: IntFilter<"FinancialPeriod"> | number
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "companyId_month_year">

  export type FinancialPeriodOrderByWithAggregationInput = {
    id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    isClosed?: SortOrder
    closedById?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    companyId?: SortOrder
    _count?: FinancialPeriodCountOrderByAggregateInput
    _avg?: FinancialPeriodAvgOrderByAggregateInput
    _max?: FinancialPeriodMaxOrderByAggregateInput
    _min?: FinancialPeriodMinOrderByAggregateInput
    _sum?: FinancialPeriodSumOrderByAggregateInput
  }

  export type FinancialPeriodScalarWhereWithAggregatesInput = {
    AND?: FinancialPeriodScalarWhereWithAggregatesInput | FinancialPeriodScalarWhereWithAggregatesInput[]
    OR?: FinancialPeriodScalarWhereWithAggregatesInput[]
    NOT?: FinancialPeriodScalarWhereWithAggregatesInput | FinancialPeriodScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FinancialPeriod"> | number
    month?: IntWithAggregatesFilter<"FinancialPeriod"> | number
    year?: IntWithAggregatesFilter<"FinancialPeriod"> | number
    isClosed?: BoolWithAggregatesFilter<"FinancialPeriod"> | boolean
    closedById?: IntNullableWithAggregatesFilter<"FinancialPeriod"> | number | null
    closedAt?: DateTimeNullableWithAggregatesFilter<"FinancialPeriod"> | Date | string | null
    companyId?: IntWithAggregatesFilter<"FinancialPeriod"> | number
  }

  export type PortWhereInput = {
    AND?: PortWhereInput | PortWhereInput[]
    OR?: PortWhereInput[]
    NOT?: PortWhereInput | PortWhereInput[]
    id?: IntFilter<"Port"> | number
    name?: StringFilter<"Port"> | string
    companyId?: IntFilter<"Port"> | number
    createdAt?: DateTimeFilter<"Port"> | Date | string
    updatedAt?: DateTimeFilter<"Port"> | Date | string
    jobs?: JobListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type PortOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    jobs?: JobOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
  }

  export type PortWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    companyId_name?: PortCompanyIdNameCompoundUniqueInput
    AND?: PortWhereInput | PortWhereInput[]
    OR?: PortWhereInput[]
    NOT?: PortWhereInput | PortWhereInput[]
    name?: StringFilter<"Port"> | string
    companyId?: IntFilter<"Port"> | number
    createdAt?: DateTimeFilter<"Port"> | Date | string
    updatedAt?: DateTimeFilter<"Port"> | Date | string
    jobs?: JobListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "companyId_name">

  export type PortOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PortCountOrderByAggregateInput
    _avg?: PortAvgOrderByAggregateInput
    _max?: PortMaxOrderByAggregateInput
    _min?: PortMinOrderByAggregateInput
    _sum?: PortSumOrderByAggregateInput
  }

  export type PortScalarWhereWithAggregatesInput = {
    AND?: PortScalarWhereWithAggregatesInput | PortScalarWhereWithAggregatesInput[]
    OR?: PortScalarWhereWithAggregatesInput[]
    NOT?: PortScalarWhereWithAggregatesInput | PortScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Port"> | number
    name?: StringWithAggregatesFilter<"Port"> | string
    companyId?: IntWithAggregatesFilter<"Port"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Port"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Port"> | Date | string
  }

  export type VoucherWhereInput = {
    AND?: VoucherWhereInput | VoucherWhereInput[]
    OR?: VoucherWhereInput[]
    NOT?: VoucherWhereInput | VoucherWhereInput[]
    id?: IntFilter<"Voucher"> | number
    voucherNumber?: StringFilter<"Voucher"> | string
    voucherType?: EnumVoucherTypeFilter<"Voucher"> | $Enums.VoucherType
    status?: EnumVoucherStatusFilter<"Voucher"> | $Enums.VoucherStatus
    date?: DateTimeFilter<"Voucher"> | Date | string
    postingDate?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    paymentMode?: EnumPaymentModeNullableFilter<"Voucher"> | $Enums.PaymentMode | null
    instrumentNo?: StringNullableFilter<"Voucher"> | string | null
    instrumentDate?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    bankName?: StringNullableFilter<"Voucher"> | string | null
    narration?: StringNullableFilter<"Voucher"> | string | null
    companyId?: IntFilter<"Voucher"> | number
    division?: StringNullableFilter<"Voucher"> | string | null
    isPosted?: BoolFilter<"Voucher"> | boolean
    postedAt?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    postedById?: IntNullableFilter<"Voucher"> | number | null
    createdAt?: DateTimeFilter<"Voucher"> | Date | string
    updatedAt?: DateTimeFilter<"Voucher"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    postedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    entries?: VoucherEntryListRelationFilter
  }

  export type VoucherOrderByWithRelationInput = {
    id?: SortOrder
    voucherNumber?: SortOrder
    voucherType?: SortOrder
    status?: SortOrder
    date?: SortOrder
    postingDate?: SortOrderInput | SortOrder
    paymentMode?: SortOrderInput | SortOrder
    instrumentNo?: SortOrderInput | SortOrder
    instrumentDate?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    narration?: SortOrderInput | SortOrder
    companyId?: SortOrder
    division?: SortOrderInput | SortOrder
    isPosted?: SortOrder
    postedAt?: SortOrderInput | SortOrder
    postedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    postedBy?: UserOrderByWithRelationInput
    entries?: VoucherEntryOrderByRelationAggregateInput
  }

  export type VoucherWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    companyId_voucherNumber?: VoucherCompanyIdVoucherNumberCompoundUniqueInput
    AND?: VoucherWhereInput | VoucherWhereInput[]
    OR?: VoucherWhereInput[]
    NOT?: VoucherWhereInput | VoucherWhereInput[]
    voucherNumber?: StringFilter<"Voucher"> | string
    voucherType?: EnumVoucherTypeFilter<"Voucher"> | $Enums.VoucherType
    status?: EnumVoucherStatusFilter<"Voucher"> | $Enums.VoucherStatus
    date?: DateTimeFilter<"Voucher"> | Date | string
    postingDate?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    paymentMode?: EnumPaymentModeNullableFilter<"Voucher"> | $Enums.PaymentMode | null
    instrumentNo?: StringNullableFilter<"Voucher"> | string | null
    instrumentDate?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    bankName?: StringNullableFilter<"Voucher"> | string | null
    narration?: StringNullableFilter<"Voucher"> | string | null
    companyId?: IntFilter<"Voucher"> | number
    division?: StringNullableFilter<"Voucher"> | string | null
    isPosted?: BoolFilter<"Voucher"> | boolean
    postedAt?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    postedById?: IntNullableFilter<"Voucher"> | number | null
    createdAt?: DateTimeFilter<"Voucher"> | Date | string
    updatedAt?: DateTimeFilter<"Voucher"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    postedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    entries?: VoucherEntryListRelationFilter
  }, "id" | "companyId_voucherNumber">

  export type VoucherOrderByWithAggregationInput = {
    id?: SortOrder
    voucherNumber?: SortOrder
    voucherType?: SortOrder
    status?: SortOrder
    date?: SortOrder
    postingDate?: SortOrderInput | SortOrder
    paymentMode?: SortOrderInput | SortOrder
    instrumentNo?: SortOrderInput | SortOrder
    instrumentDate?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    narration?: SortOrderInput | SortOrder
    companyId?: SortOrder
    division?: SortOrderInput | SortOrder
    isPosted?: SortOrder
    postedAt?: SortOrderInput | SortOrder
    postedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VoucherCountOrderByAggregateInput
    _avg?: VoucherAvgOrderByAggregateInput
    _max?: VoucherMaxOrderByAggregateInput
    _min?: VoucherMinOrderByAggregateInput
    _sum?: VoucherSumOrderByAggregateInput
  }

  export type VoucherScalarWhereWithAggregatesInput = {
    AND?: VoucherScalarWhereWithAggregatesInput | VoucherScalarWhereWithAggregatesInput[]
    OR?: VoucherScalarWhereWithAggregatesInput[]
    NOT?: VoucherScalarWhereWithAggregatesInput | VoucherScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Voucher"> | number
    voucherNumber?: StringWithAggregatesFilter<"Voucher"> | string
    voucherType?: EnumVoucherTypeWithAggregatesFilter<"Voucher"> | $Enums.VoucherType
    status?: EnumVoucherStatusWithAggregatesFilter<"Voucher"> | $Enums.VoucherStatus
    date?: DateTimeWithAggregatesFilter<"Voucher"> | Date | string
    postingDate?: DateTimeNullableWithAggregatesFilter<"Voucher"> | Date | string | null
    paymentMode?: EnumPaymentModeNullableWithAggregatesFilter<"Voucher"> | $Enums.PaymentMode | null
    instrumentNo?: StringNullableWithAggregatesFilter<"Voucher"> | string | null
    instrumentDate?: DateTimeNullableWithAggregatesFilter<"Voucher"> | Date | string | null
    bankName?: StringNullableWithAggregatesFilter<"Voucher"> | string | null
    narration?: StringNullableWithAggregatesFilter<"Voucher"> | string | null
    companyId?: IntWithAggregatesFilter<"Voucher"> | number
    division?: StringNullableWithAggregatesFilter<"Voucher"> | string | null
    isPosted?: BoolWithAggregatesFilter<"Voucher"> | boolean
    postedAt?: DateTimeNullableWithAggregatesFilter<"Voucher"> | Date | string | null
    postedById?: IntNullableWithAggregatesFilter<"Voucher"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Voucher"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Voucher"> | Date | string
  }

  export type VoucherEntryWhereInput = {
    AND?: VoucherEntryWhereInput | VoucherEntryWhereInput[]
    OR?: VoucherEntryWhereInput[]
    NOT?: VoucherEntryWhereInput | VoucherEntryWhereInput[]
    id?: IntFilter<"VoucherEntry"> | number
    voucherId?: IntFilter<"VoucherEntry"> | number
    accountId?: IntFilter<"VoucherEntry"> | number
    debit?: FloatFilter<"VoucherEntry"> | number
    credit?: FloatFilter<"VoucherEntry"> | number
    description?: StringNullableFilter<"VoucherEntry"> | string | null
    createdAt?: DateTimeFilter<"VoucherEntry"> | Date | string
    updatedAt?: DateTimeFilter<"VoucherEntry"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    voucher?: XOR<VoucherScalarRelationFilter, VoucherWhereInput>
  }

  export type VoucherEntryOrderByWithRelationInput = {
    id?: SortOrder
    voucherId?: SortOrder
    accountId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    voucher?: VoucherOrderByWithRelationInput
  }

  export type VoucherEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VoucherEntryWhereInput | VoucherEntryWhereInput[]
    OR?: VoucherEntryWhereInput[]
    NOT?: VoucherEntryWhereInput | VoucherEntryWhereInput[]
    voucherId?: IntFilter<"VoucherEntry"> | number
    accountId?: IntFilter<"VoucherEntry"> | number
    debit?: FloatFilter<"VoucherEntry"> | number
    credit?: FloatFilter<"VoucherEntry"> | number
    description?: StringNullableFilter<"VoucherEntry"> | string | null
    createdAt?: DateTimeFilter<"VoucherEntry"> | Date | string
    updatedAt?: DateTimeFilter<"VoucherEntry"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    voucher?: XOR<VoucherScalarRelationFilter, VoucherWhereInput>
  }, "id">

  export type VoucherEntryOrderByWithAggregationInput = {
    id?: SortOrder
    voucherId?: SortOrder
    accountId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VoucherEntryCountOrderByAggregateInput
    _avg?: VoucherEntryAvgOrderByAggregateInput
    _max?: VoucherEntryMaxOrderByAggregateInput
    _min?: VoucherEntryMinOrderByAggregateInput
    _sum?: VoucherEntrySumOrderByAggregateInput
  }

  export type VoucherEntryScalarWhereWithAggregatesInput = {
    AND?: VoucherEntryScalarWhereWithAggregatesInput | VoucherEntryScalarWhereWithAggregatesInput[]
    OR?: VoucherEntryScalarWhereWithAggregatesInput[]
    NOT?: VoucherEntryScalarWhereWithAggregatesInput | VoucherEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VoucherEntry"> | number
    voucherId?: IntWithAggregatesFilter<"VoucherEntry"> | number
    accountId?: IntWithAggregatesFilter<"VoucherEntry"> | number
    debit?: FloatWithAggregatesFilter<"VoucherEntry"> | number
    credit?: FloatWithAggregatesFilter<"VoucherEntry"> | number
    description?: StringNullableWithAggregatesFilter<"VoucherEntry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VoucherEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VoucherEntry"> | Date | string
  }

  export type CompanyCreateInput = {
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyCreateNestedManyWithoutCompanyInput
    customers?: CustomerCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCompanyInput
    jobs?: JobCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    ports?: PortCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: number
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyUncheckedCreateNestedManyWithoutCompanyInput
    customers?: CustomerUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    jobs?: JobUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    ports?: PortUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingUncheckedCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCompanyNestedInput
    jobs?: JobUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    ports?: PortUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUncheckedUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    ports?: PortUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUncheckedUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: number
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
  }

  export type CompanyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BranchCreateInput = {
    name: string
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutBranchesInput
    jobs?: JobCreateNestedManyWithoutBranchInput
    taxSettings?: TaxSettingCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateInput = {
    id?: number
    name: string
    location?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutBranchInput
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutBranchesNestedInput
    jobs?: JobUpdateManyWithoutBranchNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutBranchNestedInput
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateManyInput = {
    id?: number
    name: string
    location?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyCreateInput = {
    code: string
    symbol: string
    name: string
    companies?: CompanyCurrencyCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateInput = {
    id?: number
    code: string
    symbol: string
    name: string
    companies?: CompanyCurrencyUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companies?: CompanyCurrencyUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companies?: CompanyCurrencyUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyCreateManyInput = {
    id?: number
    code: string
    symbol: string
    name: string
  }

  export type CurrencyUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CurrencyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyCurrencyCreateInput = {
    exchangeRate?: number
    isDefault?: boolean
    company: CompanyCreateNestedOneWithoutCurrenciesInput
    currency: CurrencyCreateNestedOneWithoutCompaniesInput
  }

  export type CompanyCurrencyUncheckedCreateInput = {
    id?: number
    companyId: number
    currencyId: number
    exchangeRate?: number
    isDefault?: boolean
  }

  export type CompanyCurrencyUpdateInput = {
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    company?: CompanyUpdateOneRequiredWithoutCurrenciesNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutCompaniesNestedInput
  }

  export type CompanyCurrencyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    currencyId?: IntFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CompanyCurrencyCreateManyInput = {
    id?: number
    companyId: number
    currencyId: number
    exchangeRate?: number
    isDefault?: boolean
  }

  export type CompanyCurrencyUpdateManyMutationInput = {
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CompanyCurrencyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    currencyId?: IntFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaxSettingCreateInput = {
    name: string
    percentage: number
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutTaxSettingsInput
    company: CompanyCreateNestedOneWithoutTaxSettingsInput
  }

  export type TaxSettingUncheckedCreateInput = {
    id?: number
    name: string
    percentage: number
    type: string
    companyId: number
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxSettingUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutTaxSettingsNestedInput
    company?: CompanyUpdateOneRequiredWithoutTaxSettingsNestedInput
  }

  export type TaxSettingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxSettingCreateManyInput = {
    id?: number
    name: string
    percentage: number
    type: string
    companyId: number
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxSettingUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxSettingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateInput = {
    key: string
    value: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutSystemSettingsInput
  }

  export type SystemSettingUncheckedCreateInput = {
    id?: number
    key: string
    value: string
    type: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutSystemSettingsNestedInput
  }

  export type SystemSettingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateManyInput = {
    id?: number
    key: string
    value: string
    type: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    email: string
    name?: string | null
    password: string
    role?: $Enums.Role
    branch?: string | null
    department?: string | null
    region?: string | null
    division?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    postedVouchers?: VoucherCreateNestedManyWithoutPostedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    name?: string | null
    password: string
    role?: $Enums.Role
    companyId?: number | null
    branch?: string | null
    department?: string | null
    region?: string | null
    division?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    postedVouchers?: VoucherUncheckedCreateNestedManyWithoutPostedByInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    branch?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    postedVouchers?: VoucherUpdateManyWithoutPostedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    postedVouchers?: VoucherUncheckedUpdateManyWithoutPostedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    name?: string | null
    password: string
    role?: $Enums.Role
    companyId?: number | null
    branch?: string | null
    department?: string | null
    region?: string | null
    division?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    branch?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    account?: AccountCreateNestedOneWithoutCustomerInput
    company: CompanyCreateNestedOneWithoutCustomersInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCustomerInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCustomerInput
    jobs?: JobCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: number
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    accountId?: number | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    jobs?: JobUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneWithoutCustomerNestedInput
    company?: CompanyUpdateOneRequiredWithoutCustomersNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCustomerNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCustomerNestedInput
    jobs?: JobUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: number
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    accountId?: number | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
  }

  export type CustomerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VendorCreateInput = {
    name: string
    code: string
    type?: string | null
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    expenses?: ExpenseCreateNestedManyWithoutVendorInput
    payments?: PaymentCreateNestedManyWithoutVendorInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutVendorInput
    account?: AccountCreateNestedOneWithoutVendorInput
    company: CompanyCreateNestedOneWithoutVendorsInput
    freightItems?: FreightInvoiceItemCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateInput = {
    id?: number
    name: string
    code: string
    type?: string | null
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    accountId?: number | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutVendorInput
    payments?: PaymentUncheckedCreateNestedManyWithoutVendorInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutVendorInput
    freightItems?: FreightInvoiceItemUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUpdateManyWithoutVendorNestedInput
    payments?: PaymentUpdateManyWithoutVendorNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutVendorNestedInput
    account?: AccountUpdateOneWithoutVendorNestedInput
    company?: CompanyUpdateOneRequiredWithoutVendorsNestedInput
    freightItems?: FreightInvoiceItemUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutVendorNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutVendorNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutVendorNestedInput
    freightItems?: FreightInvoiceItemUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorCreateManyInput = {
    id?: number
    name: string
    code: string
    type?: string | null
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    accountId?: number | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
  }

  export type VendorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VendorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobCreateInput = {
    jobNumber: string
    date?: Date | string
    jobDate?: Date | string
    jobType?: $Enums.JobType
    status?: $Enums.JobStatus
    vessel?: string | null
    place?: string | null
    shipperRef?: string | null
    gdNo?: string | null
    gdDate?: Date | string | null
    formE?: string | null
    formEDate?: Date | string | null
    commodity?: string | null
    volume?: string | null
    containerNo?: string | null
    packages?: number | null
    weight?: number | null
    hawbBl?: string | null
    handledBy?: string | null
    salesPerson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    division?: string | null
    expenses?: ExpenseCreateNestedManyWithoutJobInput
    serviceInvoice?: ServiceInvoiceCreateNestedOneWithoutJobInput
    freightInvoice?: FreightInvoiceCreateNestedOneWithoutJobInput
    branch?: BranchCreateNestedOneWithoutJobsInput
    company: CompanyCreateNestedOneWithoutJobsInput
    customer: CustomerCreateNestedOneWithoutJobsInput
    pod?: PortCreateNestedOneWithoutJobsInput
  }

  export type JobUncheckedCreateInput = {
    id?: number
    jobNumber: string
    date?: Date | string
    jobDate?: Date | string
    jobType?: $Enums.JobType
    status?: $Enums.JobStatus
    customerId: number
    vessel?: string | null
    place?: string | null
    shipperRef?: string | null
    gdNo?: string | null
    gdDate?: Date | string | null
    formE?: string | null
    formEDate?: Date | string | null
    commodity?: string | null
    volume?: string | null
    containerNo?: string | null
    podId?: number | null
    packages?: number | null
    weight?: number | null
    hawbBl?: string | null
    handledBy?: string | null
    salesPerson?: string | null
    companyId: number
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    division?: string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutJobInput
    serviceInvoice?: ServiceInvoiceUncheckedCreateNestedOneWithoutJobInput
    freightInvoice?: FreightInvoiceUncheckedCreateNestedOneWithoutJobInput
  }

  export type JobUpdateInput = {
    jobNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    place?: NullableStringFieldUpdateOperationsInput | string | null
    shipperRef?: NullableStringFieldUpdateOperationsInput | string | null
    gdNo?: NullableStringFieldUpdateOperationsInput | string | null
    gdDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formE?: NullableStringFieldUpdateOperationsInput | string | null
    formEDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commodity?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    containerNo?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    hawbBl?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    salesPerson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUpdateManyWithoutJobNestedInput
    serviceInvoice?: ServiceInvoiceUpdateOneWithoutJobNestedInput
    freightInvoice?: FreightInvoiceUpdateOneWithoutJobNestedInput
    branch?: BranchUpdateOneWithoutJobsNestedInput
    company?: CompanyUpdateOneRequiredWithoutJobsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutJobsNestedInput
    pod?: PortUpdateOneWithoutJobsNestedInput
  }

  export type JobUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    customerId?: IntFieldUpdateOperationsInput | number
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    place?: NullableStringFieldUpdateOperationsInput | string | null
    shipperRef?: NullableStringFieldUpdateOperationsInput | string | null
    gdNo?: NullableStringFieldUpdateOperationsInput | string | null
    gdDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formE?: NullableStringFieldUpdateOperationsInput | string | null
    formEDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commodity?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    containerNo?: NullableStringFieldUpdateOperationsInput | string | null
    podId?: NullableIntFieldUpdateOperationsInput | number | null
    packages?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    hawbBl?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    salesPerson?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutJobNestedInput
    serviceInvoice?: ServiceInvoiceUncheckedUpdateOneWithoutJobNestedInput
    freightInvoice?: FreightInvoiceUncheckedUpdateOneWithoutJobNestedInput
  }

  export type JobCreateManyInput = {
    id?: number
    jobNumber: string
    date?: Date | string
    jobDate?: Date | string
    jobType?: $Enums.JobType
    status?: $Enums.JobStatus
    customerId: number
    vessel?: string | null
    place?: string | null
    shipperRef?: string | null
    gdNo?: string | null
    gdDate?: Date | string | null
    formE?: string | null
    formEDate?: Date | string | null
    commodity?: string | null
    volume?: string | null
    containerNo?: string | null
    podId?: number | null
    packages?: number | null
    weight?: number | null
    hawbBl?: string | null
    handledBy?: string | null
    salesPerson?: string | null
    companyId: number
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    division?: string | null
  }

  export type JobUpdateManyMutationInput = {
    jobNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    place?: NullableStringFieldUpdateOperationsInput | string | null
    shipperRef?: NullableStringFieldUpdateOperationsInput | string | null
    gdNo?: NullableStringFieldUpdateOperationsInput | string | null
    gdDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formE?: NullableStringFieldUpdateOperationsInput | string | null
    formEDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commodity?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    containerNo?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    hawbBl?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    salesPerson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    customerId?: IntFieldUpdateOperationsInput | number
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    place?: NullableStringFieldUpdateOperationsInput | string | null
    shipperRef?: NullableStringFieldUpdateOperationsInput | string | null
    gdNo?: NullableStringFieldUpdateOperationsInput | string | null
    gdDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formE?: NullableStringFieldUpdateOperationsInput | string | null
    formEDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commodity?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    containerNo?: NullableStringFieldUpdateOperationsInput | string | null
    podId?: NullableIntFieldUpdateOperationsInput | number | null
    packages?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    hawbBl?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    salesPerson?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseMasterCreateInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutExpensesMasterInput
  }

  export type ExpenseMasterUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseMasterUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutExpensesMasterNestedInput
  }

  export type ExpenseMasterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseMasterCreateManyInput = {
    id?: number
    code: string
    name: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseMasterUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseMasterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateInput = {
    description: string
    costPrice?: number
    sellingPrice?: number
    currencyCode?: string
    exchangeRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutExpensesInput
    job: JobCreateNestedOneWithoutExpensesInput
    vendor?: VendorCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateInput = {
    id?: number
    jobId: number
    vendorId?: number | null
    description: string
    costPrice?: number
    sellingPrice?: number
    currencyCode?: string
    exchangeRate?: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutExpensesNestedInput
    job?: JobUpdateOneRequiredWithoutExpensesNestedInput
    vendor?: VendorUpdateOneWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobId?: IntFieldUpdateOperationsInput | number
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateManyInput = {
    id?: number
    jobId: number
    vendorId?: number | null
    description: string
    costPrice?: number
    sellingPrice?: number
    currencyCode?: string
    exchangeRate?: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobId?: IntFieldUpdateOperationsInput | number
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceInvoiceCreateInput = {
    invoiceNumber: string
    date?: Date | string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    masterNumber?: string | null
    agentCode?: string | null
    shippingLine?: string | null
    origin?: string | null
    destination?: string | null
    creditDays?: number | null
    vendorType?: string | null
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    exchangeRate?: number
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    company: CompanyCreateNestedOneWithoutServiceInvoicesInput
    customer: CustomerCreateNestedOneWithoutServiceInvoicesInput
    job: JobCreateNestedOneWithoutServiceInvoiceInput
    transaction?: TransactionCreateNestedOneWithoutServiceInput
    items?: ServiceInvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type ServiceInvoiceUncheckedCreateInput = {
    id?: number
    invoiceNumber: string
    date?: Date | string
    jobId: number
    customerId: number
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    masterNumber?: string | null
    agentCode?: string | null
    shippingLine?: string | null
    origin?: string | null
    destination?: string | null
    creditDays?: number | null
    vendorType?: string | null
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    exchangeRate?: number
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId?: number | null
    division?: string | null
    items?: ServiceInvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type ServiceInvoiceUpdateInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    masterNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agentCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingLine?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    creditDays?: NullableIntFieldUpdateOperationsInput | number | null
    vendorType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutServiceInvoicesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutServiceInvoicesNestedInput
    job?: JobUpdateOneRequiredWithoutServiceInvoiceNestedInput
    transaction?: TransactionUpdateOneWithoutServiceNestedInput
    items?: ServiceInvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type ServiceInvoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    masterNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agentCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingLine?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    creditDays?: NullableIntFieldUpdateOperationsInput | number | null
    vendorType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ServiceInvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type ServiceInvoiceCreateManyInput = {
    id?: number
    invoiceNumber: string
    date?: Date | string
    jobId: number
    customerId: number
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    masterNumber?: string | null
    agentCode?: string | null
    shippingLine?: string | null
    origin?: string | null
    destination?: string | null
    creditDays?: number | null
    vendorType?: string | null
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    exchangeRate?: number
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId?: number | null
    division?: string | null
  }

  export type ServiceInvoiceUpdateManyMutationInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    masterNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agentCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingLine?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    creditDays?: NullableIntFieldUpdateOperationsInput | number | null
    vendorType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceInvoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    masterNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agentCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingLine?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    creditDays?: NullableIntFieldUpdateOperationsInput | number | null
    vendorType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceInvoiceItemCreateInput = {
    description: string
    quantity?: number
    rate?: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
    invoice: ServiceInvoiceCreateNestedOneWithoutItemsInput
    product?: ProductCreateNestedOneWithoutServiceItemsInput
  }

  export type ServiceInvoiceItemUncheckedCreateInput = {
    id?: number
    invoiceId: number
    description: string
    quantity?: number
    rate?: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
    productId?: number | null
  }

  export type ServiceInvoiceItemUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    invoice?: ServiceInvoiceUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneWithoutServiceItemsNestedInput
  }

  export type ServiceInvoiceItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ServiceInvoiceItemCreateManyInput = {
    id?: number
    invoiceId: number
    description: string
    quantity?: number
    rate?: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
    productId?: number | null
  }

  export type ServiceInvoiceItemUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type ServiceInvoiceItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FreightInvoiceCreateInput = {
    invoiceNumber: string
    date?: Date | string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    usdRate?: number
    exchangeRate?: number
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    company: CompanyCreateNestedOneWithoutFreightInvoicesInput
    customer: CustomerCreateNestedOneWithoutFreightInvoicesInput
    transaction?: TransactionCreateNestedOneWithoutFreightInput
    job?: JobCreateNestedOneWithoutFreightInvoiceInput
    items?: FreightInvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type FreightInvoiceUncheckedCreateInput = {
    id?: number
    invoiceNumber: string
    date?: Date | string
    jobId?: number | null
    customerId: number
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    usdRate?: number
    exchangeRate?: number
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId?: number | null
    division?: string | null
    items?: FreightInvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type FreightInvoiceUpdateInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    usdRate?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutFreightInvoicesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutFreightInvoicesNestedInput
    transaction?: TransactionUpdateOneWithoutFreightNestedInput
    job?: JobUpdateOneWithoutFreightInvoiceNestedInput
    items?: FreightInvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type FreightInvoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: IntFieldUpdateOperationsInput | number
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    usdRate?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    items?: FreightInvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type FreightInvoiceCreateManyInput = {
    id?: number
    invoiceNumber: string
    date?: Date | string
    jobId?: number | null
    customerId: number
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    usdRate?: number
    exchangeRate?: number
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId?: number | null
    division?: string | null
  }

  export type FreightInvoiceUpdateManyMutationInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    usdRate?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FreightInvoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: IntFieldUpdateOperationsInput | number
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    usdRate?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FreightInvoiceItemCreateInput = {
    description: string
    quantity?: number
    rate?: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
    invoice: FreightInvoiceCreateNestedOneWithoutItemsInput
    vendor?: VendorCreateNestedOneWithoutFreightItemsInput
  }

  export type FreightInvoiceItemUncheckedCreateInput = {
    id?: number
    invoiceId: number
    description: string
    quantity?: number
    rate?: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
    vendorId?: number | null
  }

  export type FreightInvoiceItemUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    invoice?: FreightInvoiceUpdateOneRequiredWithoutItemsNestedInput
    vendor?: VendorUpdateOneWithoutFreightItemsNestedInput
  }

  export type FreightInvoiceItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FreightInvoiceItemCreateManyInput = {
    id?: number
    invoiceId: number
    description: string
    quantity?: number
    rate?: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
    vendorId?: number | null
  }

  export type FreightInvoiceItemUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type FreightInvoiceItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductCategoryCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutCategoryInput
    company: CompanyCreateNestedOneWithoutProductCategoriesInput
  }

  export type ProductCategoryUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutCategoryNestedInput
    company?: CompanyUpdateOneRequiredWithoutProductCategoriesNestedInput
  }

  export type ProductCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    sku?: string | null
    name: string
    description?: string | null
    unit?: string
    purchasePrice?: number
    sellingPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    serviceItems?: ServiceInvoiceItemCreateNestedManyWithoutProductInput
    category: ProductCategoryCreateNestedOneWithoutProductsInput
    company: CompanyCreateNestedOneWithoutProductsInput
    purchaseItems?: PurchaseInvoiceItemCreateNestedManyWithoutProductInput
    movements?: StockMovementCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    sku?: string | null
    name: string
    description?: string | null
    unit?: string
    purchasePrice?: number
    sellingPrice?: number
    categoryId: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    serviceItems?: ServiceInvoiceItemUncheckedCreateNestedManyWithoutProductInput
    purchaseItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutProductInput
    movements?: StockMovementUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceItems?: ServiceInvoiceItemUpdateManyWithoutProductNestedInput
    category?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    company?: CompanyUpdateOneRequiredWithoutProductsNestedInput
    purchaseItems?: PurchaseInvoiceItemUpdateManyWithoutProductNestedInput
    movements?: StockMovementUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceItems?: ServiceInvoiceItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutProductNestedInput
    movements?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    sku?: string | null
    name: string
    description?: string | null
    unit?: string
    purchasePrice?: number
    sellingPrice?: number
    categoryId: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductUpdateManyMutationInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WarehouseCreateInput = {
    name: string
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stockMovements?: StockMovementCreateNestedManyWithoutWarehouseInput
    company: CompanyCreateNestedOneWithoutWarehousesInput
  }

  export type WarehouseUncheckedCreateInput = {
    id?: number
    name: string
    location?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockMovements?: StockMovementUpdateManyWithoutWarehouseNestedInput
    company?: CompanyUpdateOneRequiredWithoutWarehousesNestedInput
  }

  export type WarehouseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockMovements?: StockMovementUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseCreateManyInput = {
    id?: number
    name: string
    location?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementCreateInput = {
    quantity: number
    type: string
    reference?: string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutStockMovementsInput
    product: ProductCreateNestedOneWithoutMovementsInput
    warehouse?: WarehouseCreateNestedOneWithoutStockMovementsInput
  }

  export type StockMovementUncheckedCreateInput = {
    id?: number
    productId: number
    warehouseId?: number | null
    quantity: number
    type: string
    reference?: string | null
    companyId: number
    createdAt?: Date | string
  }

  export type StockMovementUpdateInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutStockMovementsNestedInput
    product?: ProductUpdateOneRequiredWithoutMovementsNestedInput
    warehouse?: WarehouseUpdateOneWithoutStockMovementsNestedInput
  }

  export type StockMovementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    warehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementCreateManyInput = {
    id?: number
    productId: number
    warehouseId?: number | null
    quantity: number
    type: string
    reference?: string | null
    companyId: number
    createdAt?: Date | string
  }

  export type StockMovementUpdateManyMutationInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    warehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceCreateInput = {
    purchaseNumber: string
    date?: Date | string
    status?: $Enums.InvoiceStatus
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutPurchaseInvoicesInput
    transaction?: TransactionCreateNestedOneWithoutPurchaseInput
    vendor: VendorCreateNestedOneWithoutPurchaseInvoicesInput
    items?: PurchaseInvoiceItemCreateNestedManyWithoutPurchaseInvoiceInput
  }

  export type PurchaseInvoiceUncheckedCreateInput = {
    id?: number
    purchaseNumber: string
    date?: Date | string
    vendorId: number
    status?: $Enums.InvoiceStatus
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    companyId: number
    transactionId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutPurchaseInvoiceInput
  }

  export type PurchaseInvoiceUpdateInput = {
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutPurchaseInvoicesNestedInput
    transaction?: TransactionUpdateOneWithoutPurchaseNestedInput
    vendor?: VendorUpdateOneRequiredWithoutPurchaseInvoicesNestedInput
    items?: PurchaseInvoiceItemUpdateManyWithoutPurchaseInvoiceNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: IntFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: PurchaseInvoiceItemUncheckedUpdateManyWithoutPurchaseInvoiceNestedInput
  }

  export type PurchaseInvoiceCreateManyInput = {
    id?: number
    purchaseNumber: string
    date?: Date | string
    vendorId: number
    status?: $Enums.InvoiceStatus
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    companyId: number
    transactionId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PurchaseInvoiceUpdateManyMutationInput = {
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PurchaseInvoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: IntFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PurchaseInvoiceItemCreateInput = {
    description?: string | null
    quantity: number
    rate: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
    product: ProductCreateNestedOneWithoutPurchaseItemsInput
    purchaseInvoice: PurchaseInvoiceCreateNestedOneWithoutItemsInput
  }

  export type PurchaseInvoiceItemUncheckedCreateInput = {
    id?: number
    purchaseInvoiceId: number
    productId: number
    description?: string | null
    quantity: number
    rate: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
  }

  export type PurchaseInvoiceItemUpdateInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutPurchaseItemsNestedInput
    purchaseInvoice?: PurchaseInvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PurchaseInvoiceItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseInvoiceId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type PurchaseInvoiceItemCreateManyInput = {
    id?: number
    purchaseInvoiceId: number
    productId: number
    description?: string | null
    quantity: number
    rate: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
  }

  export type PurchaseInvoiceItemUpdateManyMutationInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseInvoiceId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type AccountCreateInput = {
    code: string
    name: string
    type: $Enums.AccountType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    company: CompanyCreateNestedOneWithoutAccountsInput
    parent?: AccountCreateNestedOneWithoutChildrenInput
    children?: AccountCreateNestedManyWithoutParentInput
    entries?: AccountEntryCreateNestedManyWithoutAccountInput
    customer?: CustomerCreateNestedOneWithoutAccountInput
    vendor?: VendorCreateNestedOneWithoutAccountInput
    voucherEntries?: VoucherEntryCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    type: $Enums.AccountType
    description?: string | null
    parentId?: number | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    children?: AccountUncheckedCreateNestedManyWithoutParentInput
    entries?: AccountEntryUncheckedCreateNestedManyWithoutAccountInput
    customer?: CustomerUncheckedCreateNestedOneWithoutAccountInput
    vendor?: VendorUncheckedCreateNestedOneWithoutAccountInput
    voucherEntries?: VoucherEntryUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutAccountsNestedInput
    parent?: AccountUpdateOneWithoutChildrenNestedInput
    children?: AccountUpdateManyWithoutParentNestedInput
    entries?: AccountEntryUpdateManyWithoutAccountNestedInput
    customer?: CustomerUpdateOneWithoutAccountNestedInput
    vendor?: VendorUpdateOneWithoutAccountNestedInput
    voucherEntries?: VoucherEntryUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    children?: AccountUncheckedUpdateManyWithoutParentNestedInput
    entries?: AccountEntryUncheckedUpdateManyWithoutAccountNestedInput
    customer?: CustomerUncheckedUpdateOneWithoutAccountNestedInput
    vendor?: VendorUncheckedUpdateOneWithoutAccountNestedInput
    voucherEntries?: VoucherEntryUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountCreateManyInput = {
    id?: number
    code: string
    name: string
    type: $Enums.AccountType
    description?: string | null
    parentId?: number | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionCreateInput = {
    reference: string
    date?: Date | string
    description?: string | null
    type?: $Enums.TransactionType
    createdAt?: Date | string
    updatedAt?: Date | string
    isLocked?: boolean
    entries?: AccountEntryCreateNestedManyWithoutTransactionInput
    service?: ServiceInvoiceCreateNestedOneWithoutTransactionInput
    freight?: FreightInvoiceCreateNestedOneWithoutTransactionInput
    payment?: PaymentCreateNestedOneWithoutTransactionInput
    purchase?: PurchaseInvoiceCreateNestedOneWithoutTransactionInput
    company: CompanyCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: number
    reference: string
    date?: Date | string
    description?: string | null
    type?: $Enums.TransactionType
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isLocked?: boolean
    entries?: AccountEntryUncheckedCreateNestedManyWithoutTransactionInput
    service?: ServiceInvoiceUncheckedCreateNestedOneWithoutTransactionInput
    freight?: FreightInvoiceUncheckedCreateNestedOneWithoutTransactionInput
    payment?: PaymentUncheckedCreateNestedOneWithoutTransactionInput
    purchase?: PurchaseInvoiceUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUpdateInput = {
    reference?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    entries?: AccountEntryUpdateManyWithoutTransactionNestedInput
    service?: ServiceInvoiceUpdateOneWithoutTransactionNestedInput
    freight?: FreightInvoiceUpdateOneWithoutTransactionNestedInput
    payment?: PaymentUpdateOneWithoutTransactionNestedInput
    purchase?: PurchaseInvoiceUpdateOneWithoutTransactionNestedInput
    company?: CompanyUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    entries?: AccountEntryUncheckedUpdateManyWithoutTransactionNestedInput
    service?: ServiceInvoiceUncheckedUpdateOneWithoutTransactionNestedInput
    freight?: FreightInvoiceUncheckedUpdateOneWithoutTransactionNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutTransactionNestedInput
    purchase?: PurchaseInvoiceUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionCreateManyInput = {
    id?: number
    reference: string
    date?: Date | string
    description?: string | null
    type?: $Enums.TransactionType
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isLocked?: boolean
  }

  export type TransactionUpdateManyMutationInput = {
    reference?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountEntryCreateInput = {
    description?: string | null
    debit?: number
    credit?: number
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutEntriesInput
    transaction: TransactionCreateNestedOneWithoutEntriesInput
  }

  export type AccountEntryUncheckedCreateInput = {
    id?: number
    transactionId: number
    accountId: number
    description?: string | null
    debit?: number
    credit?: number
    createdAt?: Date | string
  }

  export type AccountEntryUpdateInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutEntriesNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutEntriesNestedInput
  }

  export type AccountEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountEntryCreateManyInput = {
    id?: number
    transactionId: number
    accountId: number
    description?: string | null
    debit?: number
    credit?: number
    createdAt?: Date | string
  }

  export type AccountEntryUpdateManyMutationInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    receiptNumber: string
    date?: Date | string
    amount: number
    mode?: $Enums.PaymentMode
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    company: CompanyCreateNestedOneWithoutPaymentsInput
    customer?: CustomerCreateNestedOneWithoutPaymentsInput
    transaction: TransactionCreateNestedOneWithoutPaymentInput
    vendor?: VendorCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    receiptNumber: string
    date?: Date | string
    amount: number
    mode?: $Enums.PaymentMode
    reference?: string | null
    customerId?: number | null
    vendorId?: number | null
    transactionId: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
  }

  export type PaymentUpdateInput = {
    receiptNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    mode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutPaymentsNestedInput
    customer?: CustomerUpdateOneWithoutPaymentsNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutPaymentNestedInput
    vendor?: VendorUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    mode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    transactionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateManyInput = {
    id?: number
    receiptNumber: string
    date?: Date | string
    amount: number
    mode?: $Enums.PaymentMode
    reference?: string | null
    customerId?: number | null
    vendorId?: number | null
    transactionId: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
  }

  export type PaymentUpdateManyMutationInput = {
    receiptNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    mode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    mode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    transactionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogCreateInput = {
    action: string
    module: string
    entityId?: number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutAuditLogsInput
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: number
    userId: number
    action: string
    module: string
    entityId?: number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
    companyId: number
  }

  export type AuditLogUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAuditLogsNestedInput
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
  }

  export type AuditLogCreateManyInput = {
    id?: number
    userId: number
    action: string
    module: string
    entityId?: number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
    companyId: number
  }

  export type AuditLogUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
  }

  export type FinancialPeriodCreateInput = {
    month: number
    year: number
    isClosed?: boolean
    closedById?: number | null
    closedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutFinancialPeriodsInput
  }

  export type FinancialPeriodUncheckedCreateInput = {
    id?: number
    month: number
    year: number
    isClosed?: boolean
    closedById?: number | null
    closedAt?: Date | string | null
    companyId: number
  }

  export type FinancialPeriodUpdateInput = {
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedById?: NullableIntFieldUpdateOperationsInput | number | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutFinancialPeriodsNestedInput
  }

  export type FinancialPeriodUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedById?: NullableIntFieldUpdateOperationsInput | number | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: IntFieldUpdateOperationsInput | number
  }

  export type FinancialPeriodCreateManyInput = {
    id?: number
    month: number
    year: number
    isClosed?: boolean
    closedById?: number | null
    closedAt?: Date | string | null
    companyId: number
  }

  export type FinancialPeriodUpdateManyMutationInput = {
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedById?: NullableIntFieldUpdateOperationsInput | number | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FinancialPeriodUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedById?: NullableIntFieldUpdateOperationsInput | number | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: IntFieldUpdateOperationsInput | number
  }

  export type PortCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobCreateNestedManyWithoutPodInput
    company: CompanyCreateNestedOneWithoutPortsInput
  }

  export type PortUncheckedCreateInput = {
    id?: number
    name: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutPodInput
  }

  export type PortUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUpdateManyWithoutPodNestedInput
    company?: CompanyUpdateOneRequiredWithoutPortsNestedInput
  }

  export type PortUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutPodNestedInput
  }

  export type PortCreateManyInput = {
    id?: number
    name: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherCreateInput = {
    voucherNumber: string
    voucherType: $Enums.VoucherType
    status?: $Enums.VoucherStatus
    date?: Date | string
    postingDate?: Date | string | null
    paymentMode?: $Enums.PaymentMode | null
    instrumentNo?: string | null
    instrumentDate?: Date | string | null
    bankName?: string | null
    narration?: string | null
    division?: string | null
    isPosted?: boolean
    postedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutVouchersInput
    postedBy?: UserCreateNestedOneWithoutPostedVouchersInput
    entries?: VoucherEntryCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUncheckedCreateInput = {
    id?: number
    voucherNumber: string
    voucherType: $Enums.VoucherType
    status?: $Enums.VoucherStatus
    date?: Date | string
    postingDate?: Date | string | null
    paymentMode?: $Enums.PaymentMode | null
    instrumentNo?: string | null
    instrumentDate?: Date | string | null
    bankName?: string | null
    narration?: string | null
    companyId: number
    division?: string | null
    isPosted?: boolean
    postedAt?: Date | string | null
    postedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    entries?: VoucherEntryUncheckedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUpdateInput = {
    voucherNumber?: StringFieldUpdateOperationsInput | string
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    postingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    instrumentNo?: NullableStringFieldUpdateOperationsInput | string | null
    instrumentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutVouchersNestedInput
    postedBy?: UserUpdateOneWithoutPostedVouchersNestedInput
    entries?: VoucherEntryUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    voucherNumber?: StringFieldUpdateOperationsInput | string
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    postingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    instrumentNo?: NullableStringFieldUpdateOperationsInput | string | null
    instrumentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    division?: NullableStringFieldUpdateOperationsInput | string | null
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: VoucherEntryUncheckedUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherCreateManyInput = {
    id?: number
    voucherNumber: string
    voucherType: $Enums.VoucherType
    status?: $Enums.VoucherStatus
    date?: Date | string
    postingDate?: Date | string | null
    paymentMode?: $Enums.PaymentMode | null
    instrumentNo?: string | null
    instrumentDate?: Date | string | null
    bankName?: string | null
    narration?: string | null
    companyId: number
    division?: string | null
    isPosted?: boolean
    postedAt?: Date | string | null
    postedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoucherUpdateManyMutationInput = {
    voucherNumber?: StringFieldUpdateOperationsInput | string
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    postingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    instrumentNo?: NullableStringFieldUpdateOperationsInput | string | null
    instrumentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    voucherNumber?: StringFieldUpdateOperationsInput | string
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    postingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    instrumentNo?: NullableStringFieldUpdateOperationsInput | string | null
    instrumentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    division?: NullableStringFieldUpdateOperationsInput | string | null
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherEntryCreateInput = {
    debit?: number
    credit?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutVoucherEntriesInput
    voucher: VoucherCreateNestedOneWithoutEntriesInput
  }

  export type VoucherEntryUncheckedCreateInput = {
    id?: number
    voucherId: number
    accountId: number
    debit?: number
    credit?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoucherEntryUpdateInput = {
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutVoucherEntriesNestedInput
    voucher?: VoucherUpdateOneRequiredWithoutEntriesNestedInput
  }

  export type VoucherEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    voucherId?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherEntryCreateManyInput = {
    id?: number
    voucherId: number
    accountId: number
    debit?: number
    credit?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoucherEntryUpdateManyMutationInput = {
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    voucherId?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type BranchListRelationFilter = {
    every?: BranchWhereInput
    some?: BranchWhereInput
    none?: BranchWhereInput
  }

  export type CompanyCurrencyListRelationFilter = {
    every?: CompanyCurrencyWhereInput
    some?: CompanyCurrencyWhereInput
    none?: CompanyCurrencyWhereInput
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type ExpenseListRelationFilter = {
    every?: ExpenseWhereInput
    some?: ExpenseWhereInput
    none?: ExpenseWhereInput
  }

  export type ExpenseMasterListRelationFilter = {
    every?: ExpenseMasterWhereInput
    some?: ExpenseMasterWhereInput
    none?: ExpenseMasterWhereInput
  }

  export type FinancialPeriodListRelationFilter = {
    every?: FinancialPeriodWhereInput
    some?: FinancialPeriodWhereInput
    none?: FinancialPeriodWhereInput
  }

  export type ServiceInvoiceListRelationFilter = {
    every?: ServiceInvoiceWhereInput
    some?: ServiceInvoiceWhereInput
    none?: ServiceInvoiceWhereInput
  }

  export type FreightInvoiceListRelationFilter = {
    every?: FreightInvoiceWhereInput
    some?: FreightInvoiceWhereInput
    none?: FreightInvoiceWhereInput
  }

  export type JobListRelationFilter = {
    every?: JobWhereInput
    some?: JobWhereInput
    none?: JobWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PortListRelationFilter = {
    every?: PortWhereInput
    some?: PortWhereInput
    none?: PortWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductCategoryListRelationFilter = {
    every?: ProductCategoryWhereInput
    some?: ProductCategoryWhereInput
    none?: ProductCategoryWhereInput
  }

  export type PurchaseInvoiceListRelationFilter = {
    every?: PurchaseInvoiceWhereInput
    some?: PurchaseInvoiceWhereInput
    none?: PurchaseInvoiceWhereInput
  }

  export type StockMovementListRelationFilter = {
    every?: StockMovementWhereInput
    some?: StockMovementWhereInput
    none?: StockMovementWhereInput
  }

  export type SystemSettingListRelationFilter = {
    every?: SystemSettingWhereInput
    some?: SystemSettingWhereInput
    none?: SystemSettingWhereInput
  }

  export type TaxSettingListRelationFilter = {
    every?: TaxSettingWhereInput
    some?: TaxSettingWhereInput
    none?: TaxSettingWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type VendorListRelationFilter = {
    every?: VendorWhereInput
    some?: VendorWhereInput
    none?: VendorWhereInput
  }

  export type VoucherListRelationFilter = {
    every?: VoucherWhereInput
    some?: VoucherWhereInput
    none?: VoucherWhereInput
  }

  export type WarehouseListRelationFilter = {
    every?: WarehouseWhereInput
    some?: WarehouseWhereInput
    none?: WarehouseWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCurrencyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseMasterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FinancialPeriodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FreightInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PortOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockMovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SystemSettingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaxSettingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VoucherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarehouseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    uniqueId?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    industry?: SortOrder
    logo?: SortOrder
    themeConfig?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    city?: SortOrder
    country?: SortOrder
    fiscalYearEnd?: SortOrder
    fiscalYearStart?: SortOrder
    postalCode?: SortOrder
    registrationNo?: SortOrder
    state?: SortOrder
    tagline?: SortOrder
    taxNumber?: SortOrder
    website?: SortOrder
  }

  export type CompanyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    uniqueId?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    industry?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    city?: SortOrder
    country?: SortOrder
    fiscalYearEnd?: SortOrder
    fiscalYearStart?: SortOrder
    postalCode?: SortOrder
    registrationNo?: SortOrder
    state?: SortOrder
    tagline?: SortOrder
    taxNumber?: SortOrder
    website?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    uniqueId?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    industry?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    city?: SortOrder
    country?: SortOrder
    fiscalYearEnd?: SortOrder
    fiscalYearStart?: SortOrder
    postalCode?: SortOrder
    registrationNo?: SortOrder
    state?: SortOrder
    tagline?: SortOrder
    taxNumber?: SortOrder
    website?: SortOrder
  }

  export type CompanySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type CompanyScalarRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type BranchCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type BranchMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type CurrencyCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
  }

  export type CurrencyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CurrencyMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
  }

  export type CurrencyMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
  }

  export type CurrencySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CurrencyScalarRelationFilter = {
    is?: CurrencyWhereInput
    isNot?: CurrencyWhereInput
  }

  export type CompanyCurrencyCompanyIdCurrencyIdCompoundUniqueInput = {
    companyId: number
    currencyId: number
  }

  export type CompanyCurrencyCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    currencyId?: SortOrder
    exchangeRate?: SortOrder
    isDefault?: SortOrder
  }

  export type CompanyCurrencyAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    currencyId?: SortOrder
    exchangeRate?: SortOrder
  }

  export type CompanyCurrencyMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    currencyId?: SortOrder
    exchangeRate?: SortOrder
    isDefault?: SortOrder
  }

  export type CompanyCurrencyMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    currencyId?: SortOrder
    exchangeRate?: SortOrder
    isDefault?: SortOrder
  }

  export type CompanyCurrencySumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    currencyId?: SortOrder
    exchangeRate?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BranchNullableScalarRelationFilter = {
    is?: BranchWhereInput | null
    isNot?: BranchWhereInput | null
  }

  export type TaxSettingCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    percentage?: SortOrder
    type?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxSettingAvgOrderByAggregateInput = {
    id?: SortOrder
    percentage?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
  }

  export type TaxSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    percentage?: SortOrder
    type?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxSettingMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    percentage?: SortOrder
    type?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxSettingSumOrderByAggregateInput = {
    id?: SortOrder
    percentage?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SystemSettingCompanyIdKeyCompoundUniqueInput = {
    companyId: number
    key: string
  }

  export type SystemSettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type SystemSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type CompanyNullableScalarRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    companyId?: SortOrder
    branch?: SortOrder
    department?: SortOrder
    region?: SortOrder
    division?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    companyId?: SortOrder
    branch?: SortOrder
    department?: SortOrder
    region?: SortOrder
    division?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    companyId?: SortOrder
    branch?: SortOrder
    department?: SortOrder
    region?: SortOrder
    division?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type AccountNullableScalarRelationFilter = {
    is?: AccountWhereInput | null
    isNot?: AccountWhereInput | null
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    taxNumber?: SortOrder
    accountId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    division?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    companyId?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    taxNumber?: SortOrder
    accountId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    division?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    taxNumber?: SortOrder
    accountId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    division?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    companyId?: SortOrder
  }

  export type FreightInvoiceItemListRelationFilter = {
    every?: FreightInvoiceItemWhereInput
    some?: FreightInvoiceItemWhereInput
    none?: FreightInvoiceItemWhereInput
  }

  export type FreightInvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    type?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    taxNumber?: SortOrder
    accountId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    division?: SortOrder
  }

  export type VendorAvgOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    companyId?: SortOrder
  }

  export type VendorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    type?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    taxNumber?: SortOrder
    accountId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    division?: SortOrder
  }

  export type VendorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    type?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    taxNumber?: SortOrder
    accountId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    division?: SortOrder
  }

  export type VendorSumOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    companyId?: SortOrder
  }

  export type EnumJobTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobTypeFilter<$PrismaModel> | $Enums.JobType
  }

  export type EnumJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusFilter<$PrismaModel> | $Enums.JobStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ServiceInvoiceNullableScalarRelationFilter = {
    is?: ServiceInvoiceWhereInput | null
    isNot?: ServiceInvoiceWhereInput | null
  }

  export type FreightInvoiceNullableScalarRelationFilter = {
    is?: FreightInvoiceWhereInput | null
    isNot?: FreightInvoiceWhereInput | null
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type PortNullableScalarRelationFilter = {
    is?: PortWhereInput | null
    isNot?: PortWhereInput | null
  }

  export type JobCountOrderByAggregateInput = {
    id?: SortOrder
    jobNumber?: SortOrder
    date?: SortOrder
    jobDate?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    customerId?: SortOrder
    vessel?: SortOrder
    place?: SortOrder
    shipperRef?: SortOrder
    gdNo?: SortOrder
    gdDate?: SortOrder
    formE?: SortOrder
    formEDate?: SortOrder
    commodity?: SortOrder
    volume?: SortOrder
    containerNo?: SortOrder
    podId?: SortOrder
    packages?: SortOrder
    weight?: SortOrder
    hawbBl?: SortOrder
    handledBy?: SortOrder
    salesPerson?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    division?: SortOrder
  }

  export type JobAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    podId?: SortOrder
    packages?: SortOrder
    weight?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
  }

  export type JobMaxOrderByAggregateInput = {
    id?: SortOrder
    jobNumber?: SortOrder
    date?: SortOrder
    jobDate?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    customerId?: SortOrder
    vessel?: SortOrder
    place?: SortOrder
    shipperRef?: SortOrder
    gdNo?: SortOrder
    gdDate?: SortOrder
    formE?: SortOrder
    formEDate?: SortOrder
    commodity?: SortOrder
    volume?: SortOrder
    containerNo?: SortOrder
    podId?: SortOrder
    packages?: SortOrder
    weight?: SortOrder
    hawbBl?: SortOrder
    handledBy?: SortOrder
    salesPerson?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    division?: SortOrder
  }

  export type JobMinOrderByAggregateInput = {
    id?: SortOrder
    jobNumber?: SortOrder
    date?: SortOrder
    jobDate?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    customerId?: SortOrder
    vessel?: SortOrder
    place?: SortOrder
    shipperRef?: SortOrder
    gdNo?: SortOrder
    gdDate?: SortOrder
    formE?: SortOrder
    formEDate?: SortOrder
    commodity?: SortOrder
    volume?: SortOrder
    containerNo?: SortOrder
    podId?: SortOrder
    packages?: SortOrder
    weight?: SortOrder
    hawbBl?: SortOrder
    handledBy?: SortOrder
    salesPerson?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    division?: SortOrder
  }

  export type JobSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    podId?: SortOrder
    packages?: SortOrder
    weight?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
  }

  export type EnumJobTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobTypeWithAggregatesFilter<$PrismaModel> | $Enums.JobType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobTypeFilter<$PrismaModel>
    _max?: NestedEnumJobTypeFilter<$PrismaModel>
  }

  export type EnumJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobStatusFilter<$PrismaModel>
    _max?: NestedEnumJobStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ExpenseMasterCompanyIdCodeCompoundUniqueInput = {
    companyId: number
    code: string
  }

  export type ExpenseMasterCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseMasterAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type ExpenseMasterMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseMasterMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseMasterSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type JobScalarRelationFilter = {
    is?: JobWhereInput
    isNot?: JobWhereInput
  }

  export type VendorNullableScalarRelationFilter = {
    is?: VendorWhereInput | null
    isNot?: VendorWhereInput | null
  }

  export type ExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    vendorId?: SortOrder
    description?: SortOrder
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    currencyCode?: SortOrder
    exchangeRate?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    vendorId?: SortOrder
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    exchangeRate?: SortOrder
    companyId?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    vendorId?: SortOrder
    description?: SortOrder
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    currencyCode?: SortOrder
    exchangeRate?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    vendorId?: SortOrder
    description?: SortOrder
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    currencyCode?: SortOrder
    exchangeRate?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    vendorId?: SortOrder
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    exchangeRate?: SortOrder
    companyId?: SortOrder
  }

  export type EnumInvoiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeFilter<$PrismaModel> | $Enums.InvoiceType
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type TransactionNullableScalarRelationFilter = {
    is?: TransactionWhereInput | null
    isNot?: TransactionWhereInput | null
  }

  export type ServiceInvoiceItemListRelationFilter = {
    every?: ServiceInvoiceItemWhereInput
    some?: ServiceInvoiceItemWhereInput
    none?: ServiceInvoiceItemWhereInput
  }

  export type ServiceInvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceInvoiceCompanyIdInvoiceNumberCompoundUniqueInput = {
    companyId: number
    invoiceNumber: string
  }

  export type ServiceInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    date?: SortOrder
    jobId?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    masterNumber?: SortOrder
    agentCode?: SortOrder
    shippingLine?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    creditDays?: SortOrder
    vendorType?: SortOrder
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    grandTotal?: SortOrder
    currencyCode?: SortOrder
    exchangeRate?: SortOrder
    isApproved?: SortOrder
    approvedById?: SortOrder
    isLocked?: SortOrder
    lockedAt?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactionId?: SortOrder
    division?: SortOrder
  }

  export type ServiceInvoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    customerId?: SortOrder
    creditDays?: SortOrder
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    grandTotal?: SortOrder
    exchangeRate?: SortOrder
    approvedById?: SortOrder
    companyId?: SortOrder
    transactionId?: SortOrder
  }

  export type ServiceInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    date?: SortOrder
    jobId?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    masterNumber?: SortOrder
    agentCode?: SortOrder
    shippingLine?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    creditDays?: SortOrder
    vendorType?: SortOrder
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    grandTotal?: SortOrder
    currencyCode?: SortOrder
    exchangeRate?: SortOrder
    isApproved?: SortOrder
    approvedById?: SortOrder
    isLocked?: SortOrder
    lockedAt?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactionId?: SortOrder
    division?: SortOrder
  }

  export type ServiceInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    date?: SortOrder
    jobId?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    masterNumber?: SortOrder
    agentCode?: SortOrder
    shippingLine?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    creditDays?: SortOrder
    vendorType?: SortOrder
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    grandTotal?: SortOrder
    currencyCode?: SortOrder
    exchangeRate?: SortOrder
    isApproved?: SortOrder
    approvedById?: SortOrder
    isLocked?: SortOrder
    lockedAt?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactionId?: SortOrder
    division?: SortOrder
  }

  export type ServiceInvoiceSumOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    customerId?: SortOrder
    creditDays?: SortOrder
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    grandTotal?: SortOrder
    exchangeRate?: SortOrder
    approvedById?: SortOrder
    companyId?: SortOrder
    transactionId?: SortOrder
  }

  export type EnumInvoiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceTypeFilter<$PrismaModel>
    _max?: NestedEnumInvoiceTypeFilter<$PrismaModel>
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type ServiceInvoiceScalarRelationFilter = {
    is?: ServiceInvoiceWhereInput
    isNot?: ServiceInvoiceWhereInput
  }

  export type ProductNullableScalarRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type ServiceInvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    taxPercentage?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    productId?: SortOrder
  }

  export type ServiceInvoiceItemAvgOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    quantity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    taxPercentage?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    productId?: SortOrder
  }

  export type ServiceInvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    taxPercentage?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    productId?: SortOrder
  }

  export type ServiceInvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    taxPercentage?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    productId?: SortOrder
  }

  export type ServiceInvoiceItemSumOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    quantity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    taxPercentage?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    productId?: SortOrder
  }

  export type JobNullableScalarRelationFilter = {
    is?: JobWhereInput | null
    isNot?: JobWhereInput | null
  }

  export type FreightInvoiceCompanyIdInvoiceNumberCompoundUniqueInput = {
    companyId: number
    invoiceNumber: string
  }

  export type FreightInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    date?: SortOrder
    jobId?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    usdRate?: SortOrder
    exchangeRate?: SortOrder
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    grandTotal?: SortOrder
    currencyCode?: SortOrder
    isApproved?: SortOrder
    approvedById?: SortOrder
    isLocked?: SortOrder
    lockedAt?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactionId?: SortOrder
    division?: SortOrder
  }

  export type FreightInvoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    customerId?: SortOrder
    usdRate?: SortOrder
    exchangeRate?: SortOrder
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    grandTotal?: SortOrder
    approvedById?: SortOrder
    companyId?: SortOrder
    transactionId?: SortOrder
  }

  export type FreightInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    date?: SortOrder
    jobId?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    usdRate?: SortOrder
    exchangeRate?: SortOrder
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    grandTotal?: SortOrder
    currencyCode?: SortOrder
    isApproved?: SortOrder
    approvedById?: SortOrder
    isLocked?: SortOrder
    lockedAt?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactionId?: SortOrder
    division?: SortOrder
  }

  export type FreightInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    date?: SortOrder
    jobId?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    usdRate?: SortOrder
    exchangeRate?: SortOrder
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    grandTotal?: SortOrder
    currencyCode?: SortOrder
    isApproved?: SortOrder
    approvedById?: SortOrder
    isLocked?: SortOrder
    lockedAt?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactionId?: SortOrder
    division?: SortOrder
  }

  export type FreightInvoiceSumOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    customerId?: SortOrder
    usdRate?: SortOrder
    exchangeRate?: SortOrder
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    grandTotal?: SortOrder
    approvedById?: SortOrder
    companyId?: SortOrder
    transactionId?: SortOrder
  }

  export type FreightInvoiceScalarRelationFilter = {
    is?: FreightInvoiceWhereInput
    isNot?: FreightInvoiceWhereInput
  }

  export type FreightInvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    taxPercentage?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    vendorId?: SortOrder
  }

  export type FreightInvoiceItemAvgOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    quantity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    taxPercentage?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    vendorId?: SortOrder
  }

  export type FreightInvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    taxPercentage?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    vendorId?: SortOrder
  }

  export type FreightInvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    taxPercentage?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    vendorId?: SortOrder
  }

  export type FreightInvoiceItemSumOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    quantity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    taxPercentage?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    vendorId?: SortOrder
  }

  export type ProductCategoryCompanyIdNameCompoundUniqueInput = {
    companyId: number
    name: string
  }

  export type ProductCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type ProductCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategorySumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type ProductCategoryScalarRelationFilter = {
    is?: ProductCategoryWhereInput
    isNot?: ProductCategoryWhereInput
  }

  export type PurchaseInvoiceItemListRelationFilter = {
    every?: PurchaseInvoiceItemWhereInput
    some?: PurchaseInvoiceItemWhereInput
    none?: PurchaseInvoiceItemWhereInput
  }

  export type PurchaseInvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCompanyIdNameCompoundUniqueInput = {
    companyId: number
    name: string
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
    categoryId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
    categoryId?: SortOrder
    companyId?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
    categoryId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
    categoryId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
    categoryId?: SortOrder
    companyId?: SortOrder
  }

  export type WarehouseCompanyIdNameCompoundUniqueInput = {
    companyId: number
    name: string
  }

  export type WarehouseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type WarehouseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type WarehouseNullableScalarRelationFilter = {
    is?: WarehouseWhereInput | null
    isNot?: WarehouseWhereInput | null
  }

  export type StockMovementCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    quantity?: SortOrder
    type?: SortOrder
    reference?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMovementAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    quantity?: SortOrder
    companyId?: SortOrder
  }

  export type StockMovementMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    quantity?: SortOrder
    type?: SortOrder
    reference?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMovementMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    quantity?: SortOrder
    type?: SortOrder
    reference?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMovementSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    quantity?: SortOrder
    companyId?: SortOrder
  }

  export type VendorScalarRelationFilter = {
    is?: VendorWhereInput
    isNot?: VendorWhereInput
  }

  export type PurchaseInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseNumber?: SortOrder
    date?: SortOrder
    vendorId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    grandTotal?: SortOrder
    currencyCode?: SortOrder
    isApproved?: SortOrder
    approvedById?: SortOrder
    isLocked?: SortOrder
    lockedAt?: SortOrder
    companyId?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PurchaseInvoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    grandTotal?: SortOrder
    approvedById?: SortOrder
    companyId?: SortOrder
    transactionId?: SortOrder
  }

  export type PurchaseInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseNumber?: SortOrder
    date?: SortOrder
    vendorId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    grandTotal?: SortOrder
    currencyCode?: SortOrder
    isApproved?: SortOrder
    approvedById?: SortOrder
    isLocked?: SortOrder
    lockedAt?: SortOrder
    companyId?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PurchaseInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseNumber?: SortOrder
    date?: SortOrder
    vendorId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    grandTotal?: SortOrder
    currencyCode?: SortOrder
    isApproved?: SortOrder
    approvedById?: SortOrder
    isLocked?: SortOrder
    lockedAt?: SortOrder
    companyId?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PurchaseInvoiceSumOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    grandTotal?: SortOrder
    approvedById?: SortOrder
    companyId?: SortOrder
    transactionId?: SortOrder
  }

  export type PurchaseInvoiceScalarRelationFilter = {
    is?: PurchaseInvoiceWhereInput
    isNot?: PurchaseInvoiceWhereInput
  }

  export type PurchaseInvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseInvoiceId?: SortOrder
    productId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    taxPercentage?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
  }

  export type PurchaseInvoiceItemAvgOrderByAggregateInput = {
    id?: SortOrder
    purchaseInvoiceId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    taxPercentage?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
  }

  export type PurchaseInvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseInvoiceId?: SortOrder
    productId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    taxPercentage?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
  }

  export type PurchaseInvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseInvoiceId?: SortOrder
    productId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    taxPercentage?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
  }

  export type PurchaseInvoiceItemSumOrderByAggregateInput = {
    id?: SortOrder
    purchaseInvoiceId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    taxPercentage?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
  }

  export type EnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type AccountEntryListRelationFilter = {
    every?: AccountEntryWhereInput
    some?: AccountEntryWhereInput
    none?: AccountEntryWhereInput
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type VoucherEntryListRelationFilter = {
    every?: VoucherEntryWhereInput
    some?: VoucherEntryWhereInput
    none?: VoucherEntryWhereInput
  }

  export type AccountEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VoucherEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountCompanyIdCodeCompoundUniqueInput = {
    companyId: number
    code: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    division?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    companyId?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    division?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    division?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    companyId?: SortOrder
  }

  export type EnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type PaymentNullableScalarRelationFilter = {
    is?: PaymentWhereInput | null
    isNot?: PaymentWhereInput | null
  }

  export type PurchaseInvoiceNullableScalarRelationFilter = {
    is?: PurchaseInvoiceWhereInput | null
    isNot?: PurchaseInvoiceWhereInput | null
  }

  export type TransactionCompanyIdReferenceCompoundUniqueInput = {
    companyId: number
    reference: string
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    date?: SortOrder
    description?: SortOrder
    type?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isLocked?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    date?: SortOrder
    description?: SortOrder
    type?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isLocked?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    date?: SortOrder
    description?: SortOrder
    type?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isLocked?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type AccountScalarRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type TransactionScalarRelationFilter = {
    is?: TransactionWhereInput
    isNot?: TransactionWhereInput
  }

  export type AccountEntryCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    accountId?: SortOrder
    description?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    createdAt?: SortOrder
  }

  export type AccountEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    accountId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
  }

  export type AccountEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    accountId?: SortOrder
    description?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    createdAt?: SortOrder
  }

  export type AccountEntryMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    accountId?: SortOrder
    description?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    createdAt?: SortOrder
  }

  export type AccountEntrySumOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    accountId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
  }

  export type EnumPaymentModeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentModeFilter<$PrismaModel> | $Enums.PaymentMode
  }

  export type PaymentCompanyIdReceiptNumberCompoundUniqueInput = {
    companyId: number
    receiptNumber: string
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    receiptNumber?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    mode?: SortOrder
    reference?: SortOrder
    customerId?: SortOrder
    vendorId?: SortOrder
    transactionId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    division?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    customerId?: SortOrder
    vendorId?: SortOrder
    transactionId?: SortOrder
    companyId?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    receiptNumber?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    mode?: SortOrder
    reference?: SortOrder
    customerId?: SortOrder
    vendorId?: SortOrder
    transactionId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    division?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    receiptNumber?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    mode?: SortOrder
    reference?: SortOrder
    customerId?: SortOrder
    vendorId?: SortOrder
    transactionId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    division?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    customerId?: SortOrder
    vendorId?: SortOrder
    transactionId?: SortOrder
    companyId?: SortOrder
  }

  export type EnumPaymentModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentModeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentModeFilter<$PrismaModel>
    _max?: NestedEnumPaymentModeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    module?: SortOrder
    entityId?: SortOrder
    payload?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
  }

  export type AuditLogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
    companyId?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    module?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    module?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
  }

  export type AuditLogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
    companyId?: SortOrder
  }

  export type FinancialPeriodCompanyIdMonthYearCompoundUniqueInput = {
    companyId: number
    month: number
    year: number
  }

  export type FinancialPeriodCountOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    isClosed?: SortOrder
    closedById?: SortOrder
    closedAt?: SortOrder
    companyId?: SortOrder
  }

  export type FinancialPeriodAvgOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    closedById?: SortOrder
    companyId?: SortOrder
  }

  export type FinancialPeriodMaxOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    isClosed?: SortOrder
    closedById?: SortOrder
    closedAt?: SortOrder
    companyId?: SortOrder
  }

  export type FinancialPeriodMinOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    isClosed?: SortOrder
    closedById?: SortOrder
    closedAt?: SortOrder
    companyId?: SortOrder
  }

  export type FinancialPeriodSumOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    closedById?: SortOrder
    companyId?: SortOrder
  }

  export type PortCompanyIdNameCompoundUniqueInput = {
    companyId: number
    name: string
  }

  export type PortCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type PortMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type EnumVoucherTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherType | EnumVoucherTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoucherTypeFilter<$PrismaModel> | $Enums.VoucherType
  }

  export type EnumVoucherStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherStatus | EnumVoucherStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherStatus[] | ListEnumVoucherStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoucherStatus[] | ListEnumVoucherStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVoucherStatusFilter<$PrismaModel> | $Enums.VoucherStatus
  }

  export type EnumPaymentModeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentModeNullableFilter<$PrismaModel> | $Enums.PaymentMode | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type VoucherCompanyIdVoucherNumberCompoundUniqueInput = {
    companyId: number
    voucherNumber: string
  }

  export type VoucherCountOrderByAggregateInput = {
    id?: SortOrder
    voucherNumber?: SortOrder
    voucherType?: SortOrder
    status?: SortOrder
    date?: SortOrder
    postingDate?: SortOrder
    paymentMode?: SortOrder
    instrumentNo?: SortOrder
    instrumentDate?: SortOrder
    bankName?: SortOrder
    narration?: SortOrder
    companyId?: SortOrder
    division?: SortOrder
    isPosted?: SortOrder
    postedAt?: SortOrder
    postedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoucherAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    postedById?: SortOrder
  }

  export type VoucherMaxOrderByAggregateInput = {
    id?: SortOrder
    voucherNumber?: SortOrder
    voucherType?: SortOrder
    status?: SortOrder
    date?: SortOrder
    postingDate?: SortOrder
    paymentMode?: SortOrder
    instrumentNo?: SortOrder
    instrumentDate?: SortOrder
    bankName?: SortOrder
    narration?: SortOrder
    companyId?: SortOrder
    division?: SortOrder
    isPosted?: SortOrder
    postedAt?: SortOrder
    postedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoucherMinOrderByAggregateInput = {
    id?: SortOrder
    voucherNumber?: SortOrder
    voucherType?: SortOrder
    status?: SortOrder
    date?: SortOrder
    postingDate?: SortOrder
    paymentMode?: SortOrder
    instrumentNo?: SortOrder
    instrumentDate?: SortOrder
    bankName?: SortOrder
    narration?: SortOrder
    companyId?: SortOrder
    division?: SortOrder
    isPosted?: SortOrder
    postedAt?: SortOrder
    postedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoucherSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    postedById?: SortOrder
  }

  export type EnumVoucherTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherType | EnumVoucherTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoucherTypeWithAggregatesFilter<$PrismaModel> | $Enums.VoucherType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoucherTypeFilter<$PrismaModel>
    _max?: NestedEnumVoucherTypeFilter<$PrismaModel>
  }

  export type EnumVoucherStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherStatus | EnumVoucherStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherStatus[] | ListEnumVoucherStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoucherStatus[] | ListEnumVoucherStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVoucherStatusWithAggregatesFilter<$PrismaModel> | $Enums.VoucherStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoucherStatusFilter<$PrismaModel>
    _max?: NestedEnumVoucherStatusFilter<$PrismaModel>
  }

  export type EnumPaymentModeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentModeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMode | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentModeNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentModeNullableFilter<$PrismaModel>
  }

  export type VoucherScalarRelationFilter = {
    is?: VoucherWhereInput
    isNot?: VoucherWhereInput
  }

  export type VoucherEntryCountOrderByAggregateInput = {
    id?: SortOrder
    voucherId?: SortOrder
    accountId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoucherEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    voucherId?: SortOrder
    accountId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
  }

  export type VoucherEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    voucherId?: SortOrder
    accountId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoucherEntryMinOrderByAggregateInput = {
    id?: SortOrder
    voucherId?: SortOrder
    accountId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoucherEntrySumOrderByAggregateInput = {
    id?: SortOrder
    voucherId?: SortOrder
    accountId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
  }

  export type AccountCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AccountCreateWithoutCompanyInput, AccountUncheckedCreateWithoutCompanyInput> | AccountCreateWithoutCompanyInput[] | AccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCompanyInput | AccountCreateOrConnectWithoutCompanyInput[]
    createMany?: AccountCreateManyCompanyInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type BranchCreateNestedManyWithoutCompanyInput = {
    create?: XOR<BranchCreateWithoutCompanyInput, BranchUncheckedCreateWithoutCompanyInput> | BranchCreateWithoutCompanyInput[] | BranchUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutCompanyInput | BranchCreateOrConnectWithoutCompanyInput[]
    createMany?: BranchCreateManyCompanyInputEnvelope
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type CompanyCurrencyCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyCurrencyCreateWithoutCompanyInput, CompanyCurrencyUncheckedCreateWithoutCompanyInput> | CompanyCurrencyCreateWithoutCompanyInput[] | CompanyCurrencyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyCurrencyCreateOrConnectWithoutCompanyInput | CompanyCurrencyCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyCurrencyCreateManyCompanyInputEnvelope
    connect?: CompanyCurrencyWhereUniqueInput | CompanyCurrencyWhereUniqueInput[]
  }

  export type CustomerCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CustomerCreateWithoutCompanyInput, CustomerUncheckedCreateWithoutCompanyInput> | CustomerCreateWithoutCompanyInput[] | CustomerUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutCompanyInput | CustomerCreateOrConnectWithoutCompanyInput[]
    createMany?: CustomerCreateManyCompanyInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ExpenseCreateWithoutCompanyInput, ExpenseUncheckedCreateWithoutCompanyInput> | ExpenseCreateWithoutCompanyInput[] | ExpenseUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCompanyInput | ExpenseCreateOrConnectWithoutCompanyInput[]
    createMany?: ExpenseCreateManyCompanyInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ExpenseMasterCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ExpenseMasterCreateWithoutCompanyInput, ExpenseMasterUncheckedCreateWithoutCompanyInput> | ExpenseMasterCreateWithoutCompanyInput[] | ExpenseMasterUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExpenseMasterCreateOrConnectWithoutCompanyInput | ExpenseMasterCreateOrConnectWithoutCompanyInput[]
    createMany?: ExpenseMasterCreateManyCompanyInputEnvelope
    connect?: ExpenseMasterWhereUniqueInput | ExpenseMasterWhereUniqueInput[]
  }

  export type FinancialPeriodCreateNestedManyWithoutCompanyInput = {
    create?: XOR<FinancialPeriodCreateWithoutCompanyInput, FinancialPeriodUncheckedCreateWithoutCompanyInput> | FinancialPeriodCreateWithoutCompanyInput[] | FinancialPeriodUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FinancialPeriodCreateOrConnectWithoutCompanyInput | FinancialPeriodCreateOrConnectWithoutCompanyInput[]
    createMany?: FinancialPeriodCreateManyCompanyInputEnvelope
    connect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
  }

  export type ServiceInvoiceCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ServiceInvoiceCreateWithoutCompanyInput, ServiceInvoiceUncheckedCreateWithoutCompanyInput> | ServiceInvoiceCreateWithoutCompanyInput[] | ServiceInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ServiceInvoiceCreateOrConnectWithoutCompanyInput | ServiceInvoiceCreateOrConnectWithoutCompanyInput[]
    createMany?: ServiceInvoiceCreateManyCompanyInputEnvelope
    connect?: ServiceInvoiceWhereUniqueInput | ServiceInvoiceWhereUniqueInput[]
  }

  export type FreightInvoiceCreateNestedManyWithoutCompanyInput = {
    create?: XOR<FreightInvoiceCreateWithoutCompanyInput, FreightInvoiceUncheckedCreateWithoutCompanyInput> | FreightInvoiceCreateWithoutCompanyInput[] | FreightInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FreightInvoiceCreateOrConnectWithoutCompanyInput | FreightInvoiceCreateOrConnectWithoutCompanyInput[]
    createMany?: FreightInvoiceCreateManyCompanyInputEnvelope
    connect?: FreightInvoiceWhereUniqueInput | FreightInvoiceWhereUniqueInput[]
  }

  export type JobCreateNestedManyWithoutCompanyInput = {
    create?: XOR<JobCreateWithoutCompanyInput, JobUncheckedCreateWithoutCompanyInput> | JobCreateWithoutCompanyInput[] | JobUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCompanyInput | JobCreateOrConnectWithoutCompanyInput[]
    createMany?: JobCreateManyCompanyInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PaymentCreateWithoutCompanyInput, PaymentUncheckedCreateWithoutCompanyInput> | PaymentCreateWithoutCompanyInput[] | PaymentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCompanyInput | PaymentCreateOrConnectWithoutCompanyInput[]
    createMany?: PaymentCreateManyCompanyInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PortCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PortCreateWithoutCompanyInput, PortUncheckedCreateWithoutCompanyInput> | PortCreateWithoutCompanyInput[] | PortUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PortCreateOrConnectWithoutCompanyInput | PortCreateOrConnectWithoutCompanyInput[]
    createMany?: PortCreateManyCompanyInputEnvelope
    connect?: PortWhereUniqueInput | PortWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ProductCreateWithoutCompanyInput, ProductUncheckedCreateWithoutCompanyInput> | ProductCreateWithoutCompanyInput[] | ProductUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCompanyInput | ProductCreateOrConnectWithoutCompanyInput[]
    createMany?: ProductCreateManyCompanyInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductCategoryCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ProductCategoryCreateWithoutCompanyInput, ProductCategoryUncheckedCreateWithoutCompanyInput> | ProductCategoryCreateWithoutCompanyInput[] | ProductCategoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutCompanyInput | ProductCategoryCreateOrConnectWithoutCompanyInput[]
    createMany?: ProductCategoryCreateManyCompanyInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type PurchaseInvoiceCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutCompanyInput, PurchaseInvoiceUncheckedCreateWithoutCompanyInput> | PurchaseInvoiceCreateWithoutCompanyInput[] | PurchaseInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutCompanyInput | PurchaseInvoiceCreateOrConnectWithoutCompanyInput[]
    createMany?: PurchaseInvoiceCreateManyCompanyInputEnvelope
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
  }

  export type StockMovementCreateNestedManyWithoutCompanyInput = {
    create?: XOR<StockMovementCreateWithoutCompanyInput, StockMovementUncheckedCreateWithoutCompanyInput> | StockMovementCreateWithoutCompanyInput[] | StockMovementUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutCompanyInput | StockMovementCreateOrConnectWithoutCompanyInput[]
    createMany?: StockMovementCreateManyCompanyInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type SystemSettingCreateNestedManyWithoutCompanyInput = {
    create?: XOR<SystemSettingCreateWithoutCompanyInput, SystemSettingUncheckedCreateWithoutCompanyInput> | SystemSettingCreateWithoutCompanyInput[] | SystemSettingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SystemSettingCreateOrConnectWithoutCompanyInput | SystemSettingCreateOrConnectWithoutCompanyInput[]
    createMany?: SystemSettingCreateManyCompanyInputEnvelope
    connect?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
  }

  export type TaxSettingCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TaxSettingCreateWithoutCompanyInput, TaxSettingUncheckedCreateWithoutCompanyInput> | TaxSettingCreateWithoutCompanyInput[] | TaxSettingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TaxSettingCreateOrConnectWithoutCompanyInput | TaxSettingCreateOrConnectWithoutCompanyInput[]
    createMany?: TaxSettingCreateManyCompanyInputEnvelope
    connect?: TaxSettingWhereUniqueInput | TaxSettingWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TransactionCreateWithoutCompanyInput, TransactionUncheckedCreateWithoutCompanyInput> | TransactionCreateWithoutCompanyInput[] | TransactionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCompanyInput | TransactionCreateOrConnectWithoutCompanyInput[]
    createMany?: TransactionCreateManyCompanyInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type VendorCreateNestedManyWithoutCompanyInput = {
    create?: XOR<VendorCreateWithoutCompanyInput, VendorUncheckedCreateWithoutCompanyInput> | VendorCreateWithoutCompanyInput[] | VendorUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutCompanyInput | VendorCreateOrConnectWithoutCompanyInput[]
    createMany?: VendorCreateManyCompanyInputEnvelope
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
  }

  export type VoucherCreateNestedManyWithoutCompanyInput = {
    create?: XOR<VoucherCreateWithoutCompanyInput, VoucherUncheckedCreateWithoutCompanyInput> | VoucherCreateWithoutCompanyInput[] | VoucherUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutCompanyInput | VoucherCreateOrConnectWithoutCompanyInput[]
    createMany?: VoucherCreateManyCompanyInputEnvelope
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
  }

  export type WarehouseCreateNestedManyWithoutCompanyInput = {
    create?: XOR<WarehouseCreateWithoutCompanyInput, WarehouseUncheckedCreateWithoutCompanyInput> | WarehouseCreateWithoutCompanyInput[] | WarehouseUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WarehouseCreateOrConnectWithoutCompanyInput | WarehouseCreateOrConnectWithoutCompanyInput[]
    createMany?: WarehouseCreateManyCompanyInputEnvelope
    connect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AccountCreateWithoutCompanyInput, AccountUncheckedCreateWithoutCompanyInput> | AccountCreateWithoutCompanyInput[] | AccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCompanyInput | AccountCreateOrConnectWithoutCompanyInput[]
    createMany?: AccountCreateManyCompanyInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type BranchUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<BranchCreateWithoutCompanyInput, BranchUncheckedCreateWithoutCompanyInput> | BranchCreateWithoutCompanyInput[] | BranchUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutCompanyInput | BranchCreateOrConnectWithoutCompanyInput[]
    createMany?: BranchCreateManyCompanyInputEnvelope
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type CompanyCurrencyUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyCurrencyCreateWithoutCompanyInput, CompanyCurrencyUncheckedCreateWithoutCompanyInput> | CompanyCurrencyCreateWithoutCompanyInput[] | CompanyCurrencyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyCurrencyCreateOrConnectWithoutCompanyInput | CompanyCurrencyCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyCurrencyCreateManyCompanyInputEnvelope
    connect?: CompanyCurrencyWhereUniqueInput | CompanyCurrencyWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CustomerCreateWithoutCompanyInput, CustomerUncheckedCreateWithoutCompanyInput> | CustomerCreateWithoutCompanyInput[] | CustomerUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutCompanyInput | CustomerCreateOrConnectWithoutCompanyInput[]
    createMany?: CustomerCreateManyCompanyInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ExpenseCreateWithoutCompanyInput, ExpenseUncheckedCreateWithoutCompanyInput> | ExpenseCreateWithoutCompanyInput[] | ExpenseUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCompanyInput | ExpenseCreateOrConnectWithoutCompanyInput[]
    createMany?: ExpenseCreateManyCompanyInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ExpenseMasterUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ExpenseMasterCreateWithoutCompanyInput, ExpenseMasterUncheckedCreateWithoutCompanyInput> | ExpenseMasterCreateWithoutCompanyInput[] | ExpenseMasterUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExpenseMasterCreateOrConnectWithoutCompanyInput | ExpenseMasterCreateOrConnectWithoutCompanyInput[]
    createMany?: ExpenseMasterCreateManyCompanyInputEnvelope
    connect?: ExpenseMasterWhereUniqueInput | ExpenseMasterWhereUniqueInput[]
  }

  export type FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<FinancialPeriodCreateWithoutCompanyInput, FinancialPeriodUncheckedCreateWithoutCompanyInput> | FinancialPeriodCreateWithoutCompanyInput[] | FinancialPeriodUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FinancialPeriodCreateOrConnectWithoutCompanyInput | FinancialPeriodCreateOrConnectWithoutCompanyInput[]
    createMany?: FinancialPeriodCreateManyCompanyInputEnvelope
    connect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
  }

  export type ServiceInvoiceUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ServiceInvoiceCreateWithoutCompanyInput, ServiceInvoiceUncheckedCreateWithoutCompanyInput> | ServiceInvoiceCreateWithoutCompanyInput[] | ServiceInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ServiceInvoiceCreateOrConnectWithoutCompanyInput | ServiceInvoiceCreateOrConnectWithoutCompanyInput[]
    createMany?: ServiceInvoiceCreateManyCompanyInputEnvelope
    connect?: ServiceInvoiceWhereUniqueInput | ServiceInvoiceWhereUniqueInput[]
  }

  export type FreightInvoiceUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<FreightInvoiceCreateWithoutCompanyInput, FreightInvoiceUncheckedCreateWithoutCompanyInput> | FreightInvoiceCreateWithoutCompanyInput[] | FreightInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FreightInvoiceCreateOrConnectWithoutCompanyInput | FreightInvoiceCreateOrConnectWithoutCompanyInput[]
    createMany?: FreightInvoiceCreateManyCompanyInputEnvelope
    connect?: FreightInvoiceWhereUniqueInput | FreightInvoiceWhereUniqueInput[]
  }

  export type JobUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<JobCreateWithoutCompanyInput, JobUncheckedCreateWithoutCompanyInput> | JobCreateWithoutCompanyInput[] | JobUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCompanyInput | JobCreateOrConnectWithoutCompanyInput[]
    createMany?: JobCreateManyCompanyInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PaymentCreateWithoutCompanyInput, PaymentUncheckedCreateWithoutCompanyInput> | PaymentCreateWithoutCompanyInput[] | PaymentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCompanyInput | PaymentCreateOrConnectWithoutCompanyInput[]
    createMany?: PaymentCreateManyCompanyInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PortUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PortCreateWithoutCompanyInput, PortUncheckedCreateWithoutCompanyInput> | PortCreateWithoutCompanyInput[] | PortUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PortCreateOrConnectWithoutCompanyInput | PortCreateOrConnectWithoutCompanyInput[]
    createMany?: PortCreateManyCompanyInputEnvelope
    connect?: PortWhereUniqueInput | PortWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ProductCreateWithoutCompanyInput, ProductUncheckedCreateWithoutCompanyInput> | ProductCreateWithoutCompanyInput[] | ProductUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCompanyInput | ProductCreateOrConnectWithoutCompanyInput[]
    createMany?: ProductCreateManyCompanyInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ProductCategoryCreateWithoutCompanyInput, ProductCategoryUncheckedCreateWithoutCompanyInput> | ProductCategoryCreateWithoutCompanyInput[] | ProductCategoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutCompanyInput | ProductCategoryCreateOrConnectWithoutCompanyInput[]
    createMany?: ProductCategoryCreateManyCompanyInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutCompanyInput, PurchaseInvoiceUncheckedCreateWithoutCompanyInput> | PurchaseInvoiceCreateWithoutCompanyInput[] | PurchaseInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutCompanyInput | PurchaseInvoiceCreateOrConnectWithoutCompanyInput[]
    createMany?: PurchaseInvoiceCreateManyCompanyInputEnvelope
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
  }

  export type StockMovementUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<StockMovementCreateWithoutCompanyInput, StockMovementUncheckedCreateWithoutCompanyInput> | StockMovementCreateWithoutCompanyInput[] | StockMovementUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutCompanyInput | StockMovementCreateOrConnectWithoutCompanyInput[]
    createMany?: StockMovementCreateManyCompanyInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type SystemSettingUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<SystemSettingCreateWithoutCompanyInput, SystemSettingUncheckedCreateWithoutCompanyInput> | SystemSettingCreateWithoutCompanyInput[] | SystemSettingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SystemSettingCreateOrConnectWithoutCompanyInput | SystemSettingCreateOrConnectWithoutCompanyInput[]
    createMany?: SystemSettingCreateManyCompanyInputEnvelope
    connect?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
  }

  export type TaxSettingUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TaxSettingCreateWithoutCompanyInput, TaxSettingUncheckedCreateWithoutCompanyInput> | TaxSettingCreateWithoutCompanyInput[] | TaxSettingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TaxSettingCreateOrConnectWithoutCompanyInput | TaxSettingCreateOrConnectWithoutCompanyInput[]
    createMany?: TaxSettingCreateManyCompanyInputEnvelope
    connect?: TaxSettingWhereUniqueInput | TaxSettingWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TransactionCreateWithoutCompanyInput, TransactionUncheckedCreateWithoutCompanyInput> | TransactionCreateWithoutCompanyInput[] | TransactionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCompanyInput | TransactionCreateOrConnectWithoutCompanyInput[]
    createMany?: TransactionCreateManyCompanyInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type VendorUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<VendorCreateWithoutCompanyInput, VendorUncheckedCreateWithoutCompanyInput> | VendorCreateWithoutCompanyInput[] | VendorUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutCompanyInput | VendorCreateOrConnectWithoutCompanyInput[]
    createMany?: VendorCreateManyCompanyInputEnvelope
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
  }

  export type VoucherUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<VoucherCreateWithoutCompanyInput, VoucherUncheckedCreateWithoutCompanyInput> | VoucherCreateWithoutCompanyInput[] | VoucherUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutCompanyInput | VoucherCreateOrConnectWithoutCompanyInput[]
    createMany?: VoucherCreateManyCompanyInputEnvelope
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
  }

  export type WarehouseUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<WarehouseCreateWithoutCompanyInput, WarehouseUncheckedCreateWithoutCompanyInput> | WarehouseCreateWithoutCompanyInput[] | WarehouseUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WarehouseCreateOrConnectWithoutCompanyInput | WarehouseCreateOrConnectWithoutCompanyInput[]
    createMany?: WarehouseCreateManyCompanyInputEnvelope
    connect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AccountUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AccountCreateWithoutCompanyInput, AccountUncheckedCreateWithoutCompanyInput> | AccountCreateWithoutCompanyInput[] | AccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCompanyInput | AccountCreateOrConnectWithoutCompanyInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutCompanyInput | AccountUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AccountCreateManyCompanyInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutCompanyInput | AccountUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutCompanyInput | AccountUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutCompanyInput | AuditLogUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutCompanyInput | AuditLogUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutCompanyInput | AuditLogUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type BranchUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<BranchCreateWithoutCompanyInput, BranchUncheckedCreateWithoutCompanyInput> | BranchCreateWithoutCompanyInput[] | BranchUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutCompanyInput | BranchCreateOrConnectWithoutCompanyInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutCompanyInput | BranchUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: BranchCreateManyCompanyInputEnvelope
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutCompanyInput | BranchUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutCompanyInput | BranchUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type CompanyCurrencyUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyCurrencyCreateWithoutCompanyInput, CompanyCurrencyUncheckedCreateWithoutCompanyInput> | CompanyCurrencyCreateWithoutCompanyInput[] | CompanyCurrencyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyCurrencyCreateOrConnectWithoutCompanyInput | CompanyCurrencyCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyCurrencyUpsertWithWhereUniqueWithoutCompanyInput | CompanyCurrencyUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyCurrencyCreateManyCompanyInputEnvelope
    set?: CompanyCurrencyWhereUniqueInput | CompanyCurrencyWhereUniqueInput[]
    disconnect?: CompanyCurrencyWhereUniqueInput | CompanyCurrencyWhereUniqueInput[]
    delete?: CompanyCurrencyWhereUniqueInput | CompanyCurrencyWhereUniqueInput[]
    connect?: CompanyCurrencyWhereUniqueInput | CompanyCurrencyWhereUniqueInput[]
    update?: CompanyCurrencyUpdateWithWhereUniqueWithoutCompanyInput | CompanyCurrencyUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyCurrencyUpdateManyWithWhereWithoutCompanyInput | CompanyCurrencyUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyCurrencyScalarWhereInput | CompanyCurrencyScalarWhereInput[]
  }

  export type CustomerUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CustomerCreateWithoutCompanyInput, CustomerUncheckedCreateWithoutCompanyInput> | CustomerCreateWithoutCompanyInput[] | CustomerUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutCompanyInput | CustomerCreateOrConnectWithoutCompanyInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutCompanyInput | CustomerUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CustomerCreateManyCompanyInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutCompanyInput | CustomerUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutCompanyInput | CustomerUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ExpenseCreateWithoutCompanyInput, ExpenseUncheckedCreateWithoutCompanyInput> | ExpenseCreateWithoutCompanyInput[] | ExpenseUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCompanyInput | ExpenseCreateOrConnectWithoutCompanyInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutCompanyInput | ExpenseUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ExpenseCreateManyCompanyInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutCompanyInput | ExpenseUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutCompanyInput | ExpenseUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ExpenseMasterUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ExpenseMasterCreateWithoutCompanyInput, ExpenseMasterUncheckedCreateWithoutCompanyInput> | ExpenseMasterCreateWithoutCompanyInput[] | ExpenseMasterUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExpenseMasterCreateOrConnectWithoutCompanyInput | ExpenseMasterCreateOrConnectWithoutCompanyInput[]
    upsert?: ExpenseMasterUpsertWithWhereUniqueWithoutCompanyInput | ExpenseMasterUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ExpenseMasterCreateManyCompanyInputEnvelope
    set?: ExpenseMasterWhereUniqueInput | ExpenseMasterWhereUniqueInput[]
    disconnect?: ExpenseMasterWhereUniqueInput | ExpenseMasterWhereUniqueInput[]
    delete?: ExpenseMasterWhereUniqueInput | ExpenseMasterWhereUniqueInput[]
    connect?: ExpenseMasterWhereUniqueInput | ExpenseMasterWhereUniqueInput[]
    update?: ExpenseMasterUpdateWithWhereUniqueWithoutCompanyInput | ExpenseMasterUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ExpenseMasterUpdateManyWithWhereWithoutCompanyInput | ExpenseMasterUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ExpenseMasterScalarWhereInput | ExpenseMasterScalarWhereInput[]
  }

  export type FinancialPeriodUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<FinancialPeriodCreateWithoutCompanyInput, FinancialPeriodUncheckedCreateWithoutCompanyInput> | FinancialPeriodCreateWithoutCompanyInput[] | FinancialPeriodUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FinancialPeriodCreateOrConnectWithoutCompanyInput | FinancialPeriodCreateOrConnectWithoutCompanyInput[]
    upsert?: FinancialPeriodUpsertWithWhereUniqueWithoutCompanyInput | FinancialPeriodUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: FinancialPeriodCreateManyCompanyInputEnvelope
    set?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    disconnect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    delete?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    connect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    update?: FinancialPeriodUpdateWithWhereUniqueWithoutCompanyInput | FinancialPeriodUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: FinancialPeriodUpdateManyWithWhereWithoutCompanyInput | FinancialPeriodUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: FinancialPeriodScalarWhereInput | FinancialPeriodScalarWhereInput[]
  }

  export type ServiceInvoiceUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ServiceInvoiceCreateWithoutCompanyInput, ServiceInvoiceUncheckedCreateWithoutCompanyInput> | ServiceInvoiceCreateWithoutCompanyInput[] | ServiceInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ServiceInvoiceCreateOrConnectWithoutCompanyInput | ServiceInvoiceCreateOrConnectWithoutCompanyInput[]
    upsert?: ServiceInvoiceUpsertWithWhereUniqueWithoutCompanyInput | ServiceInvoiceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ServiceInvoiceCreateManyCompanyInputEnvelope
    set?: ServiceInvoiceWhereUniqueInput | ServiceInvoiceWhereUniqueInput[]
    disconnect?: ServiceInvoiceWhereUniqueInput | ServiceInvoiceWhereUniqueInput[]
    delete?: ServiceInvoiceWhereUniqueInput | ServiceInvoiceWhereUniqueInput[]
    connect?: ServiceInvoiceWhereUniqueInput | ServiceInvoiceWhereUniqueInput[]
    update?: ServiceInvoiceUpdateWithWhereUniqueWithoutCompanyInput | ServiceInvoiceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ServiceInvoiceUpdateManyWithWhereWithoutCompanyInput | ServiceInvoiceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ServiceInvoiceScalarWhereInput | ServiceInvoiceScalarWhereInput[]
  }

  export type FreightInvoiceUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<FreightInvoiceCreateWithoutCompanyInput, FreightInvoiceUncheckedCreateWithoutCompanyInput> | FreightInvoiceCreateWithoutCompanyInput[] | FreightInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FreightInvoiceCreateOrConnectWithoutCompanyInput | FreightInvoiceCreateOrConnectWithoutCompanyInput[]
    upsert?: FreightInvoiceUpsertWithWhereUniqueWithoutCompanyInput | FreightInvoiceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: FreightInvoiceCreateManyCompanyInputEnvelope
    set?: FreightInvoiceWhereUniqueInput | FreightInvoiceWhereUniqueInput[]
    disconnect?: FreightInvoiceWhereUniqueInput | FreightInvoiceWhereUniqueInput[]
    delete?: FreightInvoiceWhereUniqueInput | FreightInvoiceWhereUniqueInput[]
    connect?: FreightInvoiceWhereUniqueInput | FreightInvoiceWhereUniqueInput[]
    update?: FreightInvoiceUpdateWithWhereUniqueWithoutCompanyInput | FreightInvoiceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: FreightInvoiceUpdateManyWithWhereWithoutCompanyInput | FreightInvoiceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: FreightInvoiceScalarWhereInput | FreightInvoiceScalarWhereInput[]
  }

  export type JobUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<JobCreateWithoutCompanyInput, JobUncheckedCreateWithoutCompanyInput> | JobCreateWithoutCompanyInput[] | JobUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCompanyInput | JobCreateOrConnectWithoutCompanyInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutCompanyInput | JobUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: JobCreateManyCompanyInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutCompanyInput | JobUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: JobUpdateManyWithWhereWithoutCompanyInput | JobUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PaymentCreateWithoutCompanyInput, PaymentUncheckedCreateWithoutCompanyInput> | PaymentCreateWithoutCompanyInput[] | PaymentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCompanyInput | PaymentCreateOrConnectWithoutCompanyInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCompanyInput | PaymentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PaymentCreateManyCompanyInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCompanyInput | PaymentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCompanyInput | PaymentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PortUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PortCreateWithoutCompanyInput, PortUncheckedCreateWithoutCompanyInput> | PortCreateWithoutCompanyInput[] | PortUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PortCreateOrConnectWithoutCompanyInput | PortCreateOrConnectWithoutCompanyInput[]
    upsert?: PortUpsertWithWhereUniqueWithoutCompanyInput | PortUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PortCreateManyCompanyInputEnvelope
    set?: PortWhereUniqueInput | PortWhereUniqueInput[]
    disconnect?: PortWhereUniqueInput | PortWhereUniqueInput[]
    delete?: PortWhereUniqueInput | PortWhereUniqueInput[]
    connect?: PortWhereUniqueInput | PortWhereUniqueInput[]
    update?: PortUpdateWithWhereUniqueWithoutCompanyInput | PortUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PortUpdateManyWithWhereWithoutCompanyInput | PortUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PortScalarWhereInput | PortScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ProductCreateWithoutCompanyInput, ProductUncheckedCreateWithoutCompanyInput> | ProductCreateWithoutCompanyInput[] | ProductUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCompanyInput | ProductCreateOrConnectWithoutCompanyInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCompanyInput | ProductUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ProductCreateManyCompanyInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCompanyInput | ProductUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCompanyInput | ProductUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCategoryUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutCompanyInput, ProductCategoryUncheckedCreateWithoutCompanyInput> | ProductCategoryCreateWithoutCompanyInput[] | ProductCategoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutCompanyInput | ProductCategoryCreateOrConnectWithoutCompanyInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutCompanyInput | ProductCategoryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ProductCategoryCreateManyCompanyInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutCompanyInput | ProductCategoryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutCompanyInput | ProductCategoryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type PurchaseInvoiceUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutCompanyInput, PurchaseInvoiceUncheckedCreateWithoutCompanyInput> | PurchaseInvoiceCreateWithoutCompanyInput[] | PurchaseInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutCompanyInput | PurchaseInvoiceCreateOrConnectWithoutCompanyInput[]
    upsert?: PurchaseInvoiceUpsertWithWhereUniqueWithoutCompanyInput | PurchaseInvoiceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PurchaseInvoiceCreateManyCompanyInputEnvelope
    set?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    disconnect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    delete?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    update?: PurchaseInvoiceUpdateWithWhereUniqueWithoutCompanyInput | PurchaseInvoiceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PurchaseInvoiceUpdateManyWithWhereWithoutCompanyInput | PurchaseInvoiceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
  }

  export type StockMovementUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<StockMovementCreateWithoutCompanyInput, StockMovementUncheckedCreateWithoutCompanyInput> | StockMovementCreateWithoutCompanyInput[] | StockMovementUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutCompanyInput | StockMovementCreateOrConnectWithoutCompanyInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutCompanyInput | StockMovementUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: StockMovementCreateManyCompanyInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutCompanyInput | StockMovementUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutCompanyInput | StockMovementUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type SystemSettingUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<SystemSettingCreateWithoutCompanyInput, SystemSettingUncheckedCreateWithoutCompanyInput> | SystemSettingCreateWithoutCompanyInput[] | SystemSettingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SystemSettingCreateOrConnectWithoutCompanyInput | SystemSettingCreateOrConnectWithoutCompanyInput[]
    upsert?: SystemSettingUpsertWithWhereUniqueWithoutCompanyInput | SystemSettingUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: SystemSettingCreateManyCompanyInputEnvelope
    set?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    disconnect?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    delete?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    connect?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    update?: SystemSettingUpdateWithWhereUniqueWithoutCompanyInput | SystemSettingUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: SystemSettingUpdateManyWithWhereWithoutCompanyInput | SystemSettingUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: SystemSettingScalarWhereInput | SystemSettingScalarWhereInput[]
  }

  export type TaxSettingUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TaxSettingCreateWithoutCompanyInput, TaxSettingUncheckedCreateWithoutCompanyInput> | TaxSettingCreateWithoutCompanyInput[] | TaxSettingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TaxSettingCreateOrConnectWithoutCompanyInput | TaxSettingCreateOrConnectWithoutCompanyInput[]
    upsert?: TaxSettingUpsertWithWhereUniqueWithoutCompanyInput | TaxSettingUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TaxSettingCreateManyCompanyInputEnvelope
    set?: TaxSettingWhereUniqueInput | TaxSettingWhereUniqueInput[]
    disconnect?: TaxSettingWhereUniqueInput | TaxSettingWhereUniqueInput[]
    delete?: TaxSettingWhereUniqueInput | TaxSettingWhereUniqueInput[]
    connect?: TaxSettingWhereUniqueInput | TaxSettingWhereUniqueInput[]
    update?: TaxSettingUpdateWithWhereUniqueWithoutCompanyInput | TaxSettingUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TaxSettingUpdateManyWithWhereWithoutCompanyInput | TaxSettingUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TaxSettingScalarWhereInput | TaxSettingScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TransactionCreateWithoutCompanyInput, TransactionUncheckedCreateWithoutCompanyInput> | TransactionCreateWithoutCompanyInput[] | TransactionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCompanyInput | TransactionCreateOrConnectWithoutCompanyInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCompanyInput | TransactionUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TransactionCreateManyCompanyInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCompanyInput | TransactionUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCompanyInput | TransactionUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type VendorUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<VendorCreateWithoutCompanyInput, VendorUncheckedCreateWithoutCompanyInput> | VendorCreateWithoutCompanyInput[] | VendorUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutCompanyInput | VendorCreateOrConnectWithoutCompanyInput[]
    upsert?: VendorUpsertWithWhereUniqueWithoutCompanyInput | VendorUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: VendorCreateManyCompanyInputEnvelope
    set?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    disconnect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    delete?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    update?: VendorUpdateWithWhereUniqueWithoutCompanyInput | VendorUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: VendorUpdateManyWithWhereWithoutCompanyInput | VendorUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: VendorScalarWhereInput | VendorScalarWhereInput[]
  }

  export type VoucherUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<VoucherCreateWithoutCompanyInput, VoucherUncheckedCreateWithoutCompanyInput> | VoucherCreateWithoutCompanyInput[] | VoucherUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutCompanyInput | VoucherCreateOrConnectWithoutCompanyInput[]
    upsert?: VoucherUpsertWithWhereUniqueWithoutCompanyInput | VoucherUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: VoucherCreateManyCompanyInputEnvelope
    set?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    disconnect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    delete?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    update?: VoucherUpdateWithWhereUniqueWithoutCompanyInput | VoucherUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: VoucherUpdateManyWithWhereWithoutCompanyInput | VoucherUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
  }

  export type WarehouseUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<WarehouseCreateWithoutCompanyInput, WarehouseUncheckedCreateWithoutCompanyInput> | WarehouseCreateWithoutCompanyInput[] | WarehouseUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WarehouseCreateOrConnectWithoutCompanyInput | WarehouseCreateOrConnectWithoutCompanyInput[]
    upsert?: WarehouseUpsertWithWhereUniqueWithoutCompanyInput | WarehouseUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: WarehouseCreateManyCompanyInputEnvelope
    set?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    disconnect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    delete?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    connect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    update?: WarehouseUpdateWithWhereUniqueWithoutCompanyInput | WarehouseUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: WarehouseUpdateManyWithWhereWithoutCompanyInput | WarehouseUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: WarehouseScalarWhereInput | WarehouseScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AccountUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AccountCreateWithoutCompanyInput, AccountUncheckedCreateWithoutCompanyInput> | AccountCreateWithoutCompanyInput[] | AccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCompanyInput | AccountCreateOrConnectWithoutCompanyInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutCompanyInput | AccountUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AccountCreateManyCompanyInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutCompanyInput | AccountUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutCompanyInput | AccountUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutCompanyInput | AuditLogUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutCompanyInput | AuditLogUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutCompanyInput | AuditLogUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type BranchUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<BranchCreateWithoutCompanyInput, BranchUncheckedCreateWithoutCompanyInput> | BranchCreateWithoutCompanyInput[] | BranchUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutCompanyInput | BranchCreateOrConnectWithoutCompanyInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutCompanyInput | BranchUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: BranchCreateManyCompanyInputEnvelope
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutCompanyInput | BranchUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutCompanyInput | BranchUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type CompanyCurrencyUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyCurrencyCreateWithoutCompanyInput, CompanyCurrencyUncheckedCreateWithoutCompanyInput> | CompanyCurrencyCreateWithoutCompanyInput[] | CompanyCurrencyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyCurrencyCreateOrConnectWithoutCompanyInput | CompanyCurrencyCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyCurrencyUpsertWithWhereUniqueWithoutCompanyInput | CompanyCurrencyUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyCurrencyCreateManyCompanyInputEnvelope
    set?: CompanyCurrencyWhereUniqueInput | CompanyCurrencyWhereUniqueInput[]
    disconnect?: CompanyCurrencyWhereUniqueInput | CompanyCurrencyWhereUniqueInput[]
    delete?: CompanyCurrencyWhereUniqueInput | CompanyCurrencyWhereUniqueInput[]
    connect?: CompanyCurrencyWhereUniqueInput | CompanyCurrencyWhereUniqueInput[]
    update?: CompanyCurrencyUpdateWithWhereUniqueWithoutCompanyInput | CompanyCurrencyUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyCurrencyUpdateManyWithWhereWithoutCompanyInput | CompanyCurrencyUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyCurrencyScalarWhereInput | CompanyCurrencyScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CustomerCreateWithoutCompanyInput, CustomerUncheckedCreateWithoutCompanyInput> | CustomerCreateWithoutCompanyInput[] | CustomerUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutCompanyInput | CustomerCreateOrConnectWithoutCompanyInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutCompanyInput | CustomerUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CustomerCreateManyCompanyInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutCompanyInput | CustomerUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutCompanyInput | CustomerUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ExpenseCreateWithoutCompanyInput, ExpenseUncheckedCreateWithoutCompanyInput> | ExpenseCreateWithoutCompanyInput[] | ExpenseUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCompanyInput | ExpenseCreateOrConnectWithoutCompanyInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutCompanyInput | ExpenseUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ExpenseCreateManyCompanyInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutCompanyInput | ExpenseUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutCompanyInput | ExpenseUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ExpenseMasterUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ExpenseMasterCreateWithoutCompanyInput, ExpenseMasterUncheckedCreateWithoutCompanyInput> | ExpenseMasterCreateWithoutCompanyInput[] | ExpenseMasterUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExpenseMasterCreateOrConnectWithoutCompanyInput | ExpenseMasterCreateOrConnectWithoutCompanyInput[]
    upsert?: ExpenseMasterUpsertWithWhereUniqueWithoutCompanyInput | ExpenseMasterUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ExpenseMasterCreateManyCompanyInputEnvelope
    set?: ExpenseMasterWhereUniqueInput | ExpenseMasterWhereUniqueInput[]
    disconnect?: ExpenseMasterWhereUniqueInput | ExpenseMasterWhereUniqueInput[]
    delete?: ExpenseMasterWhereUniqueInput | ExpenseMasterWhereUniqueInput[]
    connect?: ExpenseMasterWhereUniqueInput | ExpenseMasterWhereUniqueInput[]
    update?: ExpenseMasterUpdateWithWhereUniqueWithoutCompanyInput | ExpenseMasterUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ExpenseMasterUpdateManyWithWhereWithoutCompanyInput | ExpenseMasterUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ExpenseMasterScalarWhereInput | ExpenseMasterScalarWhereInput[]
  }

  export type FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<FinancialPeriodCreateWithoutCompanyInput, FinancialPeriodUncheckedCreateWithoutCompanyInput> | FinancialPeriodCreateWithoutCompanyInput[] | FinancialPeriodUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FinancialPeriodCreateOrConnectWithoutCompanyInput | FinancialPeriodCreateOrConnectWithoutCompanyInput[]
    upsert?: FinancialPeriodUpsertWithWhereUniqueWithoutCompanyInput | FinancialPeriodUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: FinancialPeriodCreateManyCompanyInputEnvelope
    set?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    disconnect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    delete?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    connect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    update?: FinancialPeriodUpdateWithWhereUniqueWithoutCompanyInput | FinancialPeriodUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: FinancialPeriodUpdateManyWithWhereWithoutCompanyInput | FinancialPeriodUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: FinancialPeriodScalarWhereInput | FinancialPeriodScalarWhereInput[]
  }

  export type ServiceInvoiceUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ServiceInvoiceCreateWithoutCompanyInput, ServiceInvoiceUncheckedCreateWithoutCompanyInput> | ServiceInvoiceCreateWithoutCompanyInput[] | ServiceInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ServiceInvoiceCreateOrConnectWithoutCompanyInput | ServiceInvoiceCreateOrConnectWithoutCompanyInput[]
    upsert?: ServiceInvoiceUpsertWithWhereUniqueWithoutCompanyInput | ServiceInvoiceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ServiceInvoiceCreateManyCompanyInputEnvelope
    set?: ServiceInvoiceWhereUniqueInput | ServiceInvoiceWhereUniqueInput[]
    disconnect?: ServiceInvoiceWhereUniqueInput | ServiceInvoiceWhereUniqueInput[]
    delete?: ServiceInvoiceWhereUniqueInput | ServiceInvoiceWhereUniqueInput[]
    connect?: ServiceInvoiceWhereUniqueInput | ServiceInvoiceWhereUniqueInput[]
    update?: ServiceInvoiceUpdateWithWhereUniqueWithoutCompanyInput | ServiceInvoiceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ServiceInvoiceUpdateManyWithWhereWithoutCompanyInput | ServiceInvoiceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ServiceInvoiceScalarWhereInput | ServiceInvoiceScalarWhereInput[]
  }

  export type FreightInvoiceUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<FreightInvoiceCreateWithoutCompanyInput, FreightInvoiceUncheckedCreateWithoutCompanyInput> | FreightInvoiceCreateWithoutCompanyInput[] | FreightInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FreightInvoiceCreateOrConnectWithoutCompanyInput | FreightInvoiceCreateOrConnectWithoutCompanyInput[]
    upsert?: FreightInvoiceUpsertWithWhereUniqueWithoutCompanyInput | FreightInvoiceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: FreightInvoiceCreateManyCompanyInputEnvelope
    set?: FreightInvoiceWhereUniqueInput | FreightInvoiceWhereUniqueInput[]
    disconnect?: FreightInvoiceWhereUniqueInput | FreightInvoiceWhereUniqueInput[]
    delete?: FreightInvoiceWhereUniqueInput | FreightInvoiceWhereUniqueInput[]
    connect?: FreightInvoiceWhereUniqueInput | FreightInvoiceWhereUniqueInput[]
    update?: FreightInvoiceUpdateWithWhereUniqueWithoutCompanyInput | FreightInvoiceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: FreightInvoiceUpdateManyWithWhereWithoutCompanyInput | FreightInvoiceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: FreightInvoiceScalarWhereInput | FreightInvoiceScalarWhereInput[]
  }

  export type JobUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<JobCreateWithoutCompanyInput, JobUncheckedCreateWithoutCompanyInput> | JobCreateWithoutCompanyInput[] | JobUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCompanyInput | JobCreateOrConnectWithoutCompanyInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutCompanyInput | JobUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: JobCreateManyCompanyInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutCompanyInput | JobUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: JobUpdateManyWithWhereWithoutCompanyInput | JobUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PaymentCreateWithoutCompanyInput, PaymentUncheckedCreateWithoutCompanyInput> | PaymentCreateWithoutCompanyInput[] | PaymentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCompanyInput | PaymentCreateOrConnectWithoutCompanyInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCompanyInput | PaymentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PaymentCreateManyCompanyInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCompanyInput | PaymentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCompanyInput | PaymentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PortUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PortCreateWithoutCompanyInput, PortUncheckedCreateWithoutCompanyInput> | PortCreateWithoutCompanyInput[] | PortUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PortCreateOrConnectWithoutCompanyInput | PortCreateOrConnectWithoutCompanyInput[]
    upsert?: PortUpsertWithWhereUniqueWithoutCompanyInput | PortUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PortCreateManyCompanyInputEnvelope
    set?: PortWhereUniqueInput | PortWhereUniqueInput[]
    disconnect?: PortWhereUniqueInput | PortWhereUniqueInput[]
    delete?: PortWhereUniqueInput | PortWhereUniqueInput[]
    connect?: PortWhereUniqueInput | PortWhereUniqueInput[]
    update?: PortUpdateWithWhereUniqueWithoutCompanyInput | PortUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PortUpdateManyWithWhereWithoutCompanyInput | PortUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PortScalarWhereInput | PortScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ProductCreateWithoutCompanyInput, ProductUncheckedCreateWithoutCompanyInput> | ProductCreateWithoutCompanyInput[] | ProductUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCompanyInput | ProductCreateOrConnectWithoutCompanyInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCompanyInput | ProductUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ProductCreateManyCompanyInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCompanyInput | ProductUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCompanyInput | ProductUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutCompanyInput, ProductCategoryUncheckedCreateWithoutCompanyInput> | ProductCategoryCreateWithoutCompanyInput[] | ProductCategoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutCompanyInput | ProductCategoryCreateOrConnectWithoutCompanyInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutCompanyInput | ProductCategoryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ProductCategoryCreateManyCompanyInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutCompanyInput | ProductCategoryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutCompanyInput | ProductCategoryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutCompanyInput, PurchaseInvoiceUncheckedCreateWithoutCompanyInput> | PurchaseInvoiceCreateWithoutCompanyInput[] | PurchaseInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutCompanyInput | PurchaseInvoiceCreateOrConnectWithoutCompanyInput[]
    upsert?: PurchaseInvoiceUpsertWithWhereUniqueWithoutCompanyInput | PurchaseInvoiceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PurchaseInvoiceCreateManyCompanyInputEnvelope
    set?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    disconnect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    delete?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    update?: PurchaseInvoiceUpdateWithWhereUniqueWithoutCompanyInput | PurchaseInvoiceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PurchaseInvoiceUpdateManyWithWhereWithoutCompanyInput | PurchaseInvoiceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
  }

  export type StockMovementUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<StockMovementCreateWithoutCompanyInput, StockMovementUncheckedCreateWithoutCompanyInput> | StockMovementCreateWithoutCompanyInput[] | StockMovementUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutCompanyInput | StockMovementCreateOrConnectWithoutCompanyInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutCompanyInput | StockMovementUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: StockMovementCreateManyCompanyInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutCompanyInput | StockMovementUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutCompanyInput | StockMovementUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type SystemSettingUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<SystemSettingCreateWithoutCompanyInput, SystemSettingUncheckedCreateWithoutCompanyInput> | SystemSettingCreateWithoutCompanyInput[] | SystemSettingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SystemSettingCreateOrConnectWithoutCompanyInput | SystemSettingCreateOrConnectWithoutCompanyInput[]
    upsert?: SystemSettingUpsertWithWhereUniqueWithoutCompanyInput | SystemSettingUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: SystemSettingCreateManyCompanyInputEnvelope
    set?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    disconnect?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    delete?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    connect?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    update?: SystemSettingUpdateWithWhereUniqueWithoutCompanyInput | SystemSettingUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: SystemSettingUpdateManyWithWhereWithoutCompanyInput | SystemSettingUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: SystemSettingScalarWhereInput | SystemSettingScalarWhereInput[]
  }

  export type TaxSettingUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TaxSettingCreateWithoutCompanyInput, TaxSettingUncheckedCreateWithoutCompanyInput> | TaxSettingCreateWithoutCompanyInput[] | TaxSettingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TaxSettingCreateOrConnectWithoutCompanyInput | TaxSettingCreateOrConnectWithoutCompanyInput[]
    upsert?: TaxSettingUpsertWithWhereUniqueWithoutCompanyInput | TaxSettingUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TaxSettingCreateManyCompanyInputEnvelope
    set?: TaxSettingWhereUniqueInput | TaxSettingWhereUniqueInput[]
    disconnect?: TaxSettingWhereUniqueInput | TaxSettingWhereUniqueInput[]
    delete?: TaxSettingWhereUniqueInput | TaxSettingWhereUniqueInput[]
    connect?: TaxSettingWhereUniqueInput | TaxSettingWhereUniqueInput[]
    update?: TaxSettingUpdateWithWhereUniqueWithoutCompanyInput | TaxSettingUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TaxSettingUpdateManyWithWhereWithoutCompanyInput | TaxSettingUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TaxSettingScalarWhereInput | TaxSettingScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TransactionCreateWithoutCompanyInput, TransactionUncheckedCreateWithoutCompanyInput> | TransactionCreateWithoutCompanyInput[] | TransactionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCompanyInput | TransactionCreateOrConnectWithoutCompanyInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCompanyInput | TransactionUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TransactionCreateManyCompanyInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCompanyInput | TransactionUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCompanyInput | TransactionUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type VendorUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<VendorCreateWithoutCompanyInput, VendorUncheckedCreateWithoutCompanyInput> | VendorCreateWithoutCompanyInput[] | VendorUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutCompanyInput | VendorCreateOrConnectWithoutCompanyInput[]
    upsert?: VendorUpsertWithWhereUniqueWithoutCompanyInput | VendorUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: VendorCreateManyCompanyInputEnvelope
    set?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    disconnect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    delete?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    update?: VendorUpdateWithWhereUniqueWithoutCompanyInput | VendorUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: VendorUpdateManyWithWhereWithoutCompanyInput | VendorUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: VendorScalarWhereInput | VendorScalarWhereInput[]
  }

  export type VoucherUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<VoucherCreateWithoutCompanyInput, VoucherUncheckedCreateWithoutCompanyInput> | VoucherCreateWithoutCompanyInput[] | VoucherUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutCompanyInput | VoucherCreateOrConnectWithoutCompanyInput[]
    upsert?: VoucherUpsertWithWhereUniqueWithoutCompanyInput | VoucherUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: VoucherCreateManyCompanyInputEnvelope
    set?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    disconnect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    delete?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    update?: VoucherUpdateWithWhereUniqueWithoutCompanyInput | VoucherUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: VoucherUpdateManyWithWhereWithoutCompanyInput | VoucherUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
  }

  export type WarehouseUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<WarehouseCreateWithoutCompanyInput, WarehouseUncheckedCreateWithoutCompanyInput> | WarehouseCreateWithoutCompanyInput[] | WarehouseUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WarehouseCreateOrConnectWithoutCompanyInput | WarehouseCreateOrConnectWithoutCompanyInput[]
    upsert?: WarehouseUpsertWithWhereUniqueWithoutCompanyInput | WarehouseUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: WarehouseCreateManyCompanyInputEnvelope
    set?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    disconnect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    delete?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    connect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    update?: WarehouseUpdateWithWhereUniqueWithoutCompanyInput | WarehouseUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: WarehouseUpdateManyWithWhereWithoutCompanyInput | WarehouseUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: WarehouseScalarWhereInput | WarehouseScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutBranchesInput = {
    create?: XOR<CompanyCreateWithoutBranchesInput, CompanyUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutBranchesInput
    connect?: CompanyWhereUniqueInput
  }

  export type JobCreateNestedManyWithoutBranchInput = {
    create?: XOR<JobCreateWithoutBranchInput, JobUncheckedCreateWithoutBranchInput> | JobCreateWithoutBranchInput[] | JobUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: JobCreateOrConnectWithoutBranchInput | JobCreateOrConnectWithoutBranchInput[]
    createMany?: JobCreateManyBranchInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type TaxSettingCreateNestedManyWithoutBranchInput = {
    create?: XOR<TaxSettingCreateWithoutBranchInput, TaxSettingUncheckedCreateWithoutBranchInput> | TaxSettingCreateWithoutBranchInput[] | TaxSettingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TaxSettingCreateOrConnectWithoutBranchInput | TaxSettingCreateOrConnectWithoutBranchInput[]
    createMany?: TaxSettingCreateManyBranchInputEnvelope
    connect?: TaxSettingWhereUniqueInput | TaxSettingWhereUniqueInput[]
  }

  export type JobUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<JobCreateWithoutBranchInput, JobUncheckedCreateWithoutBranchInput> | JobCreateWithoutBranchInput[] | JobUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: JobCreateOrConnectWithoutBranchInput | JobCreateOrConnectWithoutBranchInput[]
    createMany?: JobCreateManyBranchInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type TaxSettingUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<TaxSettingCreateWithoutBranchInput, TaxSettingUncheckedCreateWithoutBranchInput> | TaxSettingCreateWithoutBranchInput[] | TaxSettingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TaxSettingCreateOrConnectWithoutBranchInput | TaxSettingCreateOrConnectWithoutBranchInput[]
    createMany?: TaxSettingCreateManyBranchInputEnvelope
    connect?: TaxSettingWhereUniqueInput | TaxSettingWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutBranchesNestedInput = {
    create?: XOR<CompanyCreateWithoutBranchesInput, CompanyUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutBranchesInput
    upsert?: CompanyUpsertWithoutBranchesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutBranchesInput, CompanyUpdateWithoutBranchesInput>, CompanyUncheckedUpdateWithoutBranchesInput>
  }

  export type JobUpdateManyWithoutBranchNestedInput = {
    create?: XOR<JobCreateWithoutBranchInput, JobUncheckedCreateWithoutBranchInput> | JobCreateWithoutBranchInput[] | JobUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: JobCreateOrConnectWithoutBranchInput | JobCreateOrConnectWithoutBranchInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutBranchInput | JobUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: JobCreateManyBranchInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutBranchInput | JobUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: JobUpdateManyWithWhereWithoutBranchInput | JobUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type TaxSettingUpdateManyWithoutBranchNestedInput = {
    create?: XOR<TaxSettingCreateWithoutBranchInput, TaxSettingUncheckedCreateWithoutBranchInput> | TaxSettingCreateWithoutBranchInput[] | TaxSettingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TaxSettingCreateOrConnectWithoutBranchInput | TaxSettingCreateOrConnectWithoutBranchInput[]
    upsert?: TaxSettingUpsertWithWhereUniqueWithoutBranchInput | TaxSettingUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: TaxSettingCreateManyBranchInputEnvelope
    set?: TaxSettingWhereUniqueInput | TaxSettingWhereUniqueInput[]
    disconnect?: TaxSettingWhereUniqueInput | TaxSettingWhereUniqueInput[]
    delete?: TaxSettingWhereUniqueInput | TaxSettingWhereUniqueInput[]
    connect?: TaxSettingWhereUniqueInput | TaxSettingWhereUniqueInput[]
    update?: TaxSettingUpdateWithWhereUniqueWithoutBranchInput | TaxSettingUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: TaxSettingUpdateManyWithWhereWithoutBranchInput | TaxSettingUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: TaxSettingScalarWhereInput | TaxSettingScalarWhereInput[]
  }

  export type JobUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<JobCreateWithoutBranchInput, JobUncheckedCreateWithoutBranchInput> | JobCreateWithoutBranchInput[] | JobUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: JobCreateOrConnectWithoutBranchInput | JobCreateOrConnectWithoutBranchInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutBranchInput | JobUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: JobCreateManyBranchInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutBranchInput | JobUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: JobUpdateManyWithWhereWithoutBranchInput | JobUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type TaxSettingUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<TaxSettingCreateWithoutBranchInput, TaxSettingUncheckedCreateWithoutBranchInput> | TaxSettingCreateWithoutBranchInput[] | TaxSettingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TaxSettingCreateOrConnectWithoutBranchInput | TaxSettingCreateOrConnectWithoutBranchInput[]
    upsert?: TaxSettingUpsertWithWhereUniqueWithoutBranchInput | TaxSettingUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: TaxSettingCreateManyBranchInputEnvelope
    set?: TaxSettingWhereUniqueInput | TaxSettingWhereUniqueInput[]
    disconnect?: TaxSettingWhereUniqueInput | TaxSettingWhereUniqueInput[]
    delete?: TaxSettingWhereUniqueInput | TaxSettingWhereUniqueInput[]
    connect?: TaxSettingWhereUniqueInput | TaxSettingWhereUniqueInput[]
    update?: TaxSettingUpdateWithWhereUniqueWithoutBranchInput | TaxSettingUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: TaxSettingUpdateManyWithWhereWithoutBranchInput | TaxSettingUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: TaxSettingScalarWhereInput | TaxSettingScalarWhereInput[]
  }

  export type CompanyCurrencyCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<CompanyCurrencyCreateWithoutCurrencyInput, CompanyCurrencyUncheckedCreateWithoutCurrencyInput> | CompanyCurrencyCreateWithoutCurrencyInput[] | CompanyCurrencyUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: CompanyCurrencyCreateOrConnectWithoutCurrencyInput | CompanyCurrencyCreateOrConnectWithoutCurrencyInput[]
    createMany?: CompanyCurrencyCreateManyCurrencyInputEnvelope
    connect?: CompanyCurrencyWhereUniqueInput | CompanyCurrencyWhereUniqueInput[]
  }

  export type CompanyCurrencyUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<CompanyCurrencyCreateWithoutCurrencyInput, CompanyCurrencyUncheckedCreateWithoutCurrencyInput> | CompanyCurrencyCreateWithoutCurrencyInput[] | CompanyCurrencyUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: CompanyCurrencyCreateOrConnectWithoutCurrencyInput | CompanyCurrencyCreateOrConnectWithoutCurrencyInput[]
    createMany?: CompanyCurrencyCreateManyCurrencyInputEnvelope
    connect?: CompanyCurrencyWhereUniqueInput | CompanyCurrencyWhereUniqueInput[]
  }

  export type CompanyCurrencyUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<CompanyCurrencyCreateWithoutCurrencyInput, CompanyCurrencyUncheckedCreateWithoutCurrencyInput> | CompanyCurrencyCreateWithoutCurrencyInput[] | CompanyCurrencyUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: CompanyCurrencyCreateOrConnectWithoutCurrencyInput | CompanyCurrencyCreateOrConnectWithoutCurrencyInput[]
    upsert?: CompanyCurrencyUpsertWithWhereUniqueWithoutCurrencyInput | CompanyCurrencyUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: CompanyCurrencyCreateManyCurrencyInputEnvelope
    set?: CompanyCurrencyWhereUniqueInput | CompanyCurrencyWhereUniqueInput[]
    disconnect?: CompanyCurrencyWhereUniqueInput | CompanyCurrencyWhereUniqueInput[]
    delete?: CompanyCurrencyWhereUniqueInput | CompanyCurrencyWhereUniqueInput[]
    connect?: CompanyCurrencyWhereUniqueInput | CompanyCurrencyWhereUniqueInput[]
    update?: CompanyCurrencyUpdateWithWhereUniqueWithoutCurrencyInput | CompanyCurrencyUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: CompanyCurrencyUpdateManyWithWhereWithoutCurrencyInput | CompanyCurrencyUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: CompanyCurrencyScalarWhereInput | CompanyCurrencyScalarWhereInput[]
  }

  export type CompanyCurrencyUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<CompanyCurrencyCreateWithoutCurrencyInput, CompanyCurrencyUncheckedCreateWithoutCurrencyInput> | CompanyCurrencyCreateWithoutCurrencyInput[] | CompanyCurrencyUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: CompanyCurrencyCreateOrConnectWithoutCurrencyInput | CompanyCurrencyCreateOrConnectWithoutCurrencyInput[]
    upsert?: CompanyCurrencyUpsertWithWhereUniqueWithoutCurrencyInput | CompanyCurrencyUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: CompanyCurrencyCreateManyCurrencyInputEnvelope
    set?: CompanyCurrencyWhereUniqueInput | CompanyCurrencyWhereUniqueInput[]
    disconnect?: CompanyCurrencyWhereUniqueInput | CompanyCurrencyWhereUniqueInput[]
    delete?: CompanyCurrencyWhereUniqueInput | CompanyCurrencyWhereUniqueInput[]
    connect?: CompanyCurrencyWhereUniqueInput | CompanyCurrencyWhereUniqueInput[]
    update?: CompanyCurrencyUpdateWithWhereUniqueWithoutCurrencyInput | CompanyCurrencyUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: CompanyCurrencyUpdateManyWithWhereWithoutCurrencyInput | CompanyCurrencyUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: CompanyCurrencyScalarWhereInput | CompanyCurrencyScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutCurrenciesInput = {
    create?: XOR<CompanyCreateWithoutCurrenciesInput, CompanyUncheckedCreateWithoutCurrenciesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCurrenciesInput
    connect?: CompanyWhereUniqueInput
  }

  export type CurrencyCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<CurrencyCreateWithoutCompaniesInput, CurrencyUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutCompaniesInput
    connect?: CurrencyWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CompanyUpdateOneRequiredWithoutCurrenciesNestedInput = {
    create?: XOR<CompanyCreateWithoutCurrenciesInput, CompanyUncheckedCreateWithoutCurrenciesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCurrenciesInput
    upsert?: CompanyUpsertWithoutCurrenciesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCurrenciesInput, CompanyUpdateWithoutCurrenciesInput>, CompanyUncheckedUpdateWithoutCurrenciesInput>
  }

  export type CurrencyUpdateOneRequiredWithoutCompaniesNestedInput = {
    create?: XOR<CurrencyCreateWithoutCompaniesInput, CurrencyUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutCompaniesInput
    upsert?: CurrencyUpsertWithoutCompaniesInput
    connect?: CurrencyWhereUniqueInput
    update?: XOR<XOR<CurrencyUpdateToOneWithWhereWithoutCompaniesInput, CurrencyUpdateWithoutCompaniesInput>, CurrencyUncheckedUpdateWithoutCompaniesInput>
  }

  export type BranchCreateNestedOneWithoutTaxSettingsInput = {
    create?: XOR<BranchCreateWithoutTaxSettingsInput, BranchUncheckedCreateWithoutTaxSettingsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutTaxSettingsInput
    connect?: BranchWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutTaxSettingsInput = {
    create?: XOR<CompanyCreateWithoutTaxSettingsInput, CompanyUncheckedCreateWithoutTaxSettingsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTaxSettingsInput
    connect?: CompanyWhereUniqueInput
  }

  export type BranchUpdateOneWithoutTaxSettingsNestedInput = {
    create?: XOR<BranchCreateWithoutTaxSettingsInput, BranchUncheckedCreateWithoutTaxSettingsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutTaxSettingsInput
    upsert?: BranchUpsertWithoutTaxSettingsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutTaxSettingsInput, BranchUpdateWithoutTaxSettingsInput>, BranchUncheckedUpdateWithoutTaxSettingsInput>
  }

  export type CompanyUpdateOneRequiredWithoutTaxSettingsNestedInput = {
    create?: XOR<CompanyCreateWithoutTaxSettingsInput, CompanyUncheckedCreateWithoutTaxSettingsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTaxSettingsInput
    upsert?: CompanyUpsertWithoutTaxSettingsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutTaxSettingsInput, CompanyUpdateWithoutTaxSettingsInput>, CompanyUncheckedUpdateWithoutTaxSettingsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CompanyCreateNestedOneWithoutSystemSettingsInput = {
    create?: XOR<CompanyCreateWithoutSystemSettingsInput, CompanyUncheckedCreateWithoutSystemSettingsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSystemSettingsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutSystemSettingsNestedInput = {
    create?: XOR<CompanyCreateWithoutSystemSettingsInput, CompanyUncheckedCreateWithoutSystemSettingsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSystemSettingsInput
    upsert?: CompanyUpsertWithoutSystemSettingsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutSystemSettingsInput, CompanyUpdateWithoutSystemSettingsInput>, CompanyUncheckedUpdateWithoutSystemSettingsInput>
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutUsersInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    connect?: CompanyWhereUniqueInput
  }

  export type VoucherCreateNestedManyWithoutPostedByInput = {
    create?: XOR<VoucherCreateWithoutPostedByInput, VoucherUncheckedCreateWithoutPostedByInput> | VoucherCreateWithoutPostedByInput[] | VoucherUncheckedCreateWithoutPostedByInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutPostedByInput | VoucherCreateOrConnectWithoutPostedByInput[]
    createMany?: VoucherCreateManyPostedByInputEnvelope
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type VoucherUncheckedCreateNestedManyWithoutPostedByInput = {
    create?: XOR<VoucherCreateWithoutPostedByInput, VoucherUncheckedCreateWithoutPostedByInput> | VoucherCreateWithoutPostedByInput[] | VoucherUncheckedCreateWithoutPostedByInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutPostedByInput | VoucherCreateOrConnectWithoutPostedByInput[]
    createMany?: VoucherCreateManyPostedByInputEnvelope
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type CompanyUpdateOneWithoutUsersNestedInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    upsert?: CompanyUpsertWithoutUsersInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUsersInput, CompanyUpdateWithoutUsersInput>, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type VoucherUpdateManyWithoutPostedByNestedInput = {
    create?: XOR<VoucherCreateWithoutPostedByInput, VoucherUncheckedCreateWithoutPostedByInput> | VoucherCreateWithoutPostedByInput[] | VoucherUncheckedCreateWithoutPostedByInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutPostedByInput | VoucherCreateOrConnectWithoutPostedByInput[]
    upsert?: VoucherUpsertWithWhereUniqueWithoutPostedByInput | VoucherUpsertWithWhereUniqueWithoutPostedByInput[]
    createMany?: VoucherCreateManyPostedByInputEnvelope
    set?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    disconnect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    delete?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    update?: VoucherUpdateWithWhereUniqueWithoutPostedByInput | VoucherUpdateWithWhereUniqueWithoutPostedByInput[]
    updateMany?: VoucherUpdateManyWithWhereWithoutPostedByInput | VoucherUpdateManyWithWhereWithoutPostedByInput[]
    deleteMany?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type VoucherUncheckedUpdateManyWithoutPostedByNestedInput = {
    create?: XOR<VoucherCreateWithoutPostedByInput, VoucherUncheckedCreateWithoutPostedByInput> | VoucherCreateWithoutPostedByInput[] | VoucherUncheckedCreateWithoutPostedByInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutPostedByInput | VoucherCreateOrConnectWithoutPostedByInput[]
    upsert?: VoucherUpsertWithWhereUniqueWithoutPostedByInput | VoucherUpsertWithWhereUniqueWithoutPostedByInput[]
    createMany?: VoucherCreateManyPostedByInputEnvelope
    set?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    disconnect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    delete?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    update?: VoucherUpdateWithWhereUniqueWithoutPostedByInput | VoucherUpdateWithWhereUniqueWithoutPostedByInput[]
    updateMany?: VoucherUpdateManyWithWhereWithoutPostedByInput | VoucherUpdateManyWithWhereWithoutPostedByInput[]
    deleteMany?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutCustomerInput = {
    create?: XOR<AccountCreateWithoutCustomerInput, AccountUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCustomerInput
    connect?: AccountWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutCustomersInput = {
    create?: XOR<CompanyCreateWithoutCustomersInput, CompanyUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCustomersInput
    connect?: CompanyWhereUniqueInput
  }

  export type ServiceInvoiceCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ServiceInvoiceCreateWithoutCustomerInput, ServiceInvoiceUncheckedCreateWithoutCustomerInput> | ServiceInvoiceCreateWithoutCustomerInput[] | ServiceInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServiceInvoiceCreateOrConnectWithoutCustomerInput | ServiceInvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: ServiceInvoiceCreateManyCustomerInputEnvelope
    connect?: ServiceInvoiceWhereUniqueInput | ServiceInvoiceWhereUniqueInput[]
  }

  export type FreightInvoiceCreateNestedManyWithoutCustomerInput = {
    create?: XOR<FreightInvoiceCreateWithoutCustomerInput, FreightInvoiceUncheckedCreateWithoutCustomerInput> | FreightInvoiceCreateWithoutCustomerInput[] | FreightInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: FreightInvoiceCreateOrConnectWithoutCustomerInput | FreightInvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: FreightInvoiceCreateManyCustomerInputEnvelope
    connect?: FreightInvoiceWhereUniqueInput | FreightInvoiceWhereUniqueInput[]
  }

  export type JobCreateNestedManyWithoutCustomerInput = {
    create?: XOR<JobCreateWithoutCustomerInput, JobUncheckedCreateWithoutCustomerInput> | JobCreateWithoutCustomerInput[] | JobUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCustomerInput | JobCreateOrConnectWithoutCustomerInput[]
    createMany?: JobCreateManyCustomerInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput> | PaymentCreateWithoutCustomerInput[] | PaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCustomerInput | PaymentCreateOrConnectWithoutCustomerInput[]
    createMany?: PaymentCreateManyCustomerInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ServiceInvoiceUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ServiceInvoiceCreateWithoutCustomerInput, ServiceInvoiceUncheckedCreateWithoutCustomerInput> | ServiceInvoiceCreateWithoutCustomerInput[] | ServiceInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServiceInvoiceCreateOrConnectWithoutCustomerInput | ServiceInvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: ServiceInvoiceCreateManyCustomerInputEnvelope
    connect?: ServiceInvoiceWhereUniqueInput | ServiceInvoiceWhereUniqueInput[]
  }

  export type FreightInvoiceUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<FreightInvoiceCreateWithoutCustomerInput, FreightInvoiceUncheckedCreateWithoutCustomerInput> | FreightInvoiceCreateWithoutCustomerInput[] | FreightInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: FreightInvoiceCreateOrConnectWithoutCustomerInput | FreightInvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: FreightInvoiceCreateManyCustomerInputEnvelope
    connect?: FreightInvoiceWhereUniqueInput | FreightInvoiceWhereUniqueInput[]
  }

  export type JobUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<JobCreateWithoutCustomerInput, JobUncheckedCreateWithoutCustomerInput> | JobCreateWithoutCustomerInput[] | JobUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCustomerInput | JobCreateOrConnectWithoutCustomerInput[]
    createMany?: JobCreateManyCustomerInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput> | PaymentCreateWithoutCustomerInput[] | PaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCustomerInput | PaymentCreateOrConnectWithoutCustomerInput[]
    createMany?: PaymentCreateManyCustomerInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type AccountUpdateOneWithoutCustomerNestedInput = {
    create?: XOR<AccountCreateWithoutCustomerInput, AccountUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCustomerInput
    upsert?: AccountUpsertWithoutCustomerInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutCustomerInput, AccountUpdateWithoutCustomerInput>, AccountUncheckedUpdateWithoutCustomerInput>
  }

  export type CompanyUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<CompanyCreateWithoutCustomersInput, CompanyUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCustomersInput
    upsert?: CompanyUpsertWithoutCustomersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCustomersInput, CompanyUpdateWithoutCustomersInput>, CompanyUncheckedUpdateWithoutCustomersInput>
  }

  export type ServiceInvoiceUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ServiceInvoiceCreateWithoutCustomerInput, ServiceInvoiceUncheckedCreateWithoutCustomerInput> | ServiceInvoiceCreateWithoutCustomerInput[] | ServiceInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServiceInvoiceCreateOrConnectWithoutCustomerInput | ServiceInvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: ServiceInvoiceUpsertWithWhereUniqueWithoutCustomerInput | ServiceInvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ServiceInvoiceCreateManyCustomerInputEnvelope
    set?: ServiceInvoiceWhereUniqueInput | ServiceInvoiceWhereUniqueInput[]
    disconnect?: ServiceInvoiceWhereUniqueInput | ServiceInvoiceWhereUniqueInput[]
    delete?: ServiceInvoiceWhereUniqueInput | ServiceInvoiceWhereUniqueInput[]
    connect?: ServiceInvoiceWhereUniqueInput | ServiceInvoiceWhereUniqueInput[]
    update?: ServiceInvoiceUpdateWithWhereUniqueWithoutCustomerInput | ServiceInvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ServiceInvoiceUpdateManyWithWhereWithoutCustomerInput | ServiceInvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ServiceInvoiceScalarWhereInput | ServiceInvoiceScalarWhereInput[]
  }

  export type FreightInvoiceUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<FreightInvoiceCreateWithoutCustomerInput, FreightInvoiceUncheckedCreateWithoutCustomerInput> | FreightInvoiceCreateWithoutCustomerInput[] | FreightInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: FreightInvoiceCreateOrConnectWithoutCustomerInput | FreightInvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: FreightInvoiceUpsertWithWhereUniqueWithoutCustomerInput | FreightInvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: FreightInvoiceCreateManyCustomerInputEnvelope
    set?: FreightInvoiceWhereUniqueInput | FreightInvoiceWhereUniqueInput[]
    disconnect?: FreightInvoiceWhereUniqueInput | FreightInvoiceWhereUniqueInput[]
    delete?: FreightInvoiceWhereUniqueInput | FreightInvoiceWhereUniqueInput[]
    connect?: FreightInvoiceWhereUniqueInput | FreightInvoiceWhereUniqueInput[]
    update?: FreightInvoiceUpdateWithWhereUniqueWithoutCustomerInput | FreightInvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: FreightInvoiceUpdateManyWithWhereWithoutCustomerInput | FreightInvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: FreightInvoiceScalarWhereInput | FreightInvoiceScalarWhereInput[]
  }

  export type JobUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<JobCreateWithoutCustomerInput, JobUncheckedCreateWithoutCustomerInput> | JobCreateWithoutCustomerInput[] | JobUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCustomerInput | JobCreateOrConnectWithoutCustomerInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutCustomerInput | JobUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: JobCreateManyCustomerInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutCustomerInput | JobUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: JobUpdateManyWithWhereWithoutCustomerInput | JobUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput> | PaymentCreateWithoutCustomerInput[] | PaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCustomerInput | PaymentCreateOrConnectWithoutCustomerInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCustomerInput | PaymentUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PaymentCreateManyCustomerInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCustomerInput | PaymentUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCustomerInput | PaymentUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ServiceInvoiceUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ServiceInvoiceCreateWithoutCustomerInput, ServiceInvoiceUncheckedCreateWithoutCustomerInput> | ServiceInvoiceCreateWithoutCustomerInput[] | ServiceInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServiceInvoiceCreateOrConnectWithoutCustomerInput | ServiceInvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: ServiceInvoiceUpsertWithWhereUniqueWithoutCustomerInput | ServiceInvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ServiceInvoiceCreateManyCustomerInputEnvelope
    set?: ServiceInvoiceWhereUniqueInput | ServiceInvoiceWhereUniqueInput[]
    disconnect?: ServiceInvoiceWhereUniqueInput | ServiceInvoiceWhereUniqueInput[]
    delete?: ServiceInvoiceWhereUniqueInput | ServiceInvoiceWhereUniqueInput[]
    connect?: ServiceInvoiceWhereUniqueInput | ServiceInvoiceWhereUniqueInput[]
    update?: ServiceInvoiceUpdateWithWhereUniqueWithoutCustomerInput | ServiceInvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ServiceInvoiceUpdateManyWithWhereWithoutCustomerInput | ServiceInvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ServiceInvoiceScalarWhereInput | ServiceInvoiceScalarWhereInput[]
  }

  export type FreightInvoiceUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<FreightInvoiceCreateWithoutCustomerInput, FreightInvoiceUncheckedCreateWithoutCustomerInput> | FreightInvoiceCreateWithoutCustomerInput[] | FreightInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: FreightInvoiceCreateOrConnectWithoutCustomerInput | FreightInvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: FreightInvoiceUpsertWithWhereUniqueWithoutCustomerInput | FreightInvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: FreightInvoiceCreateManyCustomerInputEnvelope
    set?: FreightInvoiceWhereUniqueInput | FreightInvoiceWhereUniqueInput[]
    disconnect?: FreightInvoiceWhereUniqueInput | FreightInvoiceWhereUniqueInput[]
    delete?: FreightInvoiceWhereUniqueInput | FreightInvoiceWhereUniqueInput[]
    connect?: FreightInvoiceWhereUniqueInput | FreightInvoiceWhereUniqueInput[]
    update?: FreightInvoiceUpdateWithWhereUniqueWithoutCustomerInput | FreightInvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: FreightInvoiceUpdateManyWithWhereWithoutCustomerInput | FreightInvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: FreightInvoiceScalarWhereInput | FreightInvoiceScalarWhereInput[]
  }

  export type JobUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<JobCreateWithoutCustomerInput, JobUncheckedCreateWithoutCustomerInput> | JobCreateWithoutCustomerInput[] | JobUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCustomerInput | JobCreateOrConnectWithoutCustomerInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutCustomerInput | JobUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: JobCreateManyCustomerInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutCustomerInput | JobUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: JobUpdateManyWithWhereWithoutCustomerInput | JobUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput> | PaymentCreateWithoutCustomerInput[] | PaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCustomerInput | PaymentCreateOrConnectWithoutCustomerInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCustomerInput | PaymentUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PaymentCreateManyCustomerInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCustomerInput | PaymentUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCustomerInput | PaymentUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ExpenseCreateNestedManyWithoutVendorInput = {
    create?: XOR<ExpenseCreateWithoutVendorInput, ExpenseUncheckedCreateWithoutVendorInput> | ExpenseCreateWithoutVendorInput[] | ExpenseUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutVendorInput | ExpenseCreateOrConnectWithoutVendorInput[]
    createMany?: ExpenseCreateManyVendorInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutVendorInput = {
    create?: XOR<PaymentCreateWithoutVendorInput, PaymentUncheckedCreateWithoutVendorInput> | PaymentCreateWithoutVendorInput[] | PaymentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutVendorInput | PaymentCreateOrConnectWithoutVendorInput[]
    createMany?: PaymentCreateManyVendorInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PurchaseInvoiceCreateNestedManyWithoutVendorInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutVendorInput, PurchaseInvoiceUncheckedCreateWithoutVendorInput> | PurchaseInvoiceCreateWithoutVendorInput[] | PurchaseInvoiceUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutVendorInput | PurchaseInvoiceCreateOrConnectWithoutVendorInput[]
    createMany?: PurchaseInvoiceCreateManyVendorInputEnvelope
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
  }

  export type AccountCreateNestedOneWithoutVendorInput = {
    create?: XOR<AccountCreateWithoutVendorInput, AccountUncheckedCreateWithoutVendorInput>
    connectOrCreate?: AccountCreateOrConnectWithoutVendorInput
    connect?: AccountWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutVendorsInput = {
    create?: XOR<CompanyCreateWithoutVendorsInput, CompanyUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutVendorsInput
    connect?: CompanyWhereUniqueInput
  }

  export type FreightInvoiceItemCreateNestedManyWithoutVendorInput = {
    create?: XOR<FreightInvoiceItemCreateWithoutVendorInput, FreightInvoiceItemUncheckedCreateWithoutVendorInput> | FreightInvoiceItemCreateWithoutVendorInput[] | FreightInvoiceItemUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: FreightInvoiceItemCreateOrConnectWithoutVendorInput | FreightInvoiceItemCreateOrConnectWithoutVendorInput[]
    createMany?: FreightInvoiceItemCreateManyVendorInputEnvelope
    connect?: FreightInvoiceItemWhereUniqueInput | FreightInvoiceItemWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<ExpenseCreateWithoutVendorInput, ExpenseUncheckedCreateWithoutVendorInput> | ExpenseCreateWithoutVendorInput[] | ExpenseUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutVendorInput | ExpenseCreateOrConnectWithoutVendorInput[]
    createMany?: ExpenseCreateManyVendorInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<PaymentCreateWithoutVendorInput, PaymentUncheckedCreateWithoutVendorInput> | PaymentCreateWithoutVendorInput[] | PaymentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutVendorInput | PaymentCreateOrConnectWithoutVendorInput[]
    createMany?: PaymentCreateManyVendorInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PurchaseInvoiceUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutVendorInput, PurchaseInvoiceUncheckedCreateWithoutVendorInput> | PurchaseInvoiceCreateWithoutVendorInput[] | PurchaseInvoiceUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutVendorInput | PurchaseInvoiceCreateOrConnectWithoutVendorInput[]
    createMany?: PurchaseInvoiceCreateManyVendorInputEnvelope
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
  }

  export type FreightInvoiceItemUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<FreightInvoiceItemCreateWithoutVendorInput, FreightInvoiceItemUncheckedCreateWithoutVendorInput> | FreightInvoiceItemCreateWithoutVendorInput[] | FreightInvoiceItemUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: FreightInvoiceItemCreateOrConnectWithoutVendorInput | FreightInvoiceItemCreateOrConnectWithoutVendorInput[]
    createMany?: FreightInvoiceItemCreateManyVendorInputEnvelope
    connect?: FreightInvoiceItemWhereUniqueInput | FreightInvoiceItemWhereUniqueInput[]
  }

  export type ExpenseUpdateManyWithoutVendorNestedInput = {
    create?: XOR<ExpenseCreateWithoutVendorInput, ExpenseUncheckedCreateWithoutVendorInput> | ExpenseCreateWithoutVendorInput[] | ExpenseUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutVendorInput | ExpenseCreateOrConnectWithoutVendorInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutVendorInput | ExpenseUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: ExpenseCreateManyVendorInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutVendorInput | ExpenseUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutVendorInput | ExpenseUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutVendorNestedInput = {
    create?: XOR<PaymentCreateWithoutVendorInput, PaymentUncheckedCreateWithoutVendorInput> | PaymentCreateWithoutVendorInput[] | PaymentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutVendorInput | PaymentCreateOrConnectWithoutVendorInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutVendorInput | PaymentUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: PaymentCreateManyVendorInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutVendorInput | PaymentUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutVendorInput | PaymentUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PurchaseInvoiceUpdateManyWithoutVendorNestedInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutVendorInput, PurchaseInvoiceUncheckedCreateWithoutVendorInput> | PurchaseInvoiceCreateWithoutVendorInput[] | PurchaseInvoiceUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutVendorInput | PurchaseInvoiceCreateOrConnectWithoutVendorInput[]
    upsert?: PurchaseInvoiceUpsertWithWhereUniqueWithoutVendorInput | PurchaseInvoiceUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: PurchaseInvoiceCreateManyVendorInputEnvelope
    set?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    disconnect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    delete?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    update?: PurchaseInvoiceUpdateWithWhereUniqueWithoutVendorInput | PurchaseInvoiceUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: PurchaseInvoiceUpdateManyWithWhereWithoutVendorInput | PurchaseInvoiceUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
  }

  export type AccountUpdateOneWithoutVendorNestedInput = {
    create?: XOR<AccountCreateWithoutVendorInput, AccountUncheckedCreateWithoutVendorInput>
    connectOrCreate?: AccountCreateOrConnectWithoutVendorInput
    upsert?: AccountUpsertWithoutVendorInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutVendorInput, AccountUpdateWithoutVendorInput>, AccountUncheckedUpdateWithoutVendorInput>
  }

  export type CompanyUpdateOneRequiredWithoutVendorsNestedInput = {
    create?: XOR<CompanyCreateWithoutVendorsInput, CompanyUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutVendorsInput
    upsert?: CompanyUpsertWithoutVendorsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutVendorsInput, CompanyUpdateWithoutVendorsInput>, CompanyUncheckedUpdateWithoutVendorsInput>
  }

  export type FreightInvoiceItemUpdateManyWithoutVendorNestedInput = {
    create?: XOR<FreightInvoiceItemCreateWithoutVendorInput, FreightInvoiceItemUncheckedCreateWithoutVendorInput> | FreightInvoiceItemCreateWithoutVendorInput[] | FreightInvoiceItemUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: FreightInvoiceItemCreateOrConnectWithoutVendorInput | FreightInvoiceItemCreateOrConnectWithoutVendorInput[]
    upsert?: FreightInvoiceItemUpsertWithWhereUniqueWithoutVendorInput | FreightInvoiceItemUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: FreightInvoiceItemCreateManyVendorInputEnvelope
    set?: FreightInvoiceItemWhereUniqueInput | FreightInvoiceItemWhereUniqueInput[]
    disconnect?: FreightInvoiceItemWhereUniqueInput | FreightInvoiceItemWhereUniqueInput[]
    delete?: FreightInvoiceItemWhereUniqueInput | FreightInvoiceItemWhereUniqueInput[]
    connect?: FreightInvoiceItemWhereUniqueInput | FreightInvoiceItemWhereUniqueInput[]
    update?: FreightInvoiceItemUpdateWithWhereUniqueWithoutVendorInput | FreightInvoiceItemUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: FreightInvoiceItemUpdateManyWithWhereWithoutVendorInput | FreightInvoiceItemUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: FreightInvoiceItemScalarWhereInput | FreightInvoiceItemScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<ExpenseCreateWithoutVendorInput, ExpenseUncheckedCreateWithoutVendorInput> | ExpenseCreateWithoutVendorInput[] | ExpenseUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutVendorInput | ExpenseCreateOrConnectWithoutVendorInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutVendorInput | ExpenseUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: ExpenseCreateManyVendorInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutVendorInput | ExpenseUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutVendorInput | ExpenseUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<PaymentCreateWithoutVendorInput, PaymentUncheckedCreateWithoutVendorInput> | PaymentCreateWithoutVendorInput[] | PaymentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutVendorInput | PaymentCreateOrConnectWithoutVendorInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutVendorInput | PaymentUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: PaymentCreateManyVendorInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutVendorInput | PaymentUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutVendorInput | PaymentUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PurchaseInvoiceUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutVendorInput, PurchaseInvoiceUncheckedCreateWithoutVendorInput> | PurchaseInvoiceCreateWithoutVendorInput[] | PurchaseInvoiceUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutVendorInput | PurchaseInvoiceCreateOrConnectWithoutVendorInput[]
    upsert?: PurchaseInvoiceUpsertWithWhereUniqueWithoutVendorInput | PurchaseInvoiceUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: PurchaseInvoiceCreateManyVendorInputEnvelope
    set?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    disconnect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    delete?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    update?: PurchaseInvoiceUpdateWithWhereUniqueWithoutVendorInput | PurchaseInvoiceUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: PurchaseInvoiceUpdateManyWithWhereWithoutVendorInput | PurchaseInvoiceUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
  }

  export type FreightInvoiceItemUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<FreightInvoiceItemCreateWithoutVendorInput, FreightInvoiceItemUncheckedCreateWithoutVendorInput> | FreightInvoiceItemCreateWithoutVendorInput[] | FreightInvoiceItemUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: FreightInvoiceItemCreateOrConnectWithoutVendorInput | FreightInvoiceItemCreateOrConnectWithoutVendorInput[]
    upsert?: FreightInvoiceItemUpsertWithWhereUniqueWithoutVendorInput | FreightInvoiceItemUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: FreightInvoiceItemCreateManyVendorInputEnvelope
    set?: FreightInvoiceItemWhereUniqueInput | FreightInvoiceItemWhereUniqueInput[]
    disconnect?: FreightInvoiceItemWhereUniqueInput | FreightInvoiceItemWhereUniqueInput[]
    delete?: FreightInvoiceItemWhereUniqueInput | FreightInvoiceItemWhereUniqueInput[]
    connect?: FreightInvoiceItemWhereUniqueInput | FreightInvoiceItemWhereUniqueInput[]
    update?: FreightInvoiceItemUpdateWithWhereUniqueWithoutVendorInput | FreightInvoiceItemUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: FreightInvoiceItemUpdateManyWithWhereWithoutVendorInput | FreightInvoiceItemUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: FreightInvoiceItemScalarWhereInput | FreightInvoiceItemScalarWhereInput[]
  }

  export type ExpenseCreateNestedManyWithoutJobInput = {
    create?: XOR<ExpenseCreateWithoutJobInput, ExpenseUncheckedCreateWithoutJobInput> | ExpenseCreateWithoutJobInput[] | ExpenseUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutJobInput | ExpenseCreateOrConnectWithoutJobInput[]
    createMany?: ExpenseCreateManyJobInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ServiceInvoiceCreateNestedOneWithoutJobInput = {
    create?: XOR<ServiceInvoiceCreateWithoutJobInput, ServiceInvoiceUncheckedCreateWithoutJobInput>
    connectOrCreate?: ServiceInvoiceCreateOrConnectWithoutJobInput
    connect?: ServiceInvoiceWhereUniqueInput
  }

  export type FreightInvoiceCreateNestedOneWithoutJobInput = {
    create?: XOR<FreightInvoiceCreateWithoutJobInput, FreightInvoiceUncheckedCreateWithoutJobInput>
    connectOrCreate?: FreightInvoiceCreateOrConnectWithoutJobInput
    connect?: FreightInvoiceWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutJobsInput = {
    create?: XOR<BranchCreateWithoutJobsInput, BranchUncheckedCreateWithoutJobsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutJobsInput
    connect?: BranchWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutJobsInput = {
    create?: XOR<CompanyCreateWithoutJobsInput, CompanyUncheckedCreateWithoutJobsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutJobsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutJobsInput = {
    create?: XOR<CustomerCreateWithoutJobsInput, CustomerUncheckedCreateWithoutJobsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutJobsInput
    connect?: CustomerWhereUniqueInput
  }

  export type PortCreateNestedOneWithoutJobsInput = {
    create?: XOR<PortCreateWithoutJobsInput, PortUncheckedCreateWithoutJobsInput>
    connectOrCreate?: PortCreateOrConnectWithoutJobsInput
    connect?: PortWhereUniqueInput
  }

  export type ExpenseUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<ExpenseCreateWithoutJobInput, ExpenseUncheckedCreateWithoutJobInput> | ExpenseCreateWithoutJobInput[] | ExpenseUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutJobInput | ExpenseCreateOrConnectWithoutJobInput[]
    createMany?: ExpenseCreateManyJobInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ServiceInvoiceUncheckedCreateNestedOneWithoutJobInput = {
    create?: XOR<ServiceInvoiceCreateWithoutJobInput, ServiceInvoiceUncheckedCreateWithoutJobInput>
    connectOrCreate?: ServiceInvoiceCreateOrConnectWithoutJobInput
    connect?: ServiceInvoiceWhereUniqueInput
  }

  export type FreightInvoiceUncheckedCreateNestedOneWithoutJobInput = {
    create?: XOR<FreightInvoiceCreateWithoutJobInput, FreightInvoiceUncheckedCreateWithoutJobInput>
    connectOrCreate?: FreightInvoiceCreateOrConnectWithoutJobInput
    connect?: FreightInvoiceWhereUniqueInput
  }

  export type EnumJobTypeFieldUpdateOperationsInput = {
    set?: $Enums.JobType
  }

  export type EnumJobStatusFieldUpdateOperationsInput = {
    set?: $Enums.JobStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ExpenseUpdateManyWithoutJobNestedInput = {
    create?: XOR<ExpenseCreateWithoutJobInput, ExpenseUncheckedCreateWithoutJobInput> | ExpenseCreateWithoutJobInput[] | ExpenseUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutJobInput | ExpenseCreateOrConnectWithoutJobInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutJobInput | ExpenseUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: ExpenseCreateManyJobInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutJobInput | ExpenseUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutJobInput | ExpenseUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ServiceInvoiceUpdateOneWithoutJobNestedInput = {
    create?: XOR<ServiceInvoiceCreateWithoutJobInput, ServiceInvoiceUncheckedCreateWithoutJobInput>
    connectOrCreate?: ServiceInvoiceCreateOrConnectWithoutJobInput
    upsert?: ServiceInvoiceUpsertWithoutJobInput
    disconnect?: ServiceInvoiceWhereInput | boolean
    delete?: ServiceInvoiceWhereInput | boolean
    connect?: ServiceInvoiceWhereUniqueInput
    update?: XOR<XOR<ServiceInvoiceUpdateToOneWithWhereWithoutJobInput, ServiceInvoiceUpdateWithoutJobInput>, ServiceInvoiceUncheckedUpdateWithoutJobInput>
  }

  export type FreightInvoiceUpdateOneWithoutJobNestedInput = {
    create?: XOR<FreightInvoiceCreateWithoutJobInput, FreightInvoiceUncheckedCreateWithoutJobInput>
    connectOrCreate?: FreightInvoiceCreateOrConnectWithoutJobInput
    upsert?: FreightInvoiceUpsertWithoutJobInput
    disconnect?: FreightInvoiceWhereInput | boolean
    delete?: FreightInvoiceWhereInput | boolean
    connect?: FreightInvoiceWhereUniqueInput
    update?: XOR<XOR<FreightInvoiceUpdateToOneWithWhereWithoutJobInput, FreightInvoiceUpdateWithoutJobInput>, FreightInvoiceUncheckedUpdateWithoutJobInput>
  }

  export type BranchUpdateOneWithoutJobsNestedInput = {
    create?: XOR<BranchCreateWithoutJobsInput, BranchUncheckedCreateWithoutJobsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutJobsInput
    upsert?: BranchUpsertWithoutJobsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutJobsInput, BranchUpdateWithoutJobsInput>, BranchUncheckedUpdateWithoutJobsInput>
  }

  export type CompanyUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<CompanyCreateWithoutJobsInput, CompanyUncheckedCreateWithoutJobsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutJobsInput
    upsert?: CompanyUpsertWithoutJobsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutJobsInput, CompanyUpdateWithoutJobsInput>, CompanyUncheckedUpdateWithoutJobsInput>
  }

  export type CustomerUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<CustomerCreateWithoutJobsInput, CustomerUncheckedCreateWithoutJobsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutJobsInput
    upsert?: CustomerUpsertWithoutJobsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutJobsInput, CustomerUpdateWithoutJobsInput>, CustomerUncheckedUpdateWithoutJobsInput>
  }

  export type PortUpdateOneWithoutJobsNestedInput = {
    create?: XOR<PortCreateWithoutJobsInput, PortUncheckedCreateWithoutJobsInput>
    connectOrCreate?: PortCreateOrConnectWithoutJobsInput
    upsert?: PortUpsertWithoutJobsInput
    disconnect?: PortWhereInput | boolean
    delete?: PortWhereInput | boolean
    connect?: PortWhereUniqueInput
    update?: XOR<XOR<PortUpdateToOneWithWhereWithoutJobsInput, PortUpdateWithoutJobsInput>, PortUncheckedUpdateWithoutJobsInput>
  }

  export type ExpenseUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<ExpenseCreateWithoutJobInput, ExpenseUncheckedCreateWithoutJobInput> | ExpenseCreateWithoutJobInput[] | ExpenseUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutJobInput | ExpenseCreateOrConnectWithoutJobInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutJobInput | ExpenseUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: ExpenseCreateManyJobInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutJobInput | ExpenseUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutJobInput | ExpenseUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ServiceInvoiceUncheckedUpdateOneWithoutJobNestedInput = {
    create?: XOR<ServiceInvoiceCreateWithoutJobInput, ServiceInvoiceUncheckedCreateWithoutJobInput>
    connectOrCreate?: ServiceInvoiceCreateOrConnectWithoutJobInput
    upsert?: ServiceInvoiceUpsertWithoutJobInput
    disconnect?: ServiceInvoiceWhereInput | boolean
    delete?: ServiceInvoiceWhereInput | boolean
    connect?: ServiceInvoiceWhereUniqueInput
    update?: XOR<XOR<ServiceInvoiceUpdateToOneWithWhereWithoutJobInput, ServiceInvoiceUpdateWithoutJobInput>, ServiceInvoiceUncheckedUpdateWithoutJobInput>
  }

  export type FreightInvoiceUncheckedUpdateOneWithoutJobNestedInput = {
    create?: XOR<FreightInvoiceCreateWithoutJobInput, FreightInvoiceUncheckedCreateWithoutJobInput>
    connectOrCreate?: FreightInvoiceCreateOrConnectWithoutJobInput
    upsert?: FreightInvoiceUpsertWithoutJobInput
    disconnect?: FreightInvoiceWhereInput | boolean
    delete?: FreightInvoiceWhereInput | boolean
    connect?: FreightInvoiceWhereUniqueInput
    update?: XOR<XOR<FreightInvoiceUpdateToOneWithWhereWithoutJobInput, FreightInvoiceUpdateWithoutJobInput>, FreightInvoiceUncheckedUpdateWithoutJobInput>
  }

  export type CompanyCreateNestedOneWithoutExpensesMasterInput = {
    create?: XOR<CompanyCreateWithoutExpensesMasterInput, CompanyUncheckedCreateWithoutExpensesMasterInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutExpensesMasterInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutExpensesMasterNestedInput = {
    create?: XOR<CompanyCreateWithoutExpensesMasterInput, CompanyUncheckedCreateWithoutExpensesMasterInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutExpensesMasterInput
    upsert?: CompanyUpsertWithoutExpensesMasterInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutExpensesMasterInput, CompanyUpdateWithoutExpensesMasterInput>, CompanyUncheckedUpdateWithoutExpensesMasterInput>
  }

  export type CompanyCreateNestedOneWithoutExpensesInput = {
    create?: XOR<CompanyCreateWithoutExpensesInput, CompanyUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutExpensesInput
    connect?: CompanyWhereUniqueInput
  }

  export type JobCreateNestedOneWithoutExpensesInput = {
    create?: XOR<JobCreateWithoutExpensesInput, JobUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: JobCreateOrConnectWithoutExpensesInput
    connect?: JobWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutExpensesInput = {
    create?: XOR<VendorCreateWithoutExpensesInput, VendorUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutExpensesInput
    connect?: VendorWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutExpensesNestedInput = {
    create?: XOR<CompanyCreateWithoutExpensesInput, CompanyUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutExpensesInput
    upsert?: CompanyUpsertWithoutExpensesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutExpensesInput, CompanyUpdateWithoutExpensesInput>, CompanyUncheckedUpdateWithoutExpensesInput>
  }

  export type JobUpdateOneRequiredWithoutExpensesNestedInput = {
    create?: XOR<JobCreateWithoutExpensesInput, JobUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: JobCreateOrConnectWithoutExpensesInput
    upsert?: JobUpsertWithoutExpensesInput
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutExpensesInput, JobUpdateWithoutExpensesInput>, JobUncheckedUpdateWithoutExpensesInput>
  }

  export type VendorUpdateOneWithoutExpensesNestedInput = {
    create?: XOR<VendorCreateWithoutExpensesInput, VendorUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutExpensesInput
    upsert?: VendorUpsertWithoutExpensesInput
    disconnect?: VendorWhereInput | boolean
    delete?: VendorWhereInput | boolean
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutExpensesInput, VendorUpdateWithoutExpensesInput>, VendorUncheckedUpdateWithoutExpensesInput>
  }

  export type CompanyCreateNestedOneWithoutServiceInvoicesInput = {
    create?: XOR<CompanyCreateWithoutServiceInvoicesInput, CompanyUncheckedCreateWithoutServiceInvoicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutServiceInvoicesInput
    connect?: CompanyWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutServiceInvoicesInput = {
    create?: XOR<CustomerCreateWithoutServiceInvoicesInput, CustomerUncheckedCreateWithoutServiceInvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutServiceInvoicesInput
    connect?: CustomerWhereUniqueInput
  }

  export type JobCreateNestedOneWithoutServiceInvoiceInput = {
    create?: XOR<JobCreateWithoutServiceInvoiceInput, JobUncheckedCreateWithoutServiceInvoiceInput>
    connectOrCreate?: JobCreateOrConnectWithoutServiceInvoiceInput
    connect?: JobWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutServiceInput = {
    create?: XOR<TransactionCreateWithoutServiceInput, TransactionUncheckedCreateWithoutServiceInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutServiceInput
    connect?: TransactionWhereUniqueInput
  }

  export type ServiceInvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<ServiceInvoiceItemCreateWithoutInvoiceInput, ServiceInvoiceItemUncheckedCreateWithoutInvoiceInput> | ServiceInvoiceItemCreateWithoutInvoiceInput[] | ServiceInvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: ServiceInvoiceItemCreateOrConnectWithoutInvoiceInput | ServiceInvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: ServiceInvoiceItemCreateManyInvoiceInputEnvelope
    connect?: ServiceInvoiceItemWhereUniqueInput | ServiceInvoiceItemWhereUniqueInput[]
  }

  export type ServiceInvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<ServiceInvoiceItemCreateWithoutInvoiceInput, ServiceInvoiceItemUncheckedCreateWithoutInvoiceInput> | ServiceInvoiceItemCreateWithoutInvoiceInput[] | ServiceInvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: ServiceInvoiceItemCreateOrConnectWithoutInvoiceInput | ServiceInvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: ServiceInvoiceItemCreateManyInvoiceInputEnvelope
    connect?: ServiceInvoiceItemWhereUniqueInput | ServiceInvoiceItemWhereUniqueInput[]
  }

  export type EnumInvoiceTypeFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceType
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type CompanyUpdateOneRequiredWithoutServiceInvoicesNestedInput = {
    create?: XOR<CompanyCreateWithoutServiceInvoicesInput, CompanyUncheckedCreateWithoutServiceInvoicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutServiceInvoicesInput
    upsert?: CompanyUpsertWithoutServiceInvoicesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutServiceInvoicesInput, CompanyUpdateWithoutServiceInvoicesInput>, CompanyUncheckedUpdateWithoutServiceInvoicesInput>
  }

  export type CustomerUpdateOneRequiredWithoutServiceInvoicesNestedInput = {
    create?: XOR<CustomerCreateWithoutServiceInvoicesInput, CustomerUncheckedCreateWithoutServiceInvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutServiceInvoicesInput
    upsert?: CustomerUpsertWithoutServiceInvoicesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutServiceInvoicesInput, CustomerUpdateWithoutServiceInvoicesInput>, CustomerUncheckedUpdateWithoutServiceInvoicesInput>
  }

  export type JobUpdateOneRequiredWithoutServiceInvoiceNestedInput = {
    create?: XOR<JobCreateWithoutServiceInvoiceInput, JobUncheckedCreateWithoutServiceInvoiceInput>
    connectOrCreate?: JobCreateOrConnectWithoutServiceInvoiceInput
    upsert?: JobUpsertWithoutServiceInvoiceInput
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutServiceInvoiceInput, JobUpdateWithoutServiceInvoiceInput>, JobUncheckedUpdateWithoutServiceInvoiceInput>
  }

  export type TransactionUpdateOneWithoutServiceNestedInput = {
    create?: XOR<TransactionCreateWithoutServiceInput, TransactionUncheckedCreateWithoutServiceInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutServiceInput
    upsert?: TransactionUpsertWithoutServiceInput
    disconnect?: TransactionWhereInput | boolean
    delete?: TransactionWhereInput | boolean
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutServiceInput, TransactionUpdateWithoutServiceInput>, TransactionUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceInvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<ServiceInvoiceItemCreateWithoutInvoiceInput, ServiceInvoiceItemUncheckedCreateWithoutInvoiceInput> | ServiceInvoiceItemCreateWithoutInvoiceInput[] | ServiceInvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: ServiceInvoiceItemCreateOrConnectWithoutInvoiceInput | ServiceInvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: ServiceInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | ServiceInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: ServiceInvoiceItemCreateManyInvoiceInputEnvelope
    set?: ServiceInvoiceItemWhereUniqueInput | ServiceInvoiceItemWhereUniqueInput[]
    disconnect?: ServiceInvoiceItemWhereUniqueInput | ServiceInvoiceItemWhereUniqueInput[]
    delete?: ServiceInvoiceItemWhereUniqueInput | ServiceInvoiceItemWhereUniqueInput[]
    connect?: ServiceInvoiceItemWhereUniqueInput | ServiceInvoiceItemWhereUniqueInput[]
    update?: ServiceInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | ServiceInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: ServiceInvoiceItemUpdateManyWithWhereWithoutInvoiceInput | ServiceInvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: ServiceInvoiceItemScalarWhereInput | ServiceInvoiceItemScalarWhereInput[]
  }

  export type ServiceInvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<ServiceInvoiceItemCreateWithoutInvoiceInput, ServiceInvoiceItemUncheckedCreateWithoutInvoiceInput> | ServiceInvoiceItemCreateWithoutInvoiceInput[] | ServiceInvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: ServiceInvoiceItemCreateOrConnectWithoutInvoiceInput | ServiceInvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: ServiceInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | ServiceInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: ServiceInvoiceItemCreateManyInvoiceInputEnvelope
    set?: ServiceInvoiceItemWhereUniqueInput | ServiceInvoiceItemWhereUniqueInput[]
    disconnect?: ServiceInvoiceItemWhereUniqueInput | ServiceInvoiceItemWhereUniqueInput[]
    delete?: ServiceInvoiceItemWhereUniqueInput | ServiceInvoiceItemWhereUniqueInput[]
    connect?: ServiceInvoiceItemWhereUniqueInput | ServiceInvoiceItemWhereUniqueInput[]
    update?: ServiceInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | ServiceInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: ServiceInvoiceItemUpdateManyWithWhereWithoutInvoiceInput | ServiceInvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: ServiceInvoiceItemScalarWhereInput | ServiceInvoiceItemScalarWhereInput[]
  }

  export type ServiceInvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<ServiceInvoiceCreateWithoutItemsInput, ServiceInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ServiceInvoiceCreateOrConnectWithoutItemsInput
    connect?: ServiceInvoiceWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutServiceItemsInput = {
    create?: XOR<ProductCreateWithoutServiceItemsInput, ProductUncheckedCreateWithoutServiceItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutServiceItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type ServiceInvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ServiceInvoiceCreateWithoutItemsInput, ServiceInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ServiceInvoiceCreateOrConnectWithoutItemsInput
    upsert?: ServiceInvoiceUpsertWithoutItemsInput
    connect?: ServiceInvoiceWhereUniqueInput
    update?: XOR<XOR<ServiceInvoiceUpdateToOneWithWhereWithoutItemsInput, ServiceInvoiceUpdateWithoutItemsInput>, ServiceInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneWithoutServiceItemsNestedInput = {
    create?: XOR<ProductCreateWithoutServiceItemsInput, ProductUncheckedCreateWithoutServiceItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutServiceItemsInput
    upsert?: ProductUpsertWithoutServiceItemsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutServiceItemsInput, ProductUpdateWithoutServiceItemsInput>, ProductUncheckedUpdateWithoutServiceItemsInput>
  }

  export type CompanyCreateNestedOneWithoutFreightInvoicesInput = {
    create?: XOR<CompanyCreateWithoutFreightInvoicesInput, CompanyUncheckedCreateWithoutFreightInvoicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutFreightInvoicesInput
    connect?: CompanyWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutFreightInvoicesInput = {
    create?: XOR<CustomerCreateWithoutFreightInvoicesInput, CustomerUncheckedCreateWithoutFreightInvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutFreightInvoicesInput
    connect?: CustomerWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutFreightInput = {
    create?: XOR<TransactionCreateWithoutFreightInput, TransactionUncheckedCreateWithoutFreightInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutFreightInput
    connect?: TransactionWhereUniqueInput
  }

  export type JobCreateNestedOneWithoutFreightInvoiceInput = {
    create?: XOR<JobCreateWithoutFreightInvoiceInput, JobUncheckedCreateWithoutFreightInvoiceInput>
    connectOrCreate?: JobCreateOrConnectWithoutFreightInvoiceInput
    connect?: JobWhereUniqueInput
  }

  export type FreightInvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<FreightInvoiceItemCreateWithoutInvoiceInput, FreightInvoiceItemUncheckedCreateWithoutInvoiceInput> | FreightInvoiceItemCreateWithoutInvoiceInput[] | FreightInvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: FreightInvoiceItemCreateOrConnectWithoutInvoiceInput | FreightInvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: FreightInvoiceItemCreateManyInvoiceInputEnvelope
    connect?: FreightInvoiceItemWhereUniqueInput | FreightInvoiceItemWhereUniqueInput[]
  }

  export type FreightInvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<FreightInvoiceItemCreateWithoutInvoiceInput, FreightInvoiceItemUncheckedCreateWithoutInvoiceInput> | FreightInvoiceItemCreateWithoutInvoiceInput[] | FreightInvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: FreightInvoiceItemCreateOrConnectWithoutInvoiceInput | FreightInvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: FreightInvoiceItemCreateManyInvoiceInputEnvelope
    connect?: FreightInvoiceItemWhereUniqueInput | FreightInvoiceItemWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutFreightInvoicesNestedInput = {
    create?: XOR<CompanyCreateWithoutFreightInvoicesInput, CompanyUncheckedCreateWithoutFreightInvoicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutFreightInvoicesInput
    upsert?: CompanyUpsertWithoutFreightInvoicesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutFreightInvoicesInput, CompanyUpdateWithoutFreightInvoicesInput>, CompanyUncheckedUpdateWithoutFreightInvoicesInput>
  }

  export type CustomerUpdateOneRequiredWithoutFreightInvoicesNestedInput = {
    create?: XOR<CustomerCreateWithoutFreightInvoicesInput, CustomerUncheckedCreateWithoutFreightInvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutFreightInvoicesInput
    upsert?: CustomerUpsertWithoutFreightInvoicesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutFreightInvoicesInput, CustomerUpdateWithoutFreightInvoicesInput>, CustomerUncheckedUpdateWithoutFreightInvoicesInput>
  }

  export type TransactionUpdateOneWithoutFreightNestedInput = {
    create?: XOR<TransactionCreateWithoutFreightInput, TransactionUncheckedCreateWithoutFreightInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutFreightInput
    upsert?: TransactionUpsertWithoutFreightInput
    disconnect?: TransactionWhereInput | boolean
    delete?: TransactionWhereInput | boolean
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutFreightInput, TransactionUpdateWithoutFreightInput>, TransactionUncheckedUpdateWithoutFreightInput>
  }

  export type JobUpdateOneWithoutFreightInvoiceNestedInput = {
    create?: XOR<JobCreateWithoutFreightInvoiceInput, JobUncheckedCreateWithoutFreightInvoiceInput>
    connectOrCreate?: JobCreateOrConnectWithoutFreightInvoiceInput
    upsert?: JobUpsertWithoutFreightInvoiceInput
    disconnect?: JobWhereInput | boolean
    delete?: JobWhereInput | boolean
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutFreightInvoiceInput, JobUpdateWithoutFreightInvoiceInput>, JobUncheckedUpdateWithoutFreightInvoiceInput>
  }

  export type FreightInvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<FreightInvoiceItemCreateWithoutInvoiceInput, FreightInvoiceItemUncheckedCreateWithoutInvoiceInput> | FreightInvoiceItemCreateWithoutInvoiceInput[] | FreightInvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: FreightInvoiceItemCreateOrConnectWithoutInvoiceInput | FreightInvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: FreightInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | FreightInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: FreightInvoiceItemCreateManyInvoiceInputEnvelope
    set?: FreightInvoiceItemWhereUniqueInput | FreightInvoiceItemWhereUniqueInput[]
    disconnect?: FreightInvoiceItemWhereUniqueInput | FreightInvoiceItemWhereUniqueInput[]
    delete?: FreightInvoiceItemWhereUniqueInput | FreightInvoiceItemWhereUniqueInput[]
    connect?: FreightInvoiceItemWhereUniqueInput | FreightInvoiceItemWhereUniqueInput[]
    update?: FreightInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | FreightInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: FreightInvoiceItemUpdateManyWithWhereWithoutInvoiceInput | FreightInvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: FreightInvoiceItemScalarWhereInput | FreightInvoiceItemScalarWhereInput[]
  }

  export type FreightInvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<FreightInvoiceItemCreateWithoutInvoiceInput, FreightInvoiceItemUncheckedCreateWithoutInvoiceInput> | FreightInvoiceItemCreateWithoutInvoiceInput[] | FreightInvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: FreightInvoiceItemCreateOrConnectWithoutInvoiceInput | FreightInvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: FreightInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | FreightInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: FreightInvoiceItemCreateManyInvoiceInputEnvelope
    set?: FreightInvoiceItemWhereUniqueInput | FreightInvoiceItemWhereUniqueInput[]
    disconnect?: FreightInvoiceItemWhereUniqueInput | FreightInvoiceItemWhereUniqueInput[]
    delete?: FreightInvoiceItemWhereUniqueInput | FreightInvoiceItemWhereUniqueInput[]
    connect?: FreightInvoiceItemWhereUniqueInput | FreightInvoiceItemWhereUniqueInput[]
    update?: FreightInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | FreightInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: FreightInvoiceItemUpdateManyWithWhereWithoutInvoiceInput | FreightInvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: FreightInvoiceItemScalarWhereInput | FreightInvoiceItemScalarWhereInput[]
  }

  export type FreightInvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<FreightInvoiceCreateWithoutItemsInput, FreightInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: FreightInvoiceCreateOrConnectWithoutItemsInput
    connect?: FreightInvoiceWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutFreightItemsInput = {
    create?: XOR<VendorCreateWithoutFreightItemsInput, VendorUncheckedCreateWithoutFreightItemsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutFreightItemsInput
    connect?: VendorWhereUniqueInput
  }

  export type FreightInvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<FreightInvoiceCreateWithoutItemsInput, FreightInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: FreightInvoiceCreateOrConnectWithoutItemsInput
    upsert?: FreightInvoiceUpsertWithoutItemsInput
    connect?: FreightInvoiceWhereUniqueInput
    update?: XOR<XOR<FreightInvoiceUpdateToOneWithWhereWithoutItemsInput, FreightInvoiceUpdateWithoutItemsInput>, FreightInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type VendorUpdateOneWithoutFreightItemsNestedInput = {
    create?: XOR<VendorCreateWithoutFreightItemsInput, VendorUncheckedCreateWithoutFreightItemsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutFreightItemsInput
    upsert?: VendorUpsertWithoutFreightItemsInput
    disconnect?: VendorWhereInput | boolean
    delete?: VendorWhereInput | boolean
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutFreightItemsInput, VendorUpdateWithoutFreightItemsInput>, VendorUncheckedUpdateWithoutFreightItemsInput>
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutProductCategoriesInput = {
    create?: XOR<CompanyCreateWithoutProductCategoriesInput, CompanyUncheckedCreateWithoutProductCategoriesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutProductCategoriesInput
    connect?: CompanyWhereUniqueInput
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutProductCategoriesNestedInput = {
    create?: XOR<CompanyCreateWithoutProductCategoriesInput, CompanyUncheckedCreateWithoutProductCategoriesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutProductCategoriesInput
    upsert?: CompanyUpsertWithoutProductCategoriesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutProductCategoriesInput, CompanyUpdateWithoutProductCategoriesInput>, CompanyUncheckedUpdateWithoutProductCategoriesInput>
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ServiceInvoiceItemCreateNestedManyWithoutProductInput = {
    create?: XOR<ServiceInvoiceItemCreateWithoutProductInput, ServiceInvoiceItemUncheckedCreateWithoutProductInput> | ServiceInvoiceItemCreateWithoutProductInput[] | ServiceInvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ServiceInvoiceItemCreateOrConnectWithoutProductInput | ServiceInvoiceItemCreateOrConnectWithoutProductInput[]
    createMany?: ServiceInvoiceItemCreateManyProductInputEnvelope
    connect?: ServiceInvoiceItemWhereUniqueInput | ServiceInvoiceItemWhereUniqueInput[]
  }

  export type ProductCategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutProductsInput = {
    create?: XOR<CompanyCreateWithoutProductsInput, CompanyUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutProductsInput
    connect?: CompanyWhereUniqueInput
  }

  export type PurchaseInvoiceItemCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutProductInput, PurchaseInvoiceItemUncheckedCreateWithoutProductInput> | PurchaseInvoiceItemCreateWithoutProductInput[] | PurchaseInvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutProductInput | PurchaseInvoiceItemCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseInvoiceItemCreateManyProductInputEnvelope
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
  }

  export type StockMovementCreateNestedManyWithoutProductInput = {
    create?: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput> | StockMovementCreateWithoutProductInput[] | StockMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutProductInput | StockMovementCreateOrConnectWithoutProductInput[]
    createMany?: StockMovementCreateManyProductInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type ServiceInvoiceItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ServiceInvoiceItemCreateWithoutProductInput, ServiceInvoiceItemUncheckedCreateWithoutProductInput> | ServiceInvoiceItemCreateWithoutProductInput[] | ServiceInvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ServiceInvoiceItemCreateOrConnectWithoutProductInput | ServiceInvoiceItemCreateOrConnectWithoutProductInput[]
    createMany?: ServiceInvoiceItemCreateManyProductInputEnvelope
    connect?: ServiceInvoiceItemWhereUniqueInput | ServiceInvoiceItemWhereUniqueInput[]
  }

  export type PurchaseInvoiceItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutProductInput, PurchaseInvoiceItemUncheckedCreateWithoutProductInput> | PurchaseInvoiceItemCreateWithoutProductInput[] | PurchaseInvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutProductInput | PurchaseInvoiceItemCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseInvoiceItemCreateManyProductInputEnvelope
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
  }

  export type StockMovementUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput> | StockMovementCreateWithoutProductInput[] | StockMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutProductInput | StockMovementCreateOrConnectWithoutProductInput[]
    createMany?: StockMovementCreateManyProductInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type ServiceInvoiceItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<ServiceInvoiceItemCreateWithoutProductInput, ServiceInvoiceItemUncheckedCreateWithoutProductInput> | ServiceInvoiceItemCreateWithoutProductInput[] | ServiceInvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ServiceInvoiceItemCreateOrConnectWithoutProductInput | ServiceInvoiceItemCreateOrConnectWithoutProductInput[]
    upsert?: ServiceInvoiceItemUpsertWithWhereUniqueWithoutProductInput | ServiceInvoiceItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ServiceInvoiceItemCreateManyProductInputEnvelope
    set?: ServiceInvoiceItemWhereUniqueInput | ServiceInvoiceItemWhereUniqueInput[]
    disconnect?: ServiceInvoiceItemWhereUniqueInput | ServiceInvoiceItemWhereUniqueInput[]
    delete?: ServiceInvoiceItemWhereUniqueInput | ServiceInvoiceItemWhereUniqueInput[]
    connect?: ServiceInvoiceItemWhereUniqueInput | ServiceInvoiceItemWhereUniqueInput[]
    update?: ServiceInvoiceItemUpdateWithWhereUniqueWithoutProductInput | ServiceInvoiceItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ServiceInvoiceItemUpdateManyWithWhereWithoutProductInput | ServiceInvoiceItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ServiceInvoiceItemScalarWhereInput | ServiceInvoiceItemScalarWhereInput[]
  }

  export type ProductCategoryUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    upsert?: ProductCategoryUpsertWithoutProductsInput
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutProductsInput, ProductCategoryUpdateWithoutProductsInput>, ProductCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CompanyUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<CompanyCreateWithoutProductsInput, CompanyUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutProductsInput
    upsert?: CompanyUpsertWithoutProductsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutProductsInput, CompanyUpdateWithoutProductsInput>, CompanyUncheckedUpdateWithoutProductsInput>
  }

  export type PurchaseInvoiceItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutProductInput, PurchaseInvoiceItemUncheckedCreateWithoutProductInput> | PurchaseInvoiceItemCreateWithoutProductInput[] | PurchaseInvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutProductInput | PurchaseInvoiceItemCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseInvoiceItemUpsertWithWhereUniqueWithoutProductInput | PurchaseInvoiceItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseInvoiceItemCreateManyProductInputEnvelope
    set?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    delete?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    update?: PurchaseInvoiceItemUpdateWithWhereUniqueWithoutProductInput | PurchaseInvoiceItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseInvoiceItemUpdateManyWithWhereWithoutProductInput | PurchaseInvoiceItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
  }

  export type StockMovementUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput> | StockMovementCreateWithoutProductInput[] | StockMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutProductInput | StockMovementCreateOrConnectWithoutProductInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutProductInput | StockMovementUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockMovementCreateManyProductInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutProductInput | StockMovementUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutProductInput | StockMovementUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type ServiceInvoiceItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ServiceInvoiceItemCreateWithoutProductInput, ServiceInvoiceItemUncheckedCreateWithoutProductInput> | ServiceInvoiceItemCreateWithoutProductInput[] | ServiceInvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ServiceInvoiceItemCreateOrConnectWithoutProductInput | ServiceInvoiceItemCreateOrConnectWithoutProductInput[]
    upsert?: ServiceInvoiceItemUpsertWithWhereUniqueWithoutProductInput | ServiceInvoiceItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ServiceInvoiceItemCreateManyProductInputEnvelope
    set?: ServiceInvoiceItemWhereUniqueInput | ServiceInvoiceItemWhereUniqueInput[]
    disconnect?: ServiceInvoiceItemWhereUniqueInput | ServiceInvoiceItemWhereUniqueInput[]
    delete?: ServiceInvoiceItemWhereUniqueInput | ServiceInvoiceItemWhereUniqueInput[]
    connect?: ServiceInvoiceItemWhereUniqueInput | ServiceInvoiceItemWhereUniqueInput[]
    update?: ServiceInvoiceItemUpdateWithWhereUniqueWithoutProductInput | ServiceInvoiceItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ServiceInvoiceItemUpdateManyWithWhereWithoutProductInput | ServiceInvoiceItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ServiceInvoiceItemScalarWhereInput | ServiceInvoiceItemScalarWhereInput[]
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutProductInput, PurchaseInvoiceItemUncheckedCreateWithoutProductInput> | PurchaseInvoiceItemCreateWithoutProductInput[] | PurchaseInvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutProductInput | PurchaseInvoiceItemCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseInvoiceItemUpsertWithWhereUniqueWithoutProductInput | PurchaseInvoiceItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseInvoiceItemCreateManyProductInputEnvelope
    set?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    delete?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    update?: PurchaseInvoiceItemUpdateWithWhereUniqueWithoutProductInput | PurchaseInvoiceItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseInvoiceItemUpdateManyWithWhereWithoutProductInput | PurchaseInvoiceItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
  }

  export type StockMovementUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput> | StockMovementCreateWithoutProductInput[] | StockMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutProductInput | StockMovementCreateOrConnectWithoutProductInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutProductInput | StockMovementUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockMovementCreateManyProductInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutProductInput | StockMovementUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutProductInput | StockMovementUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type StockMovementCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<StockMovementCreateWithoutWarehouseInput, StockMovementUncheckedCreateWithoutWarehouseInput> | StockMovementCreateWithoutWarehouseInput[] | StockMovementUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutWarehouseInput | StockMovementCreateOrConnectWithoutWarehouseInput[]
    createMany?: StockMovementCreateManyWarehouseInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutWarehousesInput = {
    create?: XOR<CompanyCreateWithoutWarehousesInput, CompanyUncheckedCreateWithoutWarehousesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutWarehousesInput
    connect?: CompanyWhereUniqueInput
  }

  export type StockMovementUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<StockMovementCreateWithoutWarehouseInput, StockMovementUncheckedCreateWithoutWarehouseInput> | StockMovementCreateWithoutWarehouseInput[] | StockMovementUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutWarehouseInput | StockMovementCreateOrConnectWithoutWarehouseInput[]
    createMany?: StockMovementCreateManyWarehouseInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type StockMovementUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<StockMovementCreateWithoutWarehouseInput, StockMovementUncheckedCreateWithoutWarehouseInput> | StockMovementCreateWithoutWarehouseInput[] | StockMovementUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutWarehouseInput | StockMovementCreateOrConnectWithoutWarehouseInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutWarehouseInput | StockMovementUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: StockMovementCreateManyWarehouseInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutWarehouseInput | StockMovementUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutWarehouseInput | StockMovementUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutWarehousesNestedInput = {
    create?: XOR<CompanyCreateWithoutWarehousesInput, CompanyUncheckedCreateWithoutWarehousesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutWarehousesInput
    upsert?: CompanyUpsertWithoutWarehousesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutWarehousesInput, CompanyUpdateWithoutWarehousesInput>, CompanyUncheckedUpdateWithoutWarehousesInput>
  }

  export type StockMovementUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<StockMovementCreateWithoutWarehouseInput, StockMovementUncheckedCreateWithoutWarehouseInput> | StockMovementCreateWithoutWarehouseInput[] | StockMovementUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutWarehouseInput | StockMovementCreateOrConnectWithoutWarehouseInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutWarehouseInput | StockMovementUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: StockMovementCreateManyWarehouseInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutWarehouseInput | StockMovementUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutWarehouseInput | StockMovementUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutStockMovementsInput = {
    create?: XOR<CompanyCreateWithoutStockMovementsInput, CompanyUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutStockMovementsInput
    connect?: CompanyWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutMovementsInput = {
    create?: XOR<ProductCreateWithoutMovementsInput, ProductUncheckedCreateWithoutMovementsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutMovementsInput
    connect?: ProductWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutStockMovementsInput = {
    create?: XOR<WarehouseCreateWithoutStockMovementsInput, WarehouseUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutStockMovementsInput
    connect?: WarehouseWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutStockMovementsNestedInput = {
    create?: XOR<CompanyCreateWithoutStockMovementsInput, CompanyUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutStockMovementsInput
    upsert?: CompanyUpsertWithoutStockMovementsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutStockMovementsInput, CompanyUpdateWithoutStockMovementsInput>, CompanyUncheckedUpdateWithoutStockMovementsInput>
  }

  export type ProductUpdateOneRequiredWithoutMovementsNestedInput = {
    create?: XOR<ProductCreateWithoutMovementsInput, ProductUncheckedCreateWithoutMovementsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutMovementsInput
    upsert?: ProductUpsertWithoutMovementsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutMovementsInput, ProductUpdateWithoutMovementsInput>, ProductUncheckedUpdateWithoutMovementsInput>
  }

  export type WarehouseUpdateOneWithoutStockMovementsNestedInput = {
    create?: XOR<WarehouseCreateWithoutStockMovementsInput, WarehouseUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutStockMovementsInput
    upsert?: WarehouseUpsertWithoutStockMovementsInput
    disconnect?: WarehouseWhereInput | boolean
    delete?: WarehouseWhereInput | boolean
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutStockMovementsInput, WarehouseUpdateWithoutStockMovementsInput>, WarehouseUncheckedUpdateWithoutStockMovementsInput>
  }

  export type CompanyCreateNestedOneWithoutPurchaseInvoicesInput = {
    create?: XOR<CompanyCreateWithoutPurchaseInvoicesInput, CompanyUncheckedCreateWithoutPurchaseInvoicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPurchaseInvoicesInput
    connect?: CompanyWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutPurchaseInput = {
    create?: XOR<TransactionCreateWithoutPurchaseInput, TransactionUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutPurchaseInput
    connect?: TransactionWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutPurchaseInvoicesInput = {
    create?: XOR<VendorCreateWithoutPurchaseInvoicesInput, VendorUncheckedCreateWithoutPurchaseInvoicesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPurchaseInvoicesInput
    connect?: VendorWhereUniqueInput
  }

  export type PurchaseInvoiceItemCreateNestedManyWithoutPurchaseInvoiceInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutPurchaseInvoiceInput, PurchaseInvoiceItemUncheckedCreateWithoutPurchaseInvoiceInput> | PurchaseInvoiceItemCreateWithoutPurchaseInvoiceInput[] | PurchaseInvoiceItemUncheckedCreateWithoutPurchaseInvoiceInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutPurchaseInvoiceInput | PurchaseInvoiceItemCreateOrConnectWithoutPurchaseInvoiceInput[]
    createMany?: PurchaseInvoiceItemCreateManyPurchaseInvoiceInputEnvelope
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
  }

  export type PurchaseInvoiceItemUncheckedCreateNestedManyWithoutPurchaseInvoiceInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutPurchaseInvoiceInput, PurchaseInvoiceItemUncheckedCreateWithoutPurchaseInvoiceInput> | PurchaseInvoiceItemCreateWithoutPurchaseInvoiceInput[] | PurchaseInvoiceItemUncheckedCreateWithoutPurchaseInvoiceInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutPurchaseInvoiceInput | PurchaseInvoiceItemCreateOrConnectWithoutPurchaseInvoiceInput[]
    createMany?: PurchaseInvoiceItemCreateManyPurchaseInvoiceInputEnvelope
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutPurchaseInvoicesNestedInput = {
    create?: XOR<CompanyCreateWithoutPurchaseInvoicesInput, CompanyUncheckedCreateWithoutPurchaseInvoicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPurchaseInvoicesInput
    upsert?: CompanyUpsertWithoutPurchaseInvoicesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPurchaseInvoicesInput, CompanyUpdateWithoutPurchaseInvoicesInput>, CompanyUncheckedUpdateWithoutPurchaseInvoicesInput>
  }

  export type TransactionUpdateOneWithoutPurchaseNestedInput = {
    create?: XOR<TransactionCreateWithoutPurchaseInput, TransactionUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutPurchaseInput
    upsert?: TransactionUpsertWithoutPurchaseInput
    disconnect?: TransactionWhereInput | boolean
    delete?: TransactionWhereInput | boolean
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutPurchaseInput, TransactionUpdateWithoutPurchaseInput>, TransactionUncheckedUpdateWithoutPurchaseInput>
  }

  export type VendorUpdateOneRequiredWithoutPurchaseInvoicesNestedInput = {
    create?: XOR<VendorCreateWithoutPurchaseInvoicesInput, VendorUncheckedCreateWithoutPurchaseInvoicesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPurchaseInvoicesInput
    upsert?: VendorUpsertWithoutPurchaseInvoicesInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutPurchaseInvoicesInput, VendorUpdateWithoutPurchaseInvoicesInput>, VendorUncheckedUpdateWithoutPurchaseInvoicesInput>
  }

  export type PurchaseInvoiceItemUpdateManyWithoutPurchaseInvoiceNestedInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutPurchaseInvoiceInput, PurchaseInvoiceItemUncheckedCreateWithoutPurchaseInvoiceInput> | PurchaseInvoiceItemCreateWithoutPurchaseInvoiceInput[] | PurchaseInvoiceItemUncheckedCreateWithoutPurchaseInvoiceInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutPurchaseInvoiceInput | PurchaseInvoiceItemCreateOrConnectWithoutPurchaseInvoiceInput[]
    upsert?: PurchaseInvoiceItemUpsertWithWhereUniqueWithoutPurchaseInvoiceInput | PurchaseInvoiceItemUpsertWithWhereUniqueWithoutPurchaseInvoiceInput[]
    createMany?: PurchaseInvoiceItemCreateManyPurchaseInvoiceInputEnvelope
    set?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    delete?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    update?: PurchaseInvoiceItemUpdateWithWhereUniqueWithoutPurchaseInvoiceInput | PurchaseInvoiceItemUpdateWithWhereUniqueWithoutPurchaseInvoiceInput[]
    updateMany?: PurchaseInvoiceItemUpdateManyWithWhereWithoutPurchaseInvoiceInput | PurchaseInvoiceItemUpdateManyWithWhereWithoutPurchaseInvoiceInput[]
    deleteMany?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyWithoutPurchaseInvoiceNestedInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutPurchaseInvoiceInput, PurchaseInvoiceItemUncheckedCreateWithoutPurchaseInvoiceInput> | PurchaseInvoiceItemCreateWithoutPurchaseInvoiceInput[] | PurchaseInvoiceItemUncheckedCreateWithoutPurchaseInvoiceInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutPurchaseInvoiceInput | PurchaseInvoiceItemCreateOrConnectWithoutPurchaseInvoiceInput[]
    upsert?: PurchaseInvoiceItemUpsertWithWhereUniqueWithoutPurchaseInvoiceInput | PurchaseInvoiceItemUpsertWithWhereUniqueWithoutPurchaseInvoiceInput[]
    createMany?: PurchaseInvoiceItemCreateManyPurchaseInvoiceInputEnvelope
    set?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    delete?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    update?: PurchaseInvoiceItemUpdateWithWhereUniqueWithoutPurchaseInvoiceInput | PurchaseInvoiceItemUpdateWithWhereUniqueWithoutPurchaseInvoiceInput[]
    updateMany?: PurchaseInvoiceItemUpdateManyWithWhereWithoutPurchaseInvoiceInput | PurchaseInvoiceItemUpdateManyWithWhereWithoutPurchaseInvoiceInput[]
    deleteMany?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutPurchaseItemsInput = {
    create?: XOR<ProductCreateWithoutPurchaseItemsInput, ProductUncheckedCreateWithoutPurchaseItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type PurchaseInvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutItemsInput, PurchaseInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutItemsInput
    connect?: PurchaseInvoiceWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutPurchaseItemsNestedInput = {
    create?: XOR<ProductCreateWithoutPurchaseItemsInput, ProductUncheckedCreateWithoutPurchaseItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseItemsInput
    upsert?: ProductUpsertWithoutPurchaseItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPurchaseItemsInput, ProductUpdateWithoutPurchaseItemsInput>, ProductUncheckedUpdateWithoutPurchaseItemsInput>
  }

  export type PurchaseInvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutItemsInput, PurchaseInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutItemsInput
    upsert?: PurchaseInvoiceUpsertWithoutItemsInput
    connect?: PurchaseInvoiceWhereUniqueInput
    update?: XOR<XOR<PurchaseInvoiceUpdateToOneWithWhereWithoutItemsInput, PurchaseInvoiceUpdateWithoutItemsInput>, PurchaseInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type CompanyCreateNestedOneWithoutAccountsInput = {
    create?: XOR<CompanyCreateWithoutAccountsInput, CompanyUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAccountsInput
    connect?: CompanyWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutChildrenInput = {
    create?: XOR<AccountCreateWithoutChildrenInput, AccountUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: AccountCreateOrConnectWithoutChildrenInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountCreateNestedManyWithoutParentInput = {
    create?: XOR<AccountCreateWithoutParentInput, AccountUncheckedCreateWithoutParentInput> | AccountCreateWithoutParentInput[] | AccountUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParentInput | AccountCreateOrConnectWithoutParentInput[]
    createMany?: AccountCreateManyParentInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type AccountEntryCreateNestedManyWithoutAccountInput = {
    create?: XOR<AccountEntryCreateWithoutAccountInput, AccountEntryUncheckedCreateWithoutAccountInput> | AccountEntryCreateWithoutAccountInput[] | AccountEntryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountEntryCreateOrConnectWithoutAccountInput | AccountEntryCreateOrConnectWithoutAccountInput[]
    createMany?: AccountEntryCreateManyAccountInputEnvelope
    connect?: AccountEntryWhereUniqueInput | AccountEntryWhereUniqueInput[]
  }

  export type CustomerCreateNestedOneWithoutAccountInput = {
    create?: XOR<CustomerCreateWithoutAccountInput, CustomerUncheckedCreateWithoutAccountInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAccountInput
    connect?: CustomerWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutAccountInput = {
    create?: XOR<VendorCreateWithoutAccountInput, VendorUncheckedCreateWithoutAccountInput>
    connectOrCreate?: VendorCreateOrConnectWithoutAccountInput
    connect?: VendorWhereUniqueInput
  }

  export type VoucherEntryCreateNestedManyWithoutAccountInput = {
    create?: XOR<VoucherEntryCreateWithoutAccountInput, VoucherEntryUncheckedCreateWithoutAccountInput> | VoucherEntryCreateWithoutAccountInput[] | VoucherEntryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: VoucherEntryCreateOrConnectWithoutAccountInput | VoucherEntryCreateOrConnectWithoutAccountInput[]
    createMany?: VoucherEntryCreateManyAccountInputEnvelope
    connect?: VoucherEntryWhereUniqueInput | VoucherEntryWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<AccountCreateWithoutParentInput, AccountUncheckedCreateWithoutParentInput> | AccountCreateWithoutParentInput[] | AccountUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParentInput | AccountCreateOrConnectWithoutParentInput[]
    createMany?: AccountCreateManyParentInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type AccountEntryUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<AccountEntryCreateWithoutAccountInput, AccountEntryUncheckedCreateWithoutAccountInput> | AccountEntryCreateWithoutAccountInput[] | AccountEntryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountEntryCreateOrConnectWithoutAccountInput | AccountEntryCreateOrConnectWithoutAccountInput[]
    createMany?: AccountEntryCreateManyAccountInputEnvelope
    connect?: AccountEntryWhereUniqueInput | AccountEntryWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedOneWithoutAccountInput = {
    create?: XOR<CustomerCreateWithoutAccountInput, CustomerUncheckedCreateWithoutAccountInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAccountInput
    connect?: CustomerWhereUniqueInput
  }

  export type VendorUncheckedCreateNestedOneWithoutAccountInput = {
    create?: XOR<VendorCreateWithoutAccountInput, VendorUncheckedCreateWithoutAccountInput>
    connectOrCreate?: VendorCreateOrConnectWithoutAccountInput
    connect?: VendorWhereUniqueInput
  }

  export type VoucherEntryUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<VoucherEntryCreateWithoutAccountInput, VoucherEntryUncheckedCreateWithoutAccountInput> | VoucherEntryCreateWithoutAccountInput[] | VoucherEntryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: VoucherEntryCreateOrConnectWithoutAccountInput | VoucherEntryCreateOrConnectWithoutAccountInput[]
    createMany?: VoucherEntryCreateManyAccountInputEnvelope
    connect?: VoucherEntryWhereUniqueInput | VoucherEntryWhereUniqueInput[]
  }

  export type EnumAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccountType
  }

  export type CompanyUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<CompanyCreateWithoutAccountsInput, CompanyUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAccountsInput
    upsert?: CompanyUpsertWithoutAccountsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAccountsInput, CompanyUpdateWithoutAccountsInput>, CompanyUncheckedUpdateWithoutAccountsInput>
  }

  export type AccountUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<AccountCreateWithoutChildrenInput, AccountUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: AccountCreateOrConnectWithoutChildrenInput
    upsert?: AccountUpsertWithoutChildrenInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutChildrenInput, AccountUpdateWithoutChildrenInput>, AccountUncheckedUpdateWithoutChildrenInput>
  }

  export type AccountUpdateManyWithoutParentNestedInput = {
    create?: XOR<AccountCreateWithoutParentInput, AccountUncheckedCreateWithoutParentInput> | AccountCreateWithoutParentInput[] | AccountUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParentInput | AccountCreateOrConnectWithoutParentInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutParentInput | AccountUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: AccountCreateManyParentInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutParentInput | AccountUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutParentInput | AccountUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type AccountEntryUpdateManyWithoutAccountNestedInput = {
    create?: XOR<AccountEntryCreateWithoutAccountInput, AccountEntryUncheckedCreateWithoutAccountInput> | AccountEntryCreateWithoutAccountInput[] | AccountEntryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountEntryCreateOrConnectWithoutAccountInput | AccountEntryCreateOrConnectWithoutAccountInput[]
    upsert?: AccountEntryUpsertWithWhereUniqueWithoutAccountInput | AccountEntryUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: AccountEntryCreateManyAccountInputEnvelope
    set?: AccountEntryWhereUniqueInput | AccountEntryWhereUniqueInput[]
    disconnect?: AccountEntryWhereUniqueInput | AccountEntryWhereUniqueInput[]
    delete?: AccountEntryWhereUniqueInput | AccountEntryWhereUniqueInput[]
    connect?: AccountEntryWhereUniqueInput | AccountEntryWhereUniqueInput[]
    update?: AccountEntryUpdateWithWhereUniqueWithoutAccountInput | AccountEntryUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: AccountEntryUpdateManyWithWhereWithoutAccountInput | AccountEntryUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: AccountEntryScalarWhereInput | AccountEntryScalarWhereInput[]
  }

  export type CustomerUpdateOneWithoutAccountNestedInput = {
    create?: XOR<CustomerCreateWithoutAccountInput, CustomerUncheckedCreateWithoutAccountInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAccountInput
    upsert?: CustomerUpsertWithoutAccountInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutAccountInput, CustomerUpdateWithoutAccountInput>, CustomerUncheckedUpdateWithoutAccountInput>
  }

  export type VendorUpdateOneWithoutAccountNestedInput = {
    create?: XOR<VendorCreateWithoutAccountInput, VendorUncheckedCreateWithoutAccountInput>
    connectOrCreate?: VendorCreateOrConnectWithoutAccountInput
    upsert?: VendorUpsertWithoutAccountInput
    disconnect?: VendorWhereInput | boolean
    delete?: VendorWhereInput | boolean
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutAccountInput, VendorUpdateWithoutAccountInput>, VendorUncheckedUpdateWithoutAccountInput>
  }

  export type VoucherEntryUpdateManyWithoutAccountNestedInput = {
    create?: XOR<VoucherEntryCreateWithoutAccountInput, VoucherEntryUncheckedCreateWithoutAccountInput> | VoucherEntryCreateWithoutAccountInput[] | VoucherEntryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: VoucherEntryCreateOrConnectWithoutAccountInput | VoucherEntryCreateOrConnectWithoutAccountInput[]
    upsert?: VoucherEntryUpsertWithWhereUniqueWithoutAccountInput | VoucherEntryUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: VoucherEntryCreateManyAccountInputEnvelope
    set?: VoucherEntryWhereUniqueInput | VoucherEntryWhereUniqueInput[]
    disconnect?: VoucherEntryWhereUniqueInput | VoucherEntryWhereUniqueInput[]
    delete?: VoucherEntryWhereUniqueInput | VoucherEntryWhereUniqueInput[]
    connect?: VoucherEntryWhereUniqueInput | VoucherEntryWhereUniqueInput[]
    update?: VoucherEntryUpdateWithWhereUniqueWithoutAccountInput | VoucherEntryUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: VoucherEntryUpdateManyWithWhereWithoutAccountInput | VoucherEntryUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: VoucherEntryScalarWhereInput | VoucherEntryScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<AccountCreateWithoutParentInput, AccountUncheckedCreateWithoutParentInput> | AccountCreateWithoutParentInput[] | AccountUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParentInput | AccountCreateOrConnectWithoutParentInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutParentInput | AccountUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: AccountCreateManyParentInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutParentInput | AccountUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutParentInput | AccountUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type AccountEntryUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<AccountEntryCreateWithoutAccountInput, AccountEntryUncheckedCreateWithoutAccountInput> | AccountEntryCreateWithoutAccountInput[] | AccountEntryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountEntryCreateOrConnectWithoutAccountInput | AccountEntryCreateOrConnectWithoutAccountInput[]
    upsert?: AccountEntryUpsertWithWhereUniqueWithoutAccountInput | AccountEntryUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: AccountEntryCreateManyAccountInputEnvelope
    set?: AccountEntryWhereUniqueInput | AccountEntryWhereUniqueInput[]
    disconnect?: AccountEntryWhereUniqueInput | AccountEntryWhereUniqueInput[]
    delete?: AccountEntryWhereUniqueInput | AccountEntryWhereUniqueInput[]
    connect?: AccountEntryWhereUniqueInput | AccountEntryWhereUniqueInput[]
    update?: AccountEntryUpdateWithWhereUniqueWithoutAccountInput | AccountEntryUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: AccountEntryUpdateManyWithWhereWithoutAccountInput | AccountEntryUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: AccountEntryScalarWhereInput | AccountEntryScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateOneWithoutAccountNestedInput = {
    create?: XOR<CustomerCreateWithoutAccountInput, CustomerUncheckedCreateWithoutAccountInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAccountInput
    upsert?: CustomerUpsertWithoutAccountInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutAccountInput, CustomerUpdateWithoutAccountInput>, CustomerUncheckedUpdateWithoutAccountInput>
  }

  export type VendorUncheckedUpdateOneWithoutAccountNestedInput = {
    create?: XOR<VendorCreateWithoutAccountInput, VendorUncheckedCreateWithoutAccountInput>
    connectOrCreate?: VendorCreateOrConnectWithoutAccountInput
    upsert?: VendorUpsertWithoutAccountInput
    disconnect?: VendorWhereInput | boolean
    delete?: VendorWhereInput | boolean
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutAccountInput, VendorUpdateWithoutAccountInput>, VendorUncheckedUpdateWithoutAccountInput>
  }

  export type VoucherEntryUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<VoucherEntryCreateWithoutAccountInput, VoucherEntryUncheckedCreateWithoutAccountInput> | VoucherEntryCreateWithoutAccountInput[] | VoucherEntryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: VoucherEntryCreateOrConnectWithoutAccountInput | VoucherEntryCreateOrConnectWithoutAccountInput[]
    upsert?: VoucherEntryUpsertWithWhereUniqueWithoutAccountInput | VoucherEntryUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: VoucherEntryCreateManyAccountInputEnvelope
    set?: VoucherEntryWhereUniqueInput | VoucherEntryWhereUniqueInput[]
    disconnect?: VoucherEntryWhereUniqueInput | VoucherEntryWhereUniqueInput[]
    delete?: VoucherEntryWhereUniqueInput | VoucherEntryWhereUniqueInput[]
    connect?: VoucherEntryWhereUniqueInput | VoucherEntryWhereUniqueInput[]
    update?: VoucherEntryUpdateWithWhereUniqueWithoutAccountInput | VoucherEntryUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: VoucherEntryUpdateManyWithWhereWithoutAccountInput | VoucherEntryUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: VoucherEntryScalarWhereInput | VoucherEntryScalarWhereInput[]
  }

  export type AccountEntryCreateNestedManyWithoutTransactionInput = {
    create?: XOR<AccountEntryCreateWithoutTransactionInput, AccountEntryUncheckedCreateWithoutTransactionInput> | AccountEntryCreateWithoutTransactionInput[] | AccountEntryUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: AccountEntryCreateOrConnectWithoutTransactionInput | AccountEntryCreateOrConnectWithoutTransactionInput[]
    createMany?: AccountEntryCreateManyTransactionInputEnvelope
    connect?: AccountEntryWhereUniqueInput | AccountEntryWhereUniqueInput[]
  }

  export type ServiceInvoiceCreateNestedOneWithoutTransactionInput = {
    create?: XOR<ServiceInvoiceCreateWithoutTransactionInput, ServiceInvoiceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: ServiceInvoiceCreateOrConnectWithoutTransactionInput
    connect?: ServiceInvoiceWhereUniqueInput
  }

  export type FreightInvoiceCreateNestedOneWithoutTransactionInput = {
    create?: XOR<FreightInvoiceCreateWithoutTransactionInput, FreightInvoiceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: FreightInvoiceCreateOrConnectWithoutTransactionInput
    connect?: FreightInvoiceWhereUniqueInput
  }

  export type PaymentCreateNestedOneWithoutTransactionInput = {
    create?: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutTransactionInput
    connect?: PaymentWhereUniqueInput
  }

  export type PurchaseInvoiceCreateNestedOneWithoutTransactionInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutTransactionInput, PurchaseInvoiceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutTransactionInput
    connect?: PurchaseInvoiceWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CompanyCreateWithoutTransactionsInput, CompanyUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTransactionsInput
    connect?: CompanyWhereUniqueInput
  }

  export type AccountEntryUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<AccountEntryCreateWithoutTransactionInput, AccountEntryUncheckedCreateWithoutTransactionInput> | AccountEntryCreateWithoutTransactionInput[] | AccountEntryUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: AccountEntryCreateOrConnectWithoutTransactionInput | AccountEntryCreateOrConnectWithoutTransactionInput[]
    createMany?: AccountEntryCreateManyTransactionInputEnvelope
    connect?: AccountEntryWhereUniqueInput | AccountEntryWhereUniqueInput[]
  }

  export type ServiceInvoiceUncheckedCreateNestedOneWithoutTransactionInput = {
    create?: XOR<ServiceInvoiceCreateWithoutTransactionInput, ServiceInvoiceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: ServiceInvoiceCreateOrConnectWithoutTransactionInput
    connect?: ServiceInvoiceWhereUniqueInput
  }

  export type FreightInvoiceUncheckedCreateNestedOneWithoutTransactionInput = {
    create?: XOR<FreightInvoiceCreateWithoutTransactionInput, FreightInvoiceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: FreightInvoiceCreateOrConnectWithoutTransactionInput
    connect?: FreightInvoiceWhereUniqueInput
  }

  export type PaymentUncheckedCreateNestedOneWithoutTransactionInput = {
    create?: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutTransactionInput
    connect?: PaymentWhereUniqueInput
  }

  export type PurchaseInvoiceUncheckedCreateNestedOneWithoutTransactionInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutTransactionInput, PurchaseInvoiceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutTransactionInput
    connect?: PurchaseInvoiceWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type AccountEntryUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<AccountEntryCreateWithoutTransactionInput, AccountEntryUncheckedCreateWithoutTransactionInput> | AccountEntryCreateWithoutTransactionInput[] | AccountEntryUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: AccountEntryCreateOrConnectWithoutTransactionInput | AccountEntryCreateOrConnectWithoutTransactionInput[]
    upsert?: AccountEntryUpsertWithWhereUniqueWithoutTransactionInput | AccountEntryUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: AccountEntryCreateManyTransactionInputEnvelope
    set?: AccountEntryWhereUniqueInput | AccountEntryWhereUniqueInput[]
    disconnect?: AccountEntryWhereUniqueInput | AccountEntryWhereUniqueInput[]
    delete?: AccountEntryWhereUniqueInput | AccountEntryWhereUniqueInput[]
    connect?: AccountEntryWhereUniqueInput | AccountEntryWhereUniqueInput[]
    update?: AccountEntryUpdateWithWhereUniqueWithoutTransactionInput | AccountEntryUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: AccountEntryUpdateManyWithWhereWithoutTransactionInput | AccountEntryUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: AccountEntryScalarWhereInput | AccountEntryScalarWhereInput[]
  }

  export type ServiceInvoiceUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<ServiceInvoiceCreateWithoutTransactionInput, ServiceInvoiceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: ServiceInvoiceCreateOrConnectWithoutTransactionInput
    upsert?: ServiceInvoiceUpsertWithoutTransactionInput
    disconnect?: ServiceInvoiceWhereInput | boolean
    delete?: ServiceInvoiceWhereInput | boolean
    connect?: ServiceInvoiceWhereUniqueInput
    update?: XOR<XOR<ServiceInvoiceUpdateToOneWithWhereWithoutTransactionInput, ServiceInvoiceUpdateWithoutTransactionInput>, ServiceInvoiceUncheckedUpdateWithoutTransactionInput>
  }

  export type FreightInvoiceUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<FreightInvoiceCreateWithoutTransactionInput, FreightInvoiceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: FreightInvoiceCreateOrConnectWithoutTransactionInput
    upsert?: FreightInvoiceUpsertWithoutTransactionInput
    disconnect?: FreightInvoiceWhereInput | boolean
    delete?: FreightInvoiceWhereInput | boolean
    connect?: FreightInvoiceWhereUniqueInput
    update?: XOR<XOR<FreightInvoiceUpdateToOneWithWhereWithoutTransactionInput, FreightInvoiceUpdateWithoutTransactionInput>, FreightInvoiceUncheckedUpdateWithoutTransactionInput>
  }

  export type PaymentUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutTransactionInput
    upsert?: PaymentUpsertWithoutTransactionInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutTransactionInput, PaymentUpdateWithoutTransactionInput>, PaymentUncheckedUpdateWithoutTransactionInput>
  }

  export type PurchaseInvoiceUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutTransactionInput, PurchaseInvoiceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutTransactionInput
    upsert?: PurchaseInvoiceUpsertWithoutTransactionInput
    disconnect?: PurchaseInvoiceWhereInput | boolean
    delete?: PurchaseInvoiceWhereInput | boolean
    connect?: PurchaseInvoiceWhereUniqueInput
    update?: XOR<XOR<PurchaseInvoiceUpdateToOneWithWhereWithoutTransactionInput, PurchaseInvoiceUpdateWithoutTransactionInput>, PurchaseInvoiceUncheckedUpdateWithoutTransactionInput>
  }

  export type CompanyUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<CompanyCreateWithoutTransactionsInput, CompanyUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTransactionsInput
    upsert?: CompanyUpsertWithoutTransactionsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutTransactionsInput, CompanyUpdateWithoutTransactionsInput>, CompanyUncheckedUpdateWithoutTransactionsInput>
  }

  export type AccountEntryUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<AccountEntryCreateWithoutTransactionInput, AccountEntryUncheckedCreateWithoutTransactionInput> | AccountEntryCreateWithoutTransactionInput[] | AccountEntryUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: AccountEntryCreateOrConnectWithoutTransactionInput | AccountEntryCreateOrConnectWithoutTransactionInput[]
    upsert?: AccountEntryUpsertWithWhereUniqueWithoutTransactionInput | AccountEntryUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: AccountEntryCreateManyTransactionInputEnvelope
    set?: AccountEntryWhereUniqueInput | AccountEntryWhereUniqueInput[]
    disconnect?: AccountEntryWhereUniqueInput | AccountEntryWhereUniqueInput[]
    delete?: AccountEntryWhereUniqueInput | AccountEntryWhereUniqueInput[]
    connect?: AccountEntryWhereUniqueInput | AccountEntryWhereUniqueInput[]
    update?: AccountEntryUpdateWithWhereUniqueWithoutTransactionInput | AccountEntryUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: AccountEntryUpdateManyWithWhereWithoutTransactionInput | AccountEntryUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: AccountEntryScalarWhereInput | AccountEntryScalarWhereInput[]
  }

  export type ServiceInvoiceUncheckedUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<ServiceInvoiceCreateWithoutTransactionInput, ServiceInvoiceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: ServiceInvoiceCreateOrConnectWithoutTransactionInput
    upsert?: ServiceInvoiceUpsertWithoutTransactionInput
    disconnect?: ServiceInvoiceWhereInput | boolean
    delete?: ServiceInvoiceWhereInput | boolean
    connect?: ServiceInvoiceWhereUniqueInput
    update?: XOR<XOR<ServiceInvoiceUpdateToOneWithWhereWithoutTransactionInput, ServiceInvoiceUpdateWithoutTransactionInput>, ServiceInvoiceUncheckedUpdateWithoutTransactionInput>
  }

  export type FreightInvoiceUncheckedUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<FreightInvoiceCreateWithoutTransactionInput, FreightInvoiceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: FreightInvoiceCreateOrConnectWithoutTransactionInput
    upsert?: FreightInvoiceUpsertWithoutTransactionInput
    disconnect?: FreightInvoiceWhereInput | boolean
    delete?: FreightInvoiceWhereInput | boolean
    connect?: FreightInvoiceWhereUniqueInput
    update?: XOR<XOR<FreightInvoiceUpdateToOneWithWhereWithoutTransactionInput, FreightInvoiceUpdateWithoutTransactionInput>, FreightInvoiceUncheckedUpdateWithoutTransactionInput>
  }

  export type PaymentUncheckedUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutTransactionInput
    upsert?: PaymentUpsertWithoutTransactionInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutTransactionInput, PaymentUpdateWithoutTransactionInput>, PaymentUncheckedUpdateWithoutTransactionInput>
  }

  export type PurchaseInvoiceUncheckedUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutTransactionInput, PurchaseInvoiceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutTransactionInput
    upsert?: PurchaseInvoiceUpsertWithoutTransactionInput
    disconnect?: PurchaseInvoiceWhereInput | boolean
    delete?: PurchaseInvoiceWhereInput | boolean
    connect?: PurchaseInvoiceWhereUniqueInput
    update?: XOR<XOR<PurchaseInvoiceUpdateToOneWithWhereWithoutTransactionInput, PurchaseInvoiceUpdateWithoutTransactionInput>, PurchaseInvoiceUncheckedUpdateWithoutTransactionInput>
  }

  export type AccountCreateNestedOneWithoutEntriesInput = {
    create?: XOR<AccountCreateWithoutEntriesInput, AccountUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutEntriesInput
    connect?: AccountWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutEntriesInput = {
    create?: XOR<TransactionCreateWithoutEntriesInput, TransactionUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutEntriesInput
    connect?: TransactionWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutEntriesNestedInput = {
    create?: XOR<AccountCreateWithoutEntriesInput, AccountUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutEntriesInput
    upsert?: AccountUpsertWithoutEntriesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutEntriesInput, AccountUpdateWithoutEntriesInput>, AccountUncheckedUpdateWithoutEntriesInput>
  }

  export type TransactionUpdateOneRequiredWithoutEntriesNestedInput = {
    create?: XOR<TransactionCreateWithoutEntriesInput, TransactionUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutEntriesInput
    upsert?: TransactionUpsertWithoutEntriesInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutEntriesInput, TransactionUpdateWithoutEntriesInput>, TransactionUncheckedUpdateWithoutEntriesInput>
  }

  export type CompanyCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<CompanyCreateWithoutPaymentsInput, CompanyUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPaymentsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<CustomerCreateWithoutPaymentsInput, CustomerUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPaymentsInput
    connect?: CustomerWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutPaymentInput = {
    create?: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentInput
    connect?: TransactionWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<VendorCreateWithoutPaymentsInput, VendorUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPaymentsInput
    connect?: VendorWhereUniqueInput
  }

  export type EnumPaymentModeFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMode
  }

  export type CompanyUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<CompanyCreateWithoutPaymentsInput, CompanyUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPaymentsInput
    upsert?: CompanyUpsertWithoutPaymentsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPaymentsInput, CompanyUpdateWithoutPaymentsInput>, CompanyUncheckedUpdateWithoutPaymentsInput>
  }

  export type CustomerUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<CustomerCreateWithoutPaymentsInput, CustomerUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPaymentsInput
    upsert?: CustomerUpsertWithoutPaymentsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutPaymentsInput, CustomerUpdateWithoutPaymentsInput>, CustomerUncheckedUpdateWithoutPaymentsInput>
  }

  export type TransactionUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentInput
    upsert?: TransactionUpsertWithoutPaymentInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutPaymentInput, TransactionUpdateWithoutPaymentInput>, TransactionUncheckedUpdateWithoutPaymentInput>
  }

  export type VendorUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<VendorCreateWithoutPaymentsInput, VendorUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPaymentsInput
    upsert?: VendorUpsertWithoutPaymentsInput
    disconnect?: VendorWhereInput | boolean
    delete?: VendorWhereInput | boolean
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutPaymentsInput, VendorUpdateWithoutPaymentsInput>, VendorUncheckedUpdateWithoutPaymentsInput>
  }

  export type CompanyCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAuditLogsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAuditLogsInput
    upsert?: CompanyUpsertWithoutAuditLogsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAuditLogsInput, CompanyUpdateWithoutAuditLogsInput>, CompanyUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type CompanyCreateNestedOneWithoutFinancialPeriodsInput = {
    create?: XOR<CompanyCreateWithoutFinancialPeriodsInput, CompanyUncheckedCreateWithoutFinancialPeriodsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutFinancialPeriodsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutFinancialPeriodsNestedInput = {
    create?: XOR<CompanyCreateWithoutFinancialPeriodsInput, CompanyUncheckedCreateWithoutFinancialPeriodsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutFinancialPeriodsInput
    upsert?: CompanyUpsertWithoutFinancialPeriodsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutFinancialPeriodsInput, CompanyUpdateWithoutFinancialPeriodsInput>, CompanyUncheckedUpdateWithoutFinancialPeriodsInput>
  }

  export type JobCreateNestedManyWithoutPodInput = {
    create?: XOR<JobCreateWithoutPodInput, JobUncheckedCreateWithoutPodInput> | JobCreateWithoutPodInput[] | JobUncheckedCreateWithoutPodInput[]
    connectOrCreate?: JobCreateOrConnectWithoutPodInput | JobCreateOrConnectWithoutPodInput[]
    createMany?: JobCreateManyPodInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutPortsInput = {
    create?: XOR<CompanyCreateWithoutPortsInput, CompanyUncheckedCreateWithoutPortsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPortsInput
    connect?: CompanyWhereUniqueInput
  }

  export type JobUncheckedCreateNestedManyWithoutPodInput = {
    create?: XOR<JobCreateWithoutPodInput, JobUncheckedCreateWithoutPodInput> | JobCreateWithoutPodInput[] | JobUncheckedCreateWithoutPodInput[]
    connectOrCreate?: JobCreateOrConnectWithoutPodInput | JobCreateOrConnectWithoutPodInput[]
    createMany?: JobCreateManyPodInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type JobUpdateManyWithoutPodNestedInput = {
    create?: XOR<JobCreateWithoutPodInput, JobUncheckedCreateWithoutPodInput> | JobCreateWithoutPodInput[] | JobUncheckedCreateWithoutPodInput[]
    connectOrCreate?: JobCreateOrConnectWithoutPodInput | JobCreateOrConnectWithoutPodInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutPodInput | JobUpsertWithWhereUniqueWithoutPodInput[]
    createMany?: JobCreateManyPodInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutPodInput | JobUpdateWithWhereUniqueWithoutPodInput[]
    updateMany?: JobUpdateManyWithWhereWithoutPodInput | JobUpdateManyWithWhereWithoutPodInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutPortsNestedInput = {
    create?: XOR<CompanyCreateWithoutPortsInput, CompanyUncheckedCreateWithoutPortsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPortsInput
    upsert?: CompanyUpsertWithoutPortsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPortsInput, CompanyUpdateWithoutPortsInput>, CompanyUncheckedUpdateWithoutPortsInput>
  }

  export type JobUncheckedUpdateManyWithoutPodNestedInput = {
    create?: XOR<JobCreateWithoutPodInput, JobUncheckedCreateWithoutPodInput> | JobCreateWithoutPodInput[] | JobUncheckedCreateWithoutPodInput[]
    connectOrCreate?: JobCreateOrConnectWithoutPodInput | JobCreateOrConnectWithoutPodInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutPodInput | JobUpsertWithWhereUniqueWithoutPodInput[]
    createMany?: JobCreateManyPodInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutPodInput | JobUpdateWithWhereUniqueWithoutPodInput[]
    updateMany?: JobUpdateManyWithWhereWithoutPodInput | JobUpdateManyWithWhereWithoutPodInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutVouchersInput = {
    create?: XOR<CompanyCreateWithoutVouchersInput, CompanyUncheckedCreateWithoutVouchersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutVouchersInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPostedVouchersInput = {
    create?: XOR<UserCreateWithoutPostedVouchersInput, UserUncheckedCreateWithoutPostedVouchersInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostedVouchersInput
    connect?: UserWhereUniqueInput
  }

  export type VoucherEntryCreateNestedManyWithoutVoucherInput = {
    create?: XOR<VoucherEntryCreateWithoutVoucherInput, VoucherEntryUncheckedCreateWithoutVoucherInput> | VoucherEntryCreateWithoutVoucherInput[] | VoucherEntryUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherEntryCreateOrConnectWithoutVoucherInput | VoucherEntryCreateOrConnectWithoutVoucherInput[]
    createMany?: VoucherEntryCreateManyVoucherInputEnvelope
    connect?: VoucherEntryWhereUniqueInput | VoucherEntryWhereUniqueInput[]
  }

  export type VoucherEntryUncheckedCreateNestedManyWithoutVoucherInput = {
    create?: XOR<VoucherEntryCreateWithoutVoucherInput, VoucherEntryUncheckedCreateWithoutVoucherInput> | VoucherEntryCreateWithoutVoucherInput[] | VoucherEntryUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherEntryCreateOrConnectWithoutVoucherInput | VoucherEntryCreateOrConnectWithoutVoucherInput[]
    createMany?: VoucherEntryCreateManyVoucherInputEnvelope
    connect?: VoucherEntryWhereUniqueInput | VoucherEntryWhereUniqueInput[]
  }

  export type EnumVoucherTypeFieldUpdateOperationsInput = {
    set?: $Enums.VoucherType
  }

  export type EnumVoucherStatusFieldUpdateOperationsInput = {
    set?: $Enums.VoucherStatus
  }

  export type NullableEnumPaymentModeFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMode | null
  }

  export type CompanyUpdateOneRequiredWithoutVouchersNestedInput = {
    create?: XOR<CompanyCreateWithoutVouchersInput, CompanyUncheckedCreateWithoutVouchersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutVouchersInput
    upsert?: CompanyUpsertWithoutVouchersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutVouchersInput, CompanyUpdateWithoutVouchersInput>, CompanyUncheckedUpdateWithoutVouchersInput>
  }

  export type UserUpdateOneWithoutPostedVouchersNestedInput = {
    create?: XOR<UserCreateWithoutPostedVouchersInput, UserUncheckedCreateWithoutPostedVouchersInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostedVouchersInput
    upsert?: UserUpsertWithoutPostedVouchersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostedVouchersInput, UserUpdateWithoutPostedVouchersInput>, UserUncheckedUpdateWithoutPostedVouchersInput>
  }

  export type VoucherEntryUpdateManyWithoutVoucherNestedInput = {
    create?: XOR<VoucherEntryCreateWithoutVoucherInput, VoucherEntryUncheckedCreateWithoutVoucherInput> | VoucherEntryCreateWithoutVoucherInput[] | VoucherEntryUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherEntryCreateOrConnectWithoutVoucherInput | VoucherEntryCreateOrConnectWithoutVoucherInput[]
    upsert?: VoucherEntryUpsertWithWhereUniqueWithoutVoucherInput | VoucherEntryUpsertWithWhereUniqueWithoutVoucherInput[]
    createMany?: VoucherEntryCreateManyVoucherInputEnvelope
    set?: VoucherEntryWhereUniqueInput | VoucherEntryWhereUniqueInput[]
    disconnect?: VoucherEntryWhereUniqueInput | VoucherEntryWhereUniqueInput[]
    delete?: VoucherEntryWhereUniqueInput | VoucherEntryWhereUniqueInput[]
    connect?: VoucherEntryWhereUniqueInput | VoucherEntryWhereUniqueInput[]
    update?: VoucherEntryUpdateWithWhereUniqueWithoutVoucherInput | VoucherEntryUpdateWithWhereUniqueWithoutVoucherInput[]
    updateMany?: VoucherEntryUpdateManyWithWhereWithoutVoucherInput | VoucherEntryUpdateManyWithWhereWithoutVoucherInput[]
    deleteMany?: VoucherEntryScalarWhereInput | VoucherEntryScalarWhereInput[]
  }

  export type VoucherEntryUncheckedUpdateManyWithoutVoucherNestedInput = {
    create?: XOR<VoucherEntryCreateWithoutVoucherInput, VoucherEntryUncheckedCreateWithoutVoucherInput> | VoucherEntryCreateWithoutVoucherInput[] | VoucherEntryUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherEntryCreateOrConnectWithoutVoucherInput | VoucherEntryCreateOrConnectWithoutVoucherInput[]
    upsert?: VoucherEntryUpsertWithWhereUniqueWithoutVoucherInput | VoucherEntryUpsertWithWhereUniqueWithoutVoucherInput[]
    createMany?: VoucherEntryCreateManyVoucherInputEnvelope
    set?: VoucherEntryWhereUniqueInput | VoucherEntryWhereUniqueInput[]
    disconnect?: VoucherEntryWhereUniqueInput | VoucherEntryWhereUniqueInput[]
    delete?: VoucherEntryWhereUniqueInput | VoucherEntryWhereUniqueInput[]
    connect?: VoucherEntryWhereUniqueInput | VoucherEntryWhereUniqueInput[]
    update?: VoucherEntryUpdateWithWhereUniqueWithoutVoucherInput | VoucherEntryUpdateWithWhereUniqueWithoutVoucherInput[]
    updateMany?: VoucherEntryUpdateManyWithWhereWithoutVoucherInput | VoucherEntryUpdateManyWithWhereWithoutVoucherInput[]
    deleteMany?: VoucherEntryScalarWhereInput | VoucherEntryScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutVoucherEntriesInput = {
    create?: XOR<AccountCreateWithoutVoucherEntriesInput, AccountUncheckedCreateWithoutVoucherEntriesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutVoucherEntriesInput
    connect?: AccountWhereUniqueInput
  }

  export type VoucherCreateNestedOneWithoutEntriesInput = {
    create?: XOR<VoucherCreateWithoutEntriesInput, VoucherUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: VoucherCreateOrConnectWithoutEntriesInput
    connect?: VoucherWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutVoucherEntriesNestedInput = {
    create?: XOR<AccountCreateWithoutVoucherEntriesInput, AccountUncheckedCreateWithoutVoucherEntriesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutVoucherEntriesInput
    upsert?: AccountUpsertWithoutVoucherEntriesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutVoucherEntriesInput, AccountUpdateWithoutVoucherEntriesInput>, AccountUncheckedUpdateWithoutVoucherEntriesInput>
  }

  export type VoucherUpdateOneRequiredWithoutEntriesNestedInput = {
    create?: XOR<VoucherCreateWithoutEntriesInput, VoucherUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: VoucherCreateOrConnectWithoutEntriesInput
    upsert?: VoucherUpsertWithoutEntriesInput
    connect?: VoucherWhereUniqueInput
    update?: XOR<XOR<VoucherUpdateToOneWithWhereWithoutEntriesInput, VoucherUpdateWithoutEntriesInput>, VoucherUncheckedUpdateWithoutEntriesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumJobTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobTypeFilter<$PrismaModel> | $Enums.JobType
  }

  export type NestedEnumJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusFilter<$PrismaModel> | $Enums.JobStatus
  }

  export type NestedEnumJobTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobTypeWithAggregatesFilter<$PrismaModel> | $Enums.JobType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobTypeFilter<$PrismaModel>
    _max?: NestedEnumJobTypeFilter<$PrismaModel>
  }

  export type NestedEnumJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobStatusFilter<$PrismaModel>
    _max?: NestedEnumJobStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeFilter<$PrismaModel> | $Enums.InvoiceType
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceTypeFilter<$PrismaModel>
    _max?: NestedEnumInvoiceTypeFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentModeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentModeFilter<$PrismaModel> | $Enums.PaymentMode
  }

  export type NestedEnumPaymentModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentModeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentModeFilter<$PrismaModel>
    _max?: NestedEnumPaymentModeFilter<$PrismaModel>
  }

  export type NestedEnumVoucherTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherType | EnumVoucherTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoucherTypeFilter<$PrismaModel> | $Enums.VoucherType
  }

  export type NestedEnumVoucherStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherStatus | EnumVoucherStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherStatus[] | ListEnumVoucherStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoucherStatus[] | ListEnumVoucherStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVoucherStatusFilter<$PrismaModel> | $Enums.VoucherStatus
  }

  export type NestedEnumPaymentModeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentModeNullableFilter<$PrismaModel> | $Enums.PaymentMode | null
  }

  export type NestedEnumVoucherTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherType | EnumVoucherTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoucherTypeWithAggregatesFilter<$PrismaModel> | $Enums.VoucherType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoucherTypeFilter<$PrismaModel>
    _max?: NestedEnumVoucherTypeFilter<$PrismaModel>
  }

  export type NestedEnumVoucherStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherStatus | EnumVoucherStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherStatus[] | ListEnumVoucherStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoucherStatus[] | ListEnumVoucherStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVoucherStatusWithAggregatesFilter<$PrismaModel> | $Enums.VoucherStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoucherStatusFilter<$PrismaModel>
    _max?: NestedEnumVoucherStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentModeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentModeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMode | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentModeNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentModeNullableFilter<$PrismaModel>
  }

  export type AccountCreateWithoutCompanyInput = {
    code: string
    name: string
    type: $Enums.AccountType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    parent?: AccountCreateNestedOneWithoutChildrenInput
    children?: AccountCreateNestedManyWithoutParentInput
    entries?: AccountEntryCreateNestedManyWithoutAccountInput
    customer?: CustomerCreateNestedOneWithoutAccountInput
    vendor?: VendorCreateNestedOneWithoutAccountInput
    voucherEntries?: VoucherEntryCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutCompanyInput = {
    id?: number
    code: string
    name: string
    type: $Enums.AccountType
    description?: string | null
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    children?: AccountUncheckedCreateNestedManyWithoutParentInput
    entries?: AccountEntryUncheckedCreateNestedManyWithoutAccountInput
    customer?: CustomerUncheckedCreateNestedOneWithoutAccountInput
    vendor?: VendorUncheckedCreateNestedOneWithoutAccountInput
    voucherEntries?: VoucherEntryUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutCompanyInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutCompanyInput, AccountUncheckedCreateWithoutCompanyInput>
  }

  export type AccountCreateManyCompanyInputEnvelope = {
    data: AccountCreateManyCompanyInput | AccountCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutCompanyInput = {
    action: string
    module: string
    entityId?: number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutCompanyInput = {
    id?: number
    userId: number
    action: string
    module: string
    entityId?: number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutCompanyInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput>
  }

  export type AuditLogCreateManyCompanyInputEnvelope = {
    data: AuditLogCreateManyCompanyInput | AuditLogCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type BranchCreateWithoutCompanyInput = {
    name: string
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobCreateNestedManyWithoutBranchInput
    taxSettings?: TaxSettingCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutCompanyInput = {
    id?: number
    name: string
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutBranchInput
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutCompanyInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutCompanyInput, BranchUncheckedCreateWithoutCompanyInput>
  }

  export type BranchCreateManyCompanyInputEnvelope = {
    data: BranchCreateManyCompanyInput | BranchCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCurrencyCreateWithoutCompanyInput = {
    exchangeRate?: number
    isDefault?: boolean
    currency: CurrencyCreateNestedOneWithoutCompaniesInput
  }

  export type CompanyCurrencyUncheckedCreateWithoutCompanyInput = {
    id?: number
    currencyId: number
    exchangeRate?: number
    isDefault?: boolean
  }

  export type CompanyCurrencyCreateOrConnectWithoutCompanyInput = {
    where: CompanyCurrencyWhereUniqueInput
    create: XOR<CompanyCurrencyCreateWithoutCompanyInput, CompanyCurrencyUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyCurrencyCreateManyCompanyInputEnvelope = {
    data: CompanyCurrencyCreateManyCompanyInput | CompanyCurrencyCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutCompanyInput = {
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    account?: AccountCreateNestedOneWithoutCustomerInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCustomerInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCustomerInput
    jobs?: JobCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCompanyInput = {
    id?: number
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    accountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    jobs?: JobUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCompanyInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCompanyInput, CustomerUncheckedCreateWithoutCompanyInput>
  }

  export type CustomerCreateManyCompanyInputEnvelope = {
    data: CustomerCreateManyCompanyInput | CustomerCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCreateWithoutCompanyInput = {
    description: string
    costPrice?: number
    sellingPrice?: number
    currencyCode?: string
    exchangeRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    job: JobCreateNestedOneWithoutExpensesInput
    vendor?: VendorCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutCompanyInput = {
    id?: number
    jobId: number
    vendorId?: number | null
    description: string
    costPrice?: number
    sellingPrice?: number
    currencyCode?: string
    exchangeRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutCompanyInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutCompanyInput, ExpenseUncheckedCreateWithoutCompanyInput>
  }

  export type ExpenseCreateManyCompanyInputEnvelope = {
    data: ExpenseCreateManyCompanyInput | ExpenseCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseMasterCreateWithoutCompanyInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseMasterUncheckedCreateWithoutCompanyInput = {
    id?: number
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseMasterCreateOrConnectWithoutCompanyInput = {
    where: ExpenseMasterWhereUniqueInput
    create: XOR<ExpenseMasterCreateWithoutCompanyInput, ExpenseMasterUncheckedCreateWithoutCompanyInput>
  }

  export type ExpenseMasterCreateManyCompanyInputEnvelope = {
    data: ExpenseMasterCreateManyCompanyInput | ExpenseMasterCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type FinancialPeriodCreateWithoutCompanyInput = {
    month: number
    year: number
    isClosed?: boolean
    closedById?: number | null
    closedAt?: Date | string | null
  }

  export type FinancialPeriodUncheckedCreateWithoutCompanyInput = {
    id?: number
    month: number
    year: number
    isClosed?: boolean
    closedById?: number | null
    closedAt?: Date | string | null
  }

  export type FinancialPeriodCreateOrConnectWithoutCompanyInput = {
    where: FinancialPeriodWhereUniqueInput
    create: XOR<FinancialPeriodCreateWithoutCompanyInput, FinancialPeriodUncheckedCreateWithoutCompanyInput>
  }

  export type FinancialPeriodCreateManyCompanyInputEnvelope = {
    data: FinancialPeriodCreateManyCompanyInput | FinancialPeriodCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ServiceInvoiceCreateWithoutCompanyInput = {
    invoiceNumber: string
    date?: Date | string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    masterNumber?: string | null
    agentCode?: string | null
    shippingLine?: string | null
    origin?: string | null
    destination?: string | null
    creditDays?: number | null
    vendorType?: string | null
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    exchangeRate?: number
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    customer: CustomerCreateNestedOneWithoutServiceInvoicesInput
    job: JobCreateNestedOneWithoutServiceInvoiceInput
    transaction?: TransactionCreateNestedOneWithoutServiceInput
    items?: ServiceInvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type ServiceInvoiceUncheckedCreateWithoutCompanyInput = {
    id?: number
    invoiceNumber: string
    date?: Date | string
    jobId: number
    customerId: number
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    masterNumber?: string | null
    agentCode?: string | null
    shippingLine?: string | null
    origin?: string | null
    destination?: string | null
    creditDays?: number | null
    vendorType?: string | null
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    exchangeRate?: number
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId?: number | null
    division?: string | null
    items?: ServiceInvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type ServiceInvoiceCreateOrConnectWithoutCompanyInput = {
    where: ServiceInvoiceWhereUniqueInput
    create: XOR<ServiceInvoiceCreateWithoutCompanyInput, ServiceInvoiceUncheckedCreateWithoutCompanyInput>
  }

  export type ServiceInvoiceCreateManyCompanyInputEnvelope = {
    data: ServiceInvoiceCreateManyCompanyInput | ServiceInvoiceCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type FreightInvoiceCreateWithoutCompanyInput = {
    invoiceNumber: string
    date?: Date | string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    usdRate?: number
    exchangeRate?: number
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    customer: CustomerCreateNestedOneWithoutFreightInvoicesInput
    transaction?: TransactionCreateNestedOneWithoutFreightInput
    job?: JobCreateNestedOneWithoutFreightInvoiceInput
    items?: FreightInvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type FreightInvoiceUncheckedCreateWithoutCompanyInput = {
    id?: number
    invoiceNumber: string
    date?: Date | string
    jobId?: number | null
    customerId: number
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    usdRate?: number
    exchangeRate?: number
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId?: number | null
    division?: string | null
    items?: FreightInvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type FreightInvoiceCreateOrConnectWithoutCompanyInput = {
    where: FreightInvoiceWhereUniqueInput
    create: XOR<FreightInvoiceCreateWithoutCompanyInput, FreightInvoiceUncheckedCreateWithoutCompanyInput>
  }

  export type FreightInvoiceCreateManyCompanyInputEnvelope = {
    data: FreightInvoiceCreateManyCompanyInput | FreightInvoiceCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type JobCreateWithoutCompanyInput = {
    jobNumber: string
    date?: Date | string
    jobDate?: Date | string
    jobType?: $Enums.JobType
    status?: $Enums.JobStatus
    vessel?: string | null
    place?: string | null
    shipperRef?: string | null
    gdNo?: string | null
    gdDate?: Date | string | null
    formE?: string | null
    formEDate?: Date | string | null
    commodity?: string | null
    volume?: string | null
    containerNo?: string | null
    packages?: number | null
    weight?: number | null
    hawbBl?: string | null
    handledBy?: string | null
    salesPerson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    division?: string | null
    expenses?: ExpenseCreateNestedManyWithoutJobInput
    serviceInvoice?: ServiceInvoiceCreateNestedOneWithoutJobInput
    freightInvoice?: FreightInvoiceCreateNestedOneWithoutJobInput
    branch?: BranchCreateNestedOneWithoutJobsInput
    customer: CustomerCreateNestedOneWithoutJobsInput
    pod?: PortCreateNestedOneWithoutJobsInput
  }

  export type JobUncheckedCreateWithoutCompanyInput = {
    id?: number
    jobNumber: string
    date?: Date | string
    jobDate?: Date | string
    jobType?: $Enums.JobType
    status?: $Enums.JobStatus
    customerId: number
    vessel?: string | null
    place?: string | null
    shipperRef?: string | null
    gdNo?: string | null
    gdDate?: Date | string | null
    formE?: string | null
    formEDate?: Date | string | null
    commodity?: string | null
    volume?: string | null
    containerNo?: string | null
    podId?: number | null
    packages?: number | null
    weight?: number | null
    hawbBl?: string | null
    handledBy?: string | null
    salesPerson?: string | null
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    division?: string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutJobInput
    serviceInvoice?: ServiceInvoiceUncheckedCreateNestedOneWithoutJobInput
    freightInvoice?: FreightInvoiceUncheckedCreateNestedOneWithoutJobInput
  }

  export type JobCreateOrConnectWithoutCompanyInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutCompanyInput, JobUncheckedCreateWithoutCompanyInput>
  }

  export type JobCreateManyCompanyInputEnvelope = {
    data: JobCreateManyCompanyInput | JobCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutCompanyInput = {
    receiptNumber: string
    date?: Date | string
    amount: number
    mode?: $Enums.PaymentMode
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    customer?: CustomerCreateNestedOneWithoutPaymentsInput
    transaction: TransactionCreateNestedOneWithoutPaymentInput
    vendor?: VendorCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutCompanyInput = {
    id?: number
    receiptNumber: string
    date?: Date | string
    amount: number
    mode?: $Enums.PaymentMode
    reference?: string | null
    customerId?: number | null
    vendorId?: number | null
    transactionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
  }

  export type PaymentCreateOrConnectWithoutCompanyInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutCompanyInput, PaymentUncheckedCreateWithoutCompanyInput>
  }

  export type PaymentCreateManyCompanyInputEnvelope = {
    data: PaymentCreateManyCompanyInput | PaymentCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PortCreateWithoutCompanyInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobCreateNestedManyWithoutPodInput
  }

  export type PortUncheckedCreateWithoutCompanyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutPodInput
  }

  export type PortCreateOrConnectWithoutCompanyInput = {
    where: PortWhereUniqueInput
    create: XOR<PortCreateWithoutCompanyInput, PortUncheckedCreateWithoutCompanyInput>
  }

  export type PortCreateManyCompanyInputEnvelope = {
    data: PortCreateManyCompanyInput | PortCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutCompanyInput = {
    sku?: string | null
    name: string
    description?: string | null
    unit?: string
    purchasePrice?: number
    sellingPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    serviceItems?: ServiceInvoiceItemCreateNestedManyWithoutProductInput
    category: ProductCategoryCreateNestedOneWithoutProductsInput
    purchaseItems?: PurchaseInvoiceItemCreateNestedManyWithoutProductInput
    movements?: StockMovementCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCompanyInput = {
    id?: number
    sku?: string | null
    name: string
    description?: string | null
    unit?: string
    purchasePrice?: number
    sellingPrice?: number
    categoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    serviceItems?: ServiceInvoiceItemUncheckedCreateNestedManyWithoutProductInput
    purchaseItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutProductInput
    movements?: StockMovementUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCompanyInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCompanyInput, ProductUncheckedCreateWithoutCompanyInput>
  }

  export type ProductCreateManyCompanyInputEnvelope = {
    data: ProductCreateManyCompanyInput | ProductCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ProductCategoryCreateWithoutCompanyInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutCompanyInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutCompanyInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutCompanyInput, ProductCategoryUncheckedCreateWithoutCompanyInput>
  }

  export type ProductCategoryCreateManyCompanyInputEnvelope = {
    data: ProductCategoryCreateManyCompanyInput | ProductCategoryCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseInvoiceCreateWithoutCompanyInput = {
    purchaseNumber: string
    date?: Date | string
    status?: $Enums.InvoiceStatus
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    transaction?: TransactionCreateNestedOneWithoutPurchaseInput
    vendor: VendorCreateNestedOneWithoutPurchaseInvoicesInput
    items?: PurchaseInvoiceItemCreateNestedManyWithoutPurchaseInvoiceInput
  }

  export type PurchaseInvoiceUncheckedCreateWithoutCompanyInput = {
    id?: number
    purchaseNumber: string
    date?: Date | string
    vendorId: number
    status?: $Enums.InvoiceStatus
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    transactionId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutPurchaseInvoiceInput
  }

  export type PurchaseInvoiceCreateOrConnectWithoutCompanyInput = {
    where: PurchaseInvoiceWhereUniqueInput
    create: XOR<PurchaseInvoiceCreateWithoutCompanyInput, PurchaseInvoiceUncheckedCreateWithoutCompanyInput>
  }

  export type PurchaseInvoiceCreateManyCompanyInputEnvelope = {
    data: PurchaseInvoiceCreateManyCompanyInput | PurchaseInvoiceCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type StockMovementCreateWithoutCompanyInput = {
    quantity: number
    type: string
    reference?: string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutMovementsInput
    warehouse?: WarehouseCreateNestedOneWithoutStockMovementsInput
  }

  export type StockMovementUncheckedCreateWithoutCompanyInput = {
    id?: number
    productId: number
    warehouseId?: number | null
    quantity: number
    type: string
    reference?: string | null
    createdAt?: Date | string
  }

  export type StockMovementCreateOrConnectWithoutCompanyInput = {
    where: StockMovementWhereUniqueInput
    create: XOR<StockMovementCreateWithoutCompanyInput, StockMovementUncheckedCreateWithoutCompanyInput>
  }

  export type StockMovementCreateManyCompanyInputEnvelope = {
    data: StockMovementCreateManyCompanyInput | StockMovementCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type SystemSettingCreateWithoutCompanyInput = {
    key: string
    value: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUncheckedCreateWithoutCompanyInput = {
    id?: number
    key: string
    value: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingCreateOrConnectWithoutCompanyInput = {
    where: SystemSettingWhereUniqueInput
    create: XOR<SystemSettingCreateWithoutCompanyInput, SystemSettingUncheckedCreateWithoutCompanyInput>
  }

  export type SystemSettingCreateManyCompanyInputEnvelope = {
    data: SystemSettingCreateManyCompanyInput | SystemSettingCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type TaxSettingCreateWithoutCompanyInput = {
    name: string
    percentage: number
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutTaxSettingsInput
  }

  export type TaxSettingUncheckedCreateWithoutCompanyInput = {
    id?: number
    name: string
    percentage: number
    type: string
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxSettingCreateOrConnectWithoutCompanyInput = {
    where: TaxSettingWhereUniqueInput
    create: XOR<TaxSettingCreateWithoutCompanyInput, TaxSettingUncheckedCreateWithoutCompanyInput>
  }

  export type TaxSettingCreateManyCompanyInputEnvelope = {
    data: TaxSettingCreateManyCompanyInput | TaxSettingCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutCompanyInput = {
    reference: string
    date?: Date | string
    description?: string | null
    type?: $Enums.TransactionType
    createdAt?: Date | string
    updatedAt?: Date | string
    isLocked?: boolean
    entries?: AccountEntryCreateNestedManyWithoutTransactionInput
    service?: ServiceInvoiceCreateNestedOneWithoutTransactionInput
    freight?: FreightInvoiceCreateNestedOneWithoutTransactionInput
    payment?: PaymentCreateNestedOneWithoutTransactionInput
    purchase?: PurchaseInvoiceCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutCompanyInput = {
    id?: number
    reference: string
    date?: Date | string
    description?: string | null
    type?: $Enums.TransactionType
    createdAt?: Date | string
    updatedAt?: Date | string
    isLocked?: boolean
    entries?: AccountEntryUncheckedCreateNestedManyWithoutTransactionInput
    service?: ServiceInvoiceUncheckedCreateNestedOneWithoutTransactionInput
    freight?: FreightInvoiceUncheckedCreateNestedOneWithoutTransactionInput
    payment?: PaymentUncheckedCreateNestedOneWithoutTransactionInput
    purchase?: PurchaseInvoiceUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutCompanyInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCompanyInput, TransactionUncheckedCreateWithoutCompanyInput>
  }

  export type TransactionCreateManyCompanyInputEnvelope = {
    data: TransactionCreateManyCompanyInput | TransactionCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCompanyInput = {
    email: string
    name?: string | null
    password: string
    role?: $Enums.Role
    branch?: string | null
    department?: string | null
    region?: string | null
    division?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    postedVouchers?: VoucherCreateNestedManyWithoutPostedByInput
  }

  export type UserUncheckedCreateWithoutCompanyInput = {
    id?: number
    email: string
    name?: string | null
    password: string
    role?: $Enums.Role
    branch?: string | null
    department?: string | null
    region?: string | null
    division?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    postedVouchers?: VoucherUncheckedCreateNestedManyWithoutPostedByInput
  }

  export type UserCreateOrConnectWithoutCompanyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserCreateManyCompanyInputEnvelope = {
    data: UserCreateManyCompanyInput | UserCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type VendorCreateWithoutCompanyInput = {
    name: string
    code: string
    type?: string | null
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    expenses?: ExpenseCreateNestedManyWithoutVendorInput
    payments?: PaymentCreateNestedManyWithoutVendorInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutVendorInput
    account?: AccountCreateNestedOneWithoutVendorInput
    freightItems?: FreightInvoiceItemCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutCompanyInput = {
    id?: number
    name: string
    code: string
    type?: string | null
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    accountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutVendorInput
    payments?: PaymentUncheckedCreateNestedManyWithoutVendorInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutVendorInput
    freightItems?: FreightInvoiceItemUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutCompanyInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutCompanyInput, VendorUncheckedCreateWithoutCompanyInput>
  }

  export type VendorCreateManyCompanyInputEnvelope = {
    data: VendorCreateManyCompanyInput | VendorCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type VoucherCreateWithoutCompanyInput = {
    voucherNumber: string
    voucherType: $Enums.VoucherType
    status?: $Enums.VoucherStatus
    date?: Date | string
    postingDate?: Date | string | null
    paymentMode?: $Enums.PaymentMode | null
    instrumentNo?: string | null
    instrumentDate?: Date | string | null
    bankName?: string | null
    narration?: string | null
    division?: string | null
    isPosted?: boolean
    postedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postedBy?: UserCreateNestedOneWithoutPostedVouchersInput
    entries?: VoucherEntryCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUncheckedCreateWithoutCompanyInput = {
    id?: number
    voucherNumber: string
    voucherType: $Enums.VoucherType
    status?: $Enums.VoucherStatus
    date?: Date | string
    postingDate?: Date | string | null
    paymentMode?: $Enums.PaymentMode | null
    instrumentNo?: string | null
    instrumentDate?: Date | string | null
    bankName?: string | null
    narration?: string | null
    division?: string | null
    isPosted?: boolean
    postedAt?: Date | string | null
    postedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    entries?: VoucherEntryUncheckedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherCreateOrConnectWithoutCompanyInput = {
    where: VoucherWhereUniqueInput
    create: XOR<VoucherCreateWithoutCompanyInput, VoucherUncheckedCreateWithoutCompanyInput>
  }

  export type VoucherCreateManyCompanyInputEnvelope = {
    data: VoucherCreateManyCompanyInput | VoucherCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseCreateWithoutCompanyInput = {
    name: string
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stockMovements?: StockMovementCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutCompanyInput = {
    id?: number
    name: string
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutCompanyInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutCompanyInput, WarehouseUncheckedCreateWithoutCompanyInput>
  }

  export type WarehouseCreateManyCompanyInputEnvelope = {
    data: WarehouseCreateManyCompanyInput | WarehouseCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutCompanyInput, AccountUncheckedUpdateWithoutCompanyInput>
    create: XOR<AccountCreateWithoutCompanyInput, AccountUncheckedCreateWithoutCompanyInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutCompanyInput, AccountUncheckedUpdateWithoutCompanyInput>
  }

  export type AccountUpdateManyWithWhereWithoutCompanyInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutCompanyInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: IntFilter<"Account"> | number
    code?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    type?: EnumAccountTypeFilter<"Account"> | $Enums.AccountType
    description?: StringNullableFilter<"Account"> | string | null
    parentId?: IntNullableFilter<"Account"> | number | null
    companyId?: IntFilter<"Account"> | number
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    division?: StringNullableFilter<"Account"> | string | null
  }

  export type AuditLogUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutCompanyInput, AuditLogUncheckedUpdateWithoutCompanyInput>
    create: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutCompanyInput, AuditLogUncheckedUpdateWithoutCompanyInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutCompanyInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutCompanyInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    userId?: IntFilter<"AuditLog"> | number
    action?: StringFilter<"AuditLog"> | string
    module?: StringFilter<"AuditLog"> | string
    entityId?: IntNullableFilter<"AuditLog"> | number | null
    payload?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    companyId?: IntFilter<"AuditLog"> | number
  }

  export type BranchUpsertWithWhereUniqueWithoutCompanyInput = {
    where: BranchWhereUniqueInput
    update: XOR<BranchUpdateWithoutCompanyInput, BranchUncheckedUpdateWithoutCompanyInput>
    create: XOR<BranchCreateWithoutCompanyInput, BranchUncheckedCreateWithoutCompanyInput>
  }

  export type BranchUpdateWithWhereUniqueWithoutCompanyInput = {
    where: BranchWhereUniqueInput
    data: XOR<BranchUpdateWithoutCompanyInput, BranchUncheckedUpdateWithoutCompanyInput>
  }

  export type BranchUpdateManyWithWhereWithoutCompanyInput = {
    where: BranchScalarWhereInput
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyWithoutCompanyInput>
  }

  export type BranchScalarWhereInput = {
    AND?: BranchScalarWhereInput | BranchScalarWhereInput[]
    OR?: BranchScalarWhereInput[]
    NOT?: BranchScalarWhereInput | BranchScalarWhereInput[]
    id?: IntFilter<"Branch"> | number
    name?: StringFilter<"Branch"> | string
    location?: StringNullableFilter<"Branch"> | string | null
    companyId?: IntFilter<"Branch"> | number
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
  }

  export type CompanyCurrencyUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyCurrencyWhereUniqueInput
    update: XOR<CompanyCurrencyUpdateWithoutCompanyInput, CompanyCurrencyUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyCurrencyCreateWithoutCompanyInput, CompanyCurrencyUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyCurrencyUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyCurrencyWhereUniqueInput
    data: XOR<CompanyCurrencyUpdateWithoutCompanyInput, CompanyCurrencyUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyCurrencyUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyCurrencyScalarWhereInput
    data: XOR<CompanyCurrencyUpdateManyMutationInput, CompanyCurrencyUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyCurrencyScalarWhereInput = {
    AND?: CompanyCurrencyScalarWhereInput | CompanyCurrencyScalarWhereInput[]
    OR?: CompanyCurrencyScalarWhereInput[]
    NOT?: CompanyCurrencyScalarWhereInput | CompanyCurrencyScalarWhereInput[]
    id?: IntFilter<"CompanyCurrency"> | number
    companyId?: IntFilter<"CompanyCurrency"> | number
    currencyId?: IntFilter<"CompanyCurrency"> | number
    exchangeRate?: FloatFilter<"CompanyCurrency"> | number
    isDefault?: BoolFilter<"CompanyCurrency"> | boolean
  }

  export type CustomerUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutCompanyInput, CustomerUncheckedUpdateWithoutCompanyInput>
    create: XOR<CustomerCreateWithoutCompanyInput, CustomerUncheckedCreateWithoutCompanyInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutCompanyInput, CustomerUncheckedUpdateWithoutCompanyInput>
  }

  export type CustomerUpdateManyWithWhereWithoutCompanyInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: IntFilter<"Customer"> | number
    name?: StringFilter<"Customer"> | string
    code?: StringFilter<"Customer"> | string
    address?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    taxNumber?: StringNullableFilter<"Customer"> | string | null
    accountId?: IntNullableFilter<"Customer"> | number | null
    companyId?: IntFilter<"Customer"> | number
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    division?: StringNullableFilter<"Customer"> | string | null
  }

  export type ExpenseUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutCompanyInput, ExpenseUncheckedUpdateWithoutCompanyInput>
    create: XOR<ExpenseCreateWithoutCompanyInput, ExpenseUncheckedCreateWithoutCompanyInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutCompanyInput, ExpenseUncheckedUpdateWithoutCompanyInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutCompanyInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ExpenseScalarWhereInput = {
    AND?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    OR?: ExpenseScalarWhereInput[]
    NOT?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    id?: IntFilter<"Expense"> | number
    jobId?: IntFilter<"Expense"> | number
    vendorId?: IntNullableFilter<"Expense"> | number | null
    description?: StringFilter<"Expense"> | string
    costPrice?: FloatFilter<"Expense"> | number
    sellingPrice?: FloatFilter<"Expense"> | number
    currencyCode?: StringFilter<"Expense"> | string
    exchangeRate?: FloatFilter<"Expense"> | number
    companyId?: IntFilter<"Expense"> | number
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
  }

  export type ExpenseMasterUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ExpenseMasterWhereUniqueInput
    update: XOR<ExpenseMasterUpdateWithoutCompanyInput, ExpenseMasterUncheckedUpdateWithoutCompanyInput>
    create: XOR<ExpenseMasterCreateWithoutCompanyInput, ExpenseMasterUncheckedCreateWithoutCompanyInput>
  }

  export type ExpenseMasterUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ExpenseMasterWhereUniqueInput
    data: XOR<ExpenseMasterUpdateWithoutCompanyInput, ExpenseMasterUncheckedUpdateWithoutCompanyInput>
  }

  export type ExpenseMasterUpdateManyWithWhereWithoutCompanyInput = {
    where: ExpenseMasterScalarWhereInput
    data: XOR<ExpenseMasterUpdateManyMutationInput, ExpenseMasterUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ExpenseMasterScalarWhereInput = {
    AND?: ExpenseMasterScalarWhereInput | ExpenseMasterScalarWhereInput[]
    OR?: ExpenseMasterScalarWhereInput[]
    NOT?: ExpenseMasterScalarWhereInput | ExpenseMasterScalarWhereInput[]
    id?: IntFilter<"ExpenseMaster"> | number
    code?: StringFilter<"ExpenseMaster"> | string
    name?: StringFilter<"ExpenseMaster"> | string
    companyId?: IntFilter<"ExpenseMaster"> | number
    createdAt?: DateTimeFilter<"ExpenseMaster"> | Date | string
    updatedAt?: DateTimeFilter<"ExpenseMaster"> | Date | string
  }

  export type FinancialPeriodUpsertWithWhereUniqueWithoutCompanyInput = {
    where: FinancialPeriodWhereUniqueInput
    update: XOR<FinancialPeriodUpdateWithoutCompanyInput, FinancialPeriodUncheckedUpdateWithoutCompanyInput>
    create: XOR<FinancialPeriodCreateWithoutCompanyInput, FinancialPeriodUncheckedCreateWithoutCompanyInput>
  }

  export type FinancialPeriodUpdateWithWhereUniqueWithoutCompanyInput = {
    where: FinancialPeriodWhereUniqueInput
    data: XOR<FinancialPeriodUpdateWithoutCompanyInput, FinancialPeriodUncheckedUpdateWithoutCompanyInput>
  }

  export type FinancialPeriodUpdateManyWithWhereWithoutCompanyInput = {
    where: FinancialPeriodScalarWhereInput
    data: XOR<FinancialPeriodUpdateManyMutationInput, FinancialPeriodUncheckedUpdateManyWithoutCompanyInput>
  }

  export type FinancialPeriodScalarWhereInput = {
    AND?: FinancialPeriodScalarWhereInput | FinancialPeriodScalarWhereInput[]
    OR?: FinancialPeriodScalarWhereInput[]
    NOT?: FinancialPeriodScalarWhereInput | FinancialPeriodScalarWhereInput[]
    id?: IntFilter<"FinancialPeriod"> | number
    month?: IntFilter<"FinancialPeriod"> | number
    year?: IntFilter<"FinancialPeriod"> | number
    isClosed?: BoolFilter<"FinancialPeriod"> | boolean
    closedById?: IntNullableFilter<"FinancialPeriod"> | number | null
    closedAt?: DateTimeNullableFilter<"FinancialPeriod"> | Date | string | null
    companyId?: IntFilter<"FinancialPeriod"> | number
  }

  export type ServiceInvoiceUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ServiceInvoiceWhereUniqueInput
    update: XOR<ServiceInvoiceUpdateWithoutCompanyInput, ServiceInvoiceUncheckedUpdateWithoutCompanyInput>
    create: XOR<ServiceInvoiceCreateWithoutCompanyInput, ServiceInvoiceUncheckedCreateWithoutCompanyInput>
  }

  export type ServiceInvoiceUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ServiceInvoiceWhereUniqueInput
    data: XOR<ServiceInvoiceUpdateWithoutCompanyInput, ServiceInvoiceUncheckedUpdateWithoutCompanyInput>
  }

  export type ServiceInvoiceUpdateManyWithWhereWithoutCompanyInput = {
    where: ServiceInvoiceScalarWhereInput
    data: XOR<ServiceInvoiceUpdateManyMutationInput, ServiceInvoiceUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ServiceInvoiceScalarWhereInput = {
    AND?: ServiceInvoiceScalarWhereInput | ServiceInvoiceScalarWhereInput[]
    OR?: ServiceInvoiceScalarWhereInput[]
    NOT?: ServiceInvoiceScalarWhereInput | ServiceInvoiceScalarWhereInput[]
    id?: IntFilter<"ServiceInvoice"> | number
    invoiceNumber?: StringFilter<"ServiceInvoice"> | string
    date?: DateTimeFilter<"ServiceInvoice"> | Date | string
    jobId?: IntFilter<"ServiceInvoice"> | number
    customerId?: IntFilter<"ServiceInvoice"> | number
    type?: EnumInvoiceTypeFilter<"ServiceInvoice"> | $Enums.InvoiceType
    status?: EnumInvoiceStatusFilter<"ServiceInvoice"> | $Enums.InvoiceStatus
    masterNumber?: StringNullableFilter<"ServiceInvoice"> | string | null
    agentCode?: StringNullableFilter<"ServiceInvoice"> | string | null
    shippingLine?: StringNullableFilter<"ServiceInvoice"> | string | null
    origin?: StringNullableFilter<"ServiceInvoice"> | string | null
    destination?: StringNullableFilter<"ServiceInvoice"> | string | null
    creditDays?: IntNullableFilter<"ServiceInvoice"> | number | null
    vendorType?: StringNullableFilter<"ServiceInvoice"> | string | null
    totalAmount?: FloatFilter<"ServiceInvoice"> | number
    taxAmount?: FloatFilter<"ServiceInvoice"> | number
    grandTotal?: FloatFilter<"ServiceInvoice"> | number
    currencyCode?: StringFilter<"ServiceInvoice"> | string
    exchangeRate?: FloatFilter<"ServiceInvoice"> | number
    isApproved?: BoolFilter<"ServiceInvoice"> | boolean
    approvedById?: IntNullableFilter<"ServiceInvoice"> | number | null
    isLocked?: BoolFilter<"ServiceInvoice"> | boolean
    lockedAt?: DateTimeNullableFilter<"ServiceInvoice"> | Date | string | null
    companyId?: IntFilter<"ServiceInvoice"> | number
    createdAt?: DateTimeFilter<"ServiceInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceInvoice"> | Date | string
    transactionId?: IntNullableFilter<"ServiceInvoice"> | number | null
    division?: StringNullableFilter<"ServiceInvoice"> | string | null
  }

  export type FreightInvoiceUpsertWithWhereUniqueWithoutCompanyInput = {
    where: FreightInvoiceWhereUniqueInput
    update: XOR<FreightInvoiceUpdateWithoutCompanyInput, FreightInvoiceUncheckedUpdateWithoutCompanyInput>
    create: XOR<FreightInvoiceCreateWithoutCompanyInput, FreightInvoiceUncheckedCreateWithoutCompanyInput>
  }

  export type FreightInvoiceUpdateWithWhereUniqueWithoutCompanyInput = {
    where: FreightInvoiceWhereUniqueInput
    data: XOR<FreightInvoiceUpdateWithoutCompanyInput, FreightInvoiceUncheckedUpdateWithoutCompanyInput>
  }

  export type FreightInvoiceUpdateManyWithWhereWithoutCompanyInput = {
    where: FreightInvoiceScalarWhereInput
    data: XOR<FreightInvoiceUpdateManyMutationInput, FreightInvoiceUncheckedUpdateManyWithoutCompanyInput>
  }

  export type FreightInvoiceScalarWhereInput = {
    AND?: FreightInvoiceScalarWhereInput | FreightInvoiceScalarWhereInput[]
    OR?: FreightInvoiceScalarWhereInput[]
    NOT?: FreightInvoiceScalarWhereInput | FreightInvoiceScalarWhereInput[]
    id?: IntFilter<"FreightInvoice"> | number
    invoiceNumber?: StringFilter<"FreightInvoice"> | string
    date?: DateTimeFilter<"FreightInvoice"> | Date | string
    jobId?: IntNullableFilter<"FreightInvoice"> | number | null
    customerId?: IntFilter<"FreightInvoice"> | number
    type?: EnumInvoiceTypeFilter<"FreightInvoice"> | $Enums.InvoiceType
    status?: EnumInvoiceStatusFilter<"FreightInvoice"> | $Enums.InvoiceStatus
    usdRate?: FloatFilter<"FreightInvoice"> | number
    exchangeRate?: FloatFilter<"FreightInvoice"> | number
    totalAmount?: FloatFilter<"FreightInvoice"> | number
    taxAmount?: FloatFilter<"FreightInvoice"> | number
    grandTotal?: FloatFilter<"FreightInvoice"> | number
    currencyCode?: StringFilter<"FreightInvoice"> | string
    isApproved?: BoolFilter<"FreightInvoice"> | boolean
    approvedById?: IntNullableFilter<"FreightInvoice"> | number | null
    isLocked?: BoolFilter<"FreightInvoice"> | boolean
    lockedAt?: DateTimeNullableFilter<"FreightInvoice"> | Date | string | null
    companyId?: IntFilter<"FreightInvoice"> | number
    createdAt?: DateTimeFilter<"FreightInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"FreightInvoice"> | Date | string
    transactionId?: IntNullableFilter<"FreightInvoice"> | number | null
    division?: StringNullableFilter<"FreightInvoice"> | string | null
  }

  export type JobUpsertWithWhereUniqueWithoutCompanyInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutCompanyInput, JobUncheckedUpdateWithoutCompanyInput>
    create: XOR<JobCreateWithoutCompanyInput, JobUncheckedCreateWithoutCompanyInput>
  }

  export type JobUpdateWithWhereUniqueWithoutCompanyInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutCompanyInput, JobUncheckedUpdateWithoutCompanyInput>
  }

  export type JobUpdateManyWithWhereWithoutCompanyInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutCompanyInput>
  }

  export type JobScalarWhereInput = {
    AND?: JobScalarWhereInput | JobScalarWhereInput[]
    OR?: JobScalarWhereInput[]
    NOT?: JobScalarWhereInput | JobScalarWhereInput[]
    id?: IntFilter<"Job"> | number
    jobNumber?: StringFilter<"Job"> | string
    date?: DateTimeFilter<"Job"> | Date | string
    jobDate?: DateTimeFilter<"Job"> | Date | string
    jobType?: EnumJobTypeFilter<"Job"> | $Enums.JobType
    status?: EnumJobStatusFilter<"Job"> | $Enums.JobStatus
    customerId?: IntFilter<"Job"> | number
    vessel?: StringNullableFilter<"Job"> | string | null
    place?: StringNullableFilter<"Job"> | string | null
    shipperRef?: StringNullableFilter<"Job"> | string | null
    gdNo?: StringNullableFilter<"Job"> | string | null
    gdDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    formE?: StringNullableFilter<"Job"> | string | null
    formEDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    commodity?: StringNullableFilter<"Job"> | string | null
    volume?: StringNullableFilter<"Job"> | string | null
    containerNo?: StringNullableFilter<"Job"> | string | null
    podId?: IntNullableFilter<"Job"> | number | null
    packages?: IntNullableFilter<"Job"> | number | null
    weight?: FloatNullableFilter<"Job"> | number | null
    hawbBl?: StringNullableFilter<"Job"> | string | null
    handledBy?: StringNullableFilter<"Job"> | string | null
    salesPerson?: StringNullableFilter<"Job"> | string | null
    companyId?: IntFilter<"Job"> | number
    branchId?: IntNullableFilter<"Job"> | number | null
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    division?: StringNullableFilter<"Job"> | string | null
  }

  export type PaymentUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutCompanyInput, PaymentUncheckedUpdateWithoutCompanyInput>
    create: XOR<PaymentCreateWithoutCompanyInput, PaymentUncheckedCreateWithoutCompanyInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutCompanyInput, PaymentUncheckedUpdateWithoutCompanyInput>
  }

  export type PaymentUpdateManyWithWhereWithoutCompanyInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: IntFilter<"Payment"> | number
    receiptNumber?: StringFilter<"Payment"> | string
    date?: DateTimeFilter<"Payment"> | Date | string
    amount?: FloatFilter<"Payment"> | number
    mode?: EnumPaymentModeFilter<"Payment"> | $Enums.PaymentMode
    reference?: StringNullableFilter<"Payment"> | string | null
    customerId?: IntNullableFilter<"Payment"> | number | null
    vendorId?: IntNullableFilter<"Payment"> | number | null
    transactionId?: IntFilter<"Payment"> | number
    companyId?: IntFilter<"Payment"> | number
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    division?: StringNullableFilter<"Payment"> | string | null
  }

  export type PortUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PortWhereUniqueInput
    update: XOR<PortUpdateWithoutCompanyInput, PortUncheckedUpdateWithoutCompanyInput>
    create: XOR<PortCreateWithoutCompanyInput, PortUncheckedCreateWithoutCompanyInput>
  }

  export type PortUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PortWhereUniqueInput
    data: XOR<PortUpdateWithoutCompanyInput, PortUncheckedUpdateWithoutCompanyInput>
  }

  export type PortUpdateManyWithWhereWithoutCompanyInput = {
    where: PortScalarWhereInput
    data: XOR<PortUpdateManyMutationInput, PortUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PortScalarWhereInput = {
    AND?: PortScalarWhereInput | PortScalarWhereInput[]
    OR?: PortScalarWhereInput[]
    NOT?: PortScalarWhereInput | PortScalarWhereInput[]
    id?: IntFilter<"Port"> | number
    name?: StringFilter<"Port"> | string
    companyId?: IntFilter<"Port"> | number
    createdAt?: DateTimeFilter<"Port"> | Date | string
    updatedAt?: DateTimeFilter<"Port"> | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCompanyInput, ProductUncheckedUpdateWithoutCompanyInput>
    create: XOR<ProductCreateWithoutCompanyInput, ProductUncheckedCreateWithoutCompanyInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCompanyInput, ProductUncheckedUpdateWithoutCompanyInput>
  }

  export type ProductUpdateManyWithWhereWithoutCompanyInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: IntFilter<"Product"> | number
    sku?: StringNullableFilter<"Product"> | string | null
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    unit?: StringFilter<"Product"> | string
    purchasePrice?: FloatFilter<"Product"> | number
    sellingPrice?: FloatFilter<"Product"> | number
    categoryId?: IntFilter<"Product"> | number
    companyId?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
  }

  export type ProductCategoryUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ProductCategoryWhereUniqueInput
    update: XOR<ProductCategoryUpdateWithoutCompanyInput, ProductCategoryUncheckedUpdateWithoutCompanyInput>
    create: XOR<ProductCategoryCreateWithoutCompanyInput, ProductCategoryUncheckedCreateWithoutCompanyInput>
  }

  export type ProductCategoryUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ProductCategoryWhereUniqueInput
    data: XOR<ProductCategoryUpdateWithoutCompanyInput, ProductCategoryUncheckedUpdateWithoutCompanyInput>
  }

  export type ProductCategoryUpdateManyWithWhereWithoutCompanyInput = {
    where: ProductCategoryScalarWhereInput
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ProductCategoryScalarWhereInput = {
    AND?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    OR?: ProductCategoryScalarWhereInput[]
    NOT?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    id?: IntFilter<"ProductCategory"> | number
    name?: StringFilter<"ProductCategory"> | string
    description?: StringNullableFilter<"ProductCategory"> | string | null
    companyId?: IntFilter<"ProductCategory"> | number
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
  }

  export type PurchaseInvoiceUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PurchaseInvoiceWhereUniqueInput
    update: XOR<PurchaseInvoiceUpdateWithoutCompanyInput, PurchaseInvoiceUncheckedUpdateWithoutCompanyInput>
    create: XOR<PurchaseInvoiceCreateWithoutCompanyInput, PurchaseInvoiceUncheckedCreateWithoutCompanyInput>
  }

  export type PurchaseInvoiceUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PurchaseInvoiceWhereUniqueInput
    data: XOR<PurchaseInvoiceUpdateWithoutCompanyInput, PurchaseInvoiceUncheckedUpdateWithoutCompanyInput>
  }

  export type PurchaseInvoiceUpdateManyWithWhereWithoutCompanyInput = {
    where: PurchaseInvoiceScalarWhereInput
    data: XOR<PurchaseInvoiceUpdateManyMutationInput, PurchaseInvoiceUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PurchaseInvoiceScalarWhereInput = {
    AND?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
    OR?: PurchaseInvoiceScalarWhereInput[]
    NOT?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
    id?: IntFilter<"PurchaseInvoice"> | number
    purchaseNumber?: StringFilter<"PurchaseInvoice"> | string
    date?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    vendorId?: IntFilter<"PurchaseInvoice"> | number
    status?: EnumInvoiceStatusFilter<"PurchaseInvoice"> | $Enums.InvoiceStatus
    totalAmount?: FloatFilter<"PurchaseInvoice"> | number
    taxAmount?: FloatFilter<"PurchaseInvoice"> | number
    grandTotal?: FloatFilter<"PurchaseInvoice"> | number
    currencyCode?: StringFilter<"PurchaseInvoice"> | string
    isApproved?: BoolFilter<"PurchaseInvoice"> | boolean
    approvedById?: IntNullableFilter<"PurchaseInvoice"> | number | null
    isLocked?: BoolFilter<"PurchaseInvoice"> | boolean
    lockedAt?: DateTimeNullableFilter<"PurchaseInvoice"> | Date | string | null
    companyId?: IntFilter<"PurchaseInvoice"> | number
    transactionId?: IntNullableFilter<"PurchaseInvoice"> | number | null
    createdAt?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PurchaseInvoice"> | Date | string | null
  }

  export type StockMovementUpsertWithWhereUniqueWithoutCompanyInput = {
    where: StockMovementWhereUniqueInput
    update: XOR<StockMovementUpdateWithoutCompanyInput, StockMovementUncheckedUpdateWithoutCompanyInput>
    create: XOR<StockMovementCreateWithoutCompanyInput, StockMovementUncheckedCreateWithoutCompanyInput>
  }

  export type StockMovementUpdateWithWhereUniqueWithoutCompanyInput = {
    where: StockMovementWhereUniqueInput
    data: XOR<StockMovementUpdateWithoutCompanyInput, StockMovementUncheckedUpdateWithoutCompanyInput>
  }

  export type StockMovementUpdateManyWithWhereWithoutCompanyInput = {
    where: StockMovementScalarWhereInput
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyWithoutCompanyInput>
  }

  export type StockMovementScalarWhereInput = {
    AND?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
    OR?: StockMovementScalarWhereInput[]
    NOT?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
    id?: IntFilter<"StockMovement"> | number
    productId?: IntFilter<"StockMovement"> | number
    warehouseId?: IntNullableFilter<"StockMovement"> | number | null
    quantity?: FloatFilter<"StockMovement"> | number
    type?: StringFilter<"StockMovement"> | string
    reference?: StringNullableFilter<"StockMovement"> | string | null
    companyId?: IntFilter<"StockMovement"> | number
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
  }

  export type SystemSettingUpsertWithWhereUniqueWithoutCompanyInput = {
    where: SystemSettingWhereUniqueInput
    update: XOR<SystemSettingUpdateWithoutCompanyInput, SystemSettingUncheckedUpdateWithoutCompanyInput>
    create: XOR<SystemSettingCreateWithoutCompanyInput, SystemSettingUncheckedCreateWithoutCompanyInput>
  }

  export type SystemSettingUpdateWithWhereUniqueWithoutCompanyInput = {
    where: SystemSettingWhereUniqueInput
    data: XOR<SystemSettingUpdateWithoutCompanyInput, SystemSettingUncheckedUpdateWithoutCompanyInput>
  }

  export type SystemSettingUpdateManyWithWhereWithoutCompanyInput = {
    where: SystemSettingScalarWhereInput
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyWithoutCompanyInput>
  }

  export type SystemSettingScalarWhereInput = {
    AND?: SystemSettingScalarWhereInput | SystemSettingScalarWhereInput[]
    OR?: SystemSettingScalarWhereInput[]
    NOT?: SystemSettingScalarWhereInput | SystemSettingScalarWhereInput[]
    id?: IntFilter<"SystemSetting"> | number
    key?: StringFilter<"SystemSetting"> | string
    value?: StringFilter<"SystemSetting"> | string
    type?: StringFilter<"SystemSetting"> | string
    companyId?: IntFilter<"SystemSetting"> | number
    createdAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
  }

  export type TaxSettingUpsertWithWhereUniqueWithoutCompanyInput = {
    where: TaxSettingWhereUniqueInput
    update: XOR<TaxSettingUpdateWithoutCompanyInput, TaxSettingUncheckedUpdateWithoutCompanyInput>
    create: XOR<TaxSettingCreateWithoutCompanyInput, TaxSettingUncheckedCreateWithoutCompanyInput>
  }

  export type TaxSettingUpdateWithWhereUniqueWithoutCompanyInput = {
    where: TaxSettingWhereUniqueInput
    data: XOR<TaxSettingUpdateWithoutCompanyInput, TaxSettingUncheckedUpdateWithoutCompanyInput>
  }

  export type TaxSettingUpdateManyWithWhereWithoutCompanyInput = {
    where: TaxSettingScalarWhereInput
    data: XOR<TaxSettingUpdateManyMutationInput, TaxSettingUncheckedUpdateManyWithoutCompanyInput>
  }

  export type TaxSettingScalarWhereInput = {
    AND?: TaxSettingScalarWhereInput | TaxSettingScalarWhereInput[]
    OR?: TaxSettingScalarWhereInput[]
    NOT?: TaxSettingScalarWhereInput | TaxSettingScalarWhereInput[]
    id?: IntFilter<"TaxSetting"> | number
    name?: StringFilter<"TaxSetting"> | string
    percentage?: FloatFilter<"TaxSetting"> | number
    type?: StringFilter<"TaxSetting"> | string
    companyId?: IntFilter<"TaxSetting"> | number
    branchId?: IntNullableFilter<"TaxSetting"> | number | null
    createdAt?: DateTimeFilter<"TaxSetting"> | Date | string
    updatedAt?: DateTimeFilter<"TaxSetting"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutCompanyInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCompanyInput, TransactionUncheckedUpdateWithoutCompanyInput>
    create: XOR<TransactionCreateWithoutCompanyInput, TransactionUncheckedCreateWithoutCompanyInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCompanyInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCompanyInput, TransactionUncheckedUpdateWithoutCompanyInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCompanyInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCompanyInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: IntFilter<"Transaction"> | number
    reference?: StringFilter<"Transaction"> | string
    date?: DateTimeFilter<"Transaction"> | Date | string
    description?: StringNullableFilter<"Transaction"> | string | null
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    companyId?: IntFilter<"Transaction"> | number
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    isLocked?: BoolFilter<"Transaction"> | boolean
  }

  export type UserUpsertWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
  }

  export type UserUpdateManyWithWhereWithoutCompanyInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCompanyInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    companyId?: IntNullableFilter<"User"> | number | null
    branch?: StringNullableFilter<"User"> | string | null
    department?: StringNullableFilter<"User"> | string | null
    region?: StringNullableFilter<"User"> | string | null
    division?: StringNullableFilter<"User"> | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type VendorUpsertWithWhereUniqueWithoutCompanyInput = {
    where: VendorWhereUniqueInput
    update: XOR<VendorUpdateWithoutCompanyInput, VendorUncheckedUpdateWithoutCompanyInput>
    create: XOR<VendorCreateWithoutCompanyInput, VendorUncheckedCreateWithoutCompanyInput>
  }

  export type VendorUpdateWithWhereUniqueWithoutCompanyInput = {
    where: VendorWhereUniqueInput
    data: XOR<VendorUpdateWithoutCompanyInput, VendorUncheckedUpdateWithoutCompanyInput>
  }

  export type VendorUpdateManyWithWhereWithoutCompanyInput = {
    where: VendorScalarWhereInput
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyWithoutCompanyInput>
  }

  export type VendorScalarWhereInput = {
    AND?: VendorScalarWhereInput | VendorScalarWhereInput[]
    OR?: VendorScalarWhereInput[]
    NOT?: VendorScalarWhereInput | VendorScalarWhereInput[]
    id?: IntFilter<"Vendor"> | number
    name?: StringFilter<"Vendor"> | string
    code?: StringFilter<"Vendor"> | string
    type?: StringNullableFilter<"Vendor"> | string | null
    address?: StringNullableFilter<"Vendor"> | string | null
    phone?: StringNullableFilter<"Vendor"> | string | null
    email?: StringNullableFilter<"Vendor"> | string | null
    taxNumber?: StringNullableFilter<"Vendor"> | string | null
    accountId?: IntNullableFilter<"Vendor"> | number | null
    companyId?: IntFilter<"Vendor"> | number
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
    division?: StringNullableFilter<"Vendor"> | string | null
  }

  export type VoucherUpsertWithWhereUniqueWithoutCompanyInput = {
    where: VoucherWhereUniqueInput
    update: XOR<VoucherUpdateWithoutCompanyInput, VoucherUncheckedUpdateWithoutCompanyInput>
    create: XOR<VoucherCreateWithoutCompanyInput, VoucherUncheckedCreateWithoutCompanyInput>
  }

  export type VoucherUpdateWithWhereUniqueWithoutCompanyInput = {
    where: VoucherWhereUniqueInput
    data: XOR<VoucherUpdateWithoutCompanyInput, VoucherUncheckedUpdateWithoutCompanyInput>
  }

  export type VoucherUpdateManyWithWhereWithoutCompanyInput = {
    where: VoucherScalarWhereInput
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyWithoutCompanyInput>
  }

  export type VoucherScalarWhereInput = {
    AND?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
    OR?: VoucherScalarWhereInput[]
    NOT?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
    id?: IntFilter<"Voucher"> | number
    voucherNumber?: StringFilter<"Voucher"> | string
    voucherType?: EnumVoucherTypeFilter<"Voucher"> | $Enums.VoucherType
    status?: EnumVoucherStatusFilter<"Voucher"> | $Enums.VoucherStatus
    date?: DateTimeFilter<"Voucher"> | Date | string
    postingDate?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    paymentMode?: EnumPaymentModeNullableFilter<"Voucher"> | $Enums.PaymentMode | null
    instrumentNo?: StringNullableFilter<"Voucher"> | string | null
    instrumentDate?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    bankName?: StringNullableFilter<"Voucher"> | string | null
    narration?: StringNullableFilter<"Voucher"> | string | null
    companyId?: IntFilter<"Voucher"> | number
    division?: StringNullableFilter<"Voucher"> | string | null
    isPosted?: BoolFilter<"Voucher"> | boolean
    postedAt?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    postedById?: IntNullableFilter<"Voucher"> | number | null
    createdAt?: DateTimeFilter<"Voucher"> | Date | string
    updatedAt?: DateTimeFilter<"Voucher"> | Date | string
  }

  export type WarehouseUpsertWithWhereUniqueWithoutCompanyInput = {
    where: WarehouseWhereUniqueInput
    update: XOR<WarehouseUpdateWithoutCompanyInput, WarehouseUncheckedUpdateWithoutCompanyInput>
    create: XOR<WarehouseCreateWithoutCompanyInput, WarehouseUncheckedCreateWithoutCompanyInput>
  }

  export type WarehouseUpdateWithWhereUniqueWithoutCompanyInput = {
    where: WarehouseWhereUniqueInput
    data: XOR<WarehouseUpdateWithoutCompanyInput, WarehouseUncheckedUpdateWithoutCompanyInput>
  }

  export type WarehouseUpdateManyWithWhereWithoutCompanyInput = {
    where: WarehouseScalarWhereInput
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyWithoutCompanyInput>
  }

  export type WarehouseScalarWhereInput = {
    AND?: WarehouseScalarWhereInput | WarehouseScalarWhereInput[]
    OR?: WarehouseScalarWhereInput[]
    NOT?: WarehouseScalarWhereInput | WarehouseScalarWhereInput[]
    id?: IntFilter<"Warehouse"> | number
    name?: StringFilter<"Warehouse"> | string
    location?: StringNullableFilter<"Warehouse"> | string | null
    companyId?: IntFilter<"Warehouse"> | number
    createdAt?: DateTimeFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeFilter<"Warehouse"> | Date | string
  }

  export type CompanyCreateWithoutBranchesInput = {
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyCreateNestedManyWithoutCompanyInput
    customers?: CustomerCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCompanyInput
    jobs?: JobCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    ports?: PortCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutBranchesInput = {
    id?: number
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyUncheckedCreateNestedManyWithoutCompanyInput
    customers?: CustomerUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    jobs?: JobUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    ports?: PortUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingUncheckedCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutBranchesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutBranchesInput, CompanyUncheckedCreateWithoutBranchesInput>
  }

  export type JobCreateWithoutBranchInput = {
    jobNumber: string
    date?: Date | string
    jobDate?: Date | string
    jobType?: $Enums.JobType
    status?: $Enums.JobStatus
    vessel?: string | null
    place?: string | null
    shipperRef?: string | null
    gdNo?: string | null
    gdDate?: Date | string | null
    formE?: string | null
    formEDate?: Date | string | null
    commodity?: string | null
    volume?: string | null
    containerNo?: string | null
    packages?: number | null
    weight?: number | null
    hawbBl?: string | null
    handledBy?: string | null
    salesPerson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    division?: string | null
    expenses?: ExpenseCreateNestedManyWithoutJobInput
    serviceInvoice?: ServiceInvoiceCreateNestedOneWithoutJobInput
    freightInvoice?: FreightInvoiceCreateNestedOneWithoutJobInput
    company: CompanyCreateNestedOneWithoutJobsInput
    customer: CustomerCreateNestedOneWithoutJobsInput
    pod?: PortCreateNestedOneWithoutJobsInput
  }

  export type JobUncheckedCreateWithoutBranchInput = {
    id?: number
    jobNumber: string
    date?: Date | string
    jobDate?: Date | string
    jobType?: $Enums.JobType
    status?: $Enums.JobStatus
    customerId: number
    vessel?: string | null
    place?: string | null
    shipperRef?: string | null
    gdNo?: string | null
    gdDate?: Date | string | null
    formE?: string | null
    formEDate?: Date | string | null
    commodity?: string | null
    volume?: string | null
    containerNo?: string | null
    podId?: number | null
    packages?: number | null
    weight?: number | null
    hawbBl?: string | null
    handledBy?: string | null
    salesPerson?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    division?: string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutJobInput
    serviceInvoice?: ServiceInvoiceUncheckedCreateNestedOneWithoutJobInput
    freightInvoice?: FreightInvoiceUncheckedCreateNestedOneWithoutJobInput
  }

  export type JobCreateOrConnectWithoutBranchInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutBranchInput, JobUncheckedCreateWithoutBranchInput>
  }

  export type JobCreateManyBranchInputEnvelope = {
    data: JobCreateManyBranchInput | JobCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type TaxSettingCreateWithoutBranchInput = {
    name: string
    percentage: number
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutTaxSettingsInput
  }

  export type TaxSettingUncheckedCreateWithoutBranchInput = {
    id?: number
    name: string
    percentage: number
    type: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxSettingCreateOrConnectWithoutBranchInput = {
    where: TaxSettingWhereUniqueInput
    create: XOR<TaxSettingCreateWithoutBranchInput, TaxSettingUncheckedCreateWithoutBranchInput>
  }

  export type TaxSettingCreateManyBranchInputEnvelope = {
    data: TaxSettingCreateManyBranchInput | TaxSettingCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutBranchesInput = {
    update: XOR<CompanyUpdateWithoutBranchesInput, CompanyUncheckedUpdateWithoutBranchesInput>
    create: XOR<CompanyCreateWithoutBranchesInput, CompanyUncheckedCreateWithoutBranchesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutBranchesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutBranchesInput, CompanyUncheckedUpdateWithoutBranchesInput>
  }

  export type CompanyUpdateWithoutBranchesInput = {
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCompanyNestedInput
    jobs?: JobUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    ports?: PortUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutBranchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUncheckedUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    ports?: PortUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUncheckedUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type JobUpsertWithWhereUniqueWithoutBranchInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutBranchInput, JobUncheckedUpdateWithoutBranchInput>
    create: XOR<JobCreateWithoutBranchInput, JobUncheckedCreateWithoutBranchInput>
  }

  export type JobUpdateWithWhereUniqueWithoutBranchInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutBranchInput, JobUncheckedUpdateWithoutBranchInput>
  }

  export type JobUpdateManyWithWhereWithoutBranchInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutBranchInput>
  }

  export type TaxSettingUpsertWithWhereUniqueWithoutBranchInput = {
    where: TaxSettingWhereUniqueInput
    update: XOR<TaxSettingUpdateWithoutBranchInput, TaxSettingUncheckedUpdateWithoutBranchInput>
    create: XOR<TaxSettingCreateWithoutBranchInput, TaxSettingUncheckedCreateWithoutBranchInput>
  }

  export type TaxSettingUpdateWithWhereUniqueWithoutBranchInput = {
    where: TaxSettingWhereUniqueInput
    data: XOR<TaxSettingUpdateWithoutBranchInput, TaxSettingUncheckedUpdateWithoutBranchInput>
  }

  export type TaxSettingUpdateManyWithWhereWithoutBranchInput = {
    where: TaxSettingScalarWhereInput
    data: XOR<TaxSettingUpdateManyMutationInput, TaxSettingUncheckedUpdateManyWithoutBranchInput>
  }

  export type CompanyCurrencyCreateWithoutCurrencyInput = {
    exchangeRate?: number
    isDefault?: boolean
    company: CompanyCreateNestedOneWithoutCurrenciesInput
  }

  export type CompanyCurrencyUncheckedCreateWithoutCurrencyInput = {
    id?: number
    companyId: number
    exchangeRate?: number
    isDefault?: boolean
  }

  export type CompanyCurrencyCreateOrConnectWithoutCurrencyInput = {
    where: CompanyCurrencyWhereUniqueInput
    create: XOR<CompanyCurrencyCreateWithoutCurrencyInput, CompanyCurrencyUncheckedCreateWithoutCurrencyInput>
  }

  export type CompanyCurrencyCreateManyCurrencyInputEnvelope = {
    data: CompanyCurrencyCreateManyCurrencyInput | CompanyCurrencyCreateManyCurrencyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCurrencyUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: CompanyCurrencyWhereUniqueInput
    update: XOR<CompanyCurrencyUpdateWithoutCurrencyInput, CompanyCurrencyUncheckedUpdateWithoutCurrencyInput>
    create: XOR<CompanyCurrencyCreateWithoutCurrencyInput, CompanyCurrencyUncheckedCreateWithoutCurrencyInput>
  }

  export type CompanyCurrencyUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: CompanyCurrencyWhereUniqueInput
    data: XOR<CompanyCurrencyUpdateWithoutCurrencyInput, CompanyCurrencyUncheckedUpdateWithoutCurrencyInput>
  }

  export type CompanyCurrencyUpdateManyWithWhereWithoutCurrencyInput = {
    where: CompanyCurrencyScalarWhereInput
    data: XOR<CompanyCurrencyUpdateManyMutationInput, CompanyCurrencyUncheckedUpdateManyWithoutCurrencyInput>
  }

  export type CompanyCreateWithoutCurrenciesInput = {
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    customers?: CustomerCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCompanyInput
    jobs?: JobCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    ports?: PortCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCurrenciesInput = {
    id?: number
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    customers?: CustomerUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    jobs?: JobUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    ports?: PortUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingUncheckedCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCurrenciesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCurrenciesInput, CompanyUncheckedCreateWithoutCurrenciesInput>
  }

  export type CurrencyCreateWithoutCompaniesInput = {
    code: string
    symbol: string
    name: string
  }

  export type CurrencyUncheckedCreateWithoutCompaniesInput = {
    id?: number
    code: string
    symbol: string
    name: string
  }

  export type CurrencyCreateOrConnectWithoutCompaniesInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutCompaniesInput, CurrencyUncheckedCreateWithoutCompaniesInput>
  }

  export type CompanyUpsertWithoutCurrenciesInput = {
    update: XOR<CompanyUpdateWithoutCurrenciesInput, CompanyUncheckedUpdateWithoutCurrenciesInput>
    create: XOR<CompanyCreateWithoutCurrenciesInput, CompanyUncheckedCreateWithoutCurrenciesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCurrenciesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCurrenciesInput, CompanyUncheckedUpdateWithoutCurrenciesInput>
  }

  export type CompanyUpdateWithoutCurrenciesInput = {
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCompanyNestedInput
    jobs?: JobUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    ports?: PortUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCurrenciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    ports?: PortUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUncheckedUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CurrencyUpsertWithoutCompaniesInput = {
    update: XOR<CurrencyUpdateWithoutCompaniesInput, CurrencyUncheckedUpdateWithoutCompaniesInput>
    create: XOR<CurrencyCreateWithoutCompaniesInput, CurrencyUncheckedCreateWithoutCompaniesInput>
    where?: CurrencyWhereInput
  }

  export type CurrencyUpdateToOneWithWhereWithoutCompaniesInput = {
    where?: CurrencyWhereInput
    data: XOR<CurrencyUpdateWithoutCompaniesInput, CurrencyUncheckedUpdateWithoutCompaniesInput>
  }

  export type CurrencyUpdateWithoutCompaniesInput = {
    code?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CurrencyUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BranchCreateWithoutTaxSettingsInput = {
    name: string
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutBranchesInput
    jobs?: JobCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutTaxSettingsInput = {
    id?: number
    name: string
    location?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutTaxSettingsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutTaxSettingsInput, BranchUncheckedCreateWithoutTaxSettingsInput>
  }

  export type CompanyCreateWithoutTaxSettingsInput = {
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyCreateNestedManyWithoutCompanyInput
    customers?: CustomerCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCompanyInput
    jobs?: JobCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    ports?: PortCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutTaxSettingsInput = {
    id?: number
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyUncheckedCreateNestedManyWithoutCompanyInput
    customers?: CustomerUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    jobs?: JobUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    ports?: PortUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutTaxSettingsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutTaxSettingsInput, CompanyUncheckedCreateWithoutTaxSettingsInput>
  }

  export type BranchUpsertWithoutTaxSettingsInput = {
    update: XOR<BranchUpdateWithoutTaxSettingsInput, BranchUncheckedUpdateWithoutTaxSettingsInput>
    create: XOR<BranchCreateWithoutTaxSettingsInput, BranchUncheckedCreateWithoutTaxSettingsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutTaxSettingsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutTaxSettingsInput, BranchUncheckedUpdateWithoutTaxSettingsInput>
  }

  export type BranchUpdateWithoutTaxSettingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutBranchesNestedInput
    jobs?: JobUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutTaxSettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type CompanyUpsertWithoutTaxSettingsInput = {
    update: XOR<CompanyUpdateWithoutTaxSettingsInput, CompanyUncheckedUpdateWithoutTaxSettingsInput>
    create: XOR<CompanyCreateWithoutTaxSettingsInput, CompanyUncheckedCreateWithoutTaxSettingsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutTaxSettingsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutTaxSettingsInput, CompanyUncheckedUpdateWithoutTaxSettingsInput>
  }

  export type CompanyUpdateWithoutTaxSettingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCompanyNestedInput
    jobs?: JobUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    ports?: PortUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutTaxSettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUncheckedUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    ports?: PortUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutSystemSettingsInput = {
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyCreateNestedManyWithoutCompanyInput
    customers?: CustomerCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCompanyInput
    jobs?: JobCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    ports?: PortCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutSystemSettingsInput = {
    id?: number
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyUncheckedCreateNestedManyWithoutCompanyInput
    customers?: CustomerUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    jobs?: JobUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    ports?: PortUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutSystemSettingsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutSystemSettingsInput, CompanyUncheckedCreateWithoutSystemSettingsInput>
  }

  export type CompanyUpsertWithoutSystemSettingsInput = {
    update: XOR<CompanyUpdateWithoutSystemSettingsInput, CompanyUncheckedUpdateWithoutSystemSettingsInput>
    create: XOR<CompanyCreateWithoutSystemSettingsInput, CompanyUncheckedCreateWithoutSystemSettingsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutSystemSettingsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutSystemSettingsInput, CompanyUncheckedUpdateWithoutSystemSettingsInput>
  }

  export type CompanyUpdateWithoutSystemSettingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCompanyNestedInput
    jobs?: JobUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    ports?: PortUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutSystemSettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUncheckedUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    ports?: PortUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type AuditLogCreateWithoutUserInput = {
    action: string
    module: string
    entityId?: number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: number
    action: string
    module: string
    entityId?: number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
    companyId: number
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutUsersInput = {
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyCreateNestedManyWithoutCompanyInput
    customers?: CustomerCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCompanyInput
    jobs?: JobCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    ports?: PortCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyUncheckedCreateNestedManyWithoutCompanyInput
    customers?: CustomerUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    jobs?: JobUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    ports?: PortUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingUncheckedCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUsersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
  }

  export type VoucherCreateWithoutPostedByInput = {
    voucherNumber: string
    voucherType: $Enums.VoucherType
    status?: $Enums.VoucherStatus
    date?: Date | string
    postingDate?: Date | string | null
    paymentMode?: $Enums.PaymentMode | null
    instrumentNo?: string | null
    instrumentDate?: Date | string | null
    bankName?: string | null
    narration?: string | null
    division?: string | null
    isPosted?: boolean
    postedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutVouchersInput
    entries?: VoucherEntryCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUncheckedCreateWithoutPostedByInput = {
    id?: number
    voucherNumber: string
    voucherType: $Enums.VoucherType
    status?: $Enums.VoucherStatus
    date?: Date | string
    postingDate?: Date | string | null
    paymentMode?: $Enums.PaymentMode | null
    instrumentNo?: string | null
    instrumentDate?: Date | string | null
    bankName?: string | null
    narration?: string | null
    companyId: number
    division?: string | null
    isPosted?: boolean
    postedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    entries?: VoucherEntryUncheckedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherCreateOrConnectWithoutPostedByInput = {
    where: VoucherWhereUniqueInput
    create: XOR<VoucherCreateWithoutPostedByInput, VoucherUncheckedCreateWithoutPostedByInput>
  }

  export type VoucherCreateManyPostedByInputEnvelope = {
    data: VoucherCreateManyPostedByInput | VoucherCreateManyPostedByInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type CompanyUpsertWithoutUsersInput = {
    update: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUsersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCompanyNestedInput
    jobs?: JobUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    ports?: PortUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUncheckedUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    ports?: PortUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUncheckedUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type VoucherUpsertWithWhereUniqueWithoutPostedByInput = {
    where: VoucherWhereUniqueInput
    update: XOR<VoucherUpdateWithoutPostedByInput, VoucherUncheckedUpdateWithoutPostedByInput>
    create: XOR<VoucherCreateWithoutPostedByInput, VoucherUncheckedCreateWithoutPostedByInput>
  }

  export type VoucherUpdateWithWhereUniqueWithoutPostedByInput = {
    where: VoucherWhereUniqueInput
    data: XOR<VoucherUpdateWithoutPostedByInput, VoucherUncheckedUpdateWithoutPostedByInput>
  }

  export type VoucherUpdateManyWithWhereWithoutPostedByInput = {
    where: VoucherScalarWhereInput
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyWithoutPostedByInput>
  }

  export type AccountCreateWithoutCustomerInput = {
    code: string
    name: string
    type: $Enums.AccountType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    company: CompanyCreateNestedOneWithoutAccountsInput
    parent?: AccountCreateNestedOneWithoutChildrenInput
    children?: AccountCreateNestedManyWithoutParentInput
    entries?: AccountEntryCreateNestedManyWithoutAccountInput
    vendor?: VendorCreateNestedOneWithoutAccountInput
    voucherEntries?: VoucherEntryCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutCustomerInput = {
    id?: number
    code: string
    name: string
    type: $Enums.AccountType
    description?: string | null
    parentId?: number | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    children?: AccountUncheckedCreateNestedManyWithoutParentInput
    entries?: AccountEntryUncheckedCreateNestedManyWithoutAccountInput
    vendor?: VendorUncheckedCreateNestedOneWithoutAccountInput
    voucherEntries?: VoucherEntryUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutCustomerInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutCustomerInput, AccountUncheckedCreateWithoutCustomerInput>
  }

  export type CompanyCreateWithoutCustomersInput = {
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCompanyInput
    jobs?: JobCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    ports?: PortCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCustomersInput = {
    id?: number
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    jobs?: JobUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    ports?: PortUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingUncheckedCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCustomersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCustomersInput, CompanyUncheckedCreateWithoutCustomersInput>
  }

  export type ServiceInvoiceCreateWithoutCustomerInput = {
    invoiceNumber: string
    date?: Date | string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    masterNumber?: string | null
    agentCode?: string | null
    shippingLine?: string | null
    origin?: string | null
    destination?: string | null
    creditDays?: number | null
    vendorType?: string | null
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    exchangeRate?: number
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    company: CompanyCreateNestedOneWithoutServiceInvoicesInput
    job: JobCreateNestedOneWithoutServiceInvoiceInput
    transaction?: TransactionCreateNestedOneWithoutServiceInput
    items?: ServiceInvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type ServiceInvoiceUncheckedCreateWithoutCustomerInput = {
    id?: number
    invoiceNumber: string
    date?: Date | string
    jobId: number
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    masterNumber?: string | null
    agentCode?: string | null
    shippingLine?: string | null
    origin?: string | null
    destination?: string | null
    creditDays?: number | null
    vendorType?: string | null
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    exchangeRate?: number
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId?: number | null
    division?: string | null
    items?: ServiceInvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type ServiceInvoiceCreateOrConnectWithoutCustomerInput = {
    where: ServiceInvoiceWhereUniqueInput
    create: XOR<ServiceInvoiceCreateWithoutCustomerInput, ServiceInvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type ServiceInvoiceCreateManyCustomerInputEnvelope = {
    data: ServiceInvoiceCreateManyCustomerInput | ServiceInvoiceCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type FreightInvoiceCreateWithoutCustomerInput = {
    invoiceNumber: string
    date?: Date | string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    usdRate?: number
    exchangeRate?: number
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    company: CompanyCreateNestedOneWithoutFreightInvoicesInput
    transaction?: TransactionCreateNestedOneWithoutFreightInput
    job?: JobCreateNestedOneWithoutFreightInvoiceInput
    items?: FreightInvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type FreightInvoiceUncheckedCreateWithoutCustomerInput = {
    id?: number
    invoiceNumber: string
    date?: Date | string
    jobId?: number | null
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    usdRate?: number
    exchangeRate?: number
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId?: number | null
    division?: string | null
    items?: FreightInvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type FreightInvoiceCreateOrConnectWithoutCustomerInput = {
    where: FreightInvoiceWhereUniqueInput
    create: XOR<FreightInvoiceCreateWithoutCustomerInput, FreightInvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type FreightInvoiceCreateManyCustomerInputEnvelope = {
    data: FreightInvoiceCreateManyCustomerInput | FreightInvoiceCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type JobCreateWithoutCustomerInput = {
    jobNumber: string
    date?: Date | string
    jobDate?: Date | string
    jobType?: $Enums.JobType
    status?: $Enums.JobStatus
    vessel?: string | null
    place?: string | null
    shipperRef?: string | null
    gdNo?: string | null
    gdDate?: Date | string | null
    formE?: string | null
    formEDate?: Date | string | null
    commodity?: string | null
    volume?: string | null
    containerNo?: string | null
    packages?: number | null
    weight?: number | null
    hawbBl?: string | null
    handledBy?: string | null
    salesPerson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    division?: string | null
    expenses?: ExpenseCreateNestedManyWithoutJobInput
    serviceInvoice?: ServiceInvoiceCreateNestedOneWithoutJobInput
    freightInvoice?: FreightInvoiceCreateNestedOneWithoutJobInput
    branch?: BranchCreateNestedOneWithoutJobsInput
    company: CompanyCreateNestedOneWithoutJobsInput
    pod?: PortCreateNestedOneWithoutJobsInput
  }

  export type JobUncheckedCreateWithoutCustomerInput = {
    id?: number
    jobNumber: string
    date?: Date | string
    jobDate?: Date | string
    jobType?: $Enums.JobType
    status?: $Enums.JobStatus
    vessel?: string | null
    place?: string | null
    shipperRef?: string | null
    gdNo?: string | null
    gdDate?: Date | string | null
    formE?: string | null
    formEDate?: Date | string | null
    commodity?: string | null
    volume?: string | null
    containerNo?: string | null
    podId?: number | null
    packages?: number | null
    weight?: number | null
    hawbBl?: string | null
    handledBy?: string | null
    salesPerson?: string | null
    companyId: number
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    division?: string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutJobInput
    serviceInvoice?: ServiceInvoiceUncheckedCreateNestedOneWithoutJobInput
    freightInvoice?: FreightInvoiceUncheckedCreateNestedOneWithoutJobInput
  }

  export type JobCreateOrConnectWithoutCustomerInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutCustomerInput, JobUncheckedCreateWithoutCustomerInput>
  }

  export type JobCreateManyCustomerInputEnvelope = {
    data: JobCreateManyCustomerInput | JobCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutCustomerInput = {
    receiptNumber: string
    date?: Date | string
    amount: number
    mode?: $Enums.PaymentMode
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    company: CompanyCreateNestedOneWithoutPaymentsInput
    transaction: TransactionCreateNestedOneWithoutPaymentInput
    vendor?: VendorCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutCustomerInput = {
    id?: number
    receiptNumber: string
    date?: Date | string
    amount: number
    mode?: $Enums.PaymentMode
    reference?: string | null
    vendorId?: number | null
    transactionId: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
  }

  export type PaymentCreateOrConnectWithoutCustomerInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput>
  }

  export type PaymentCreateManyCustomerInputEnvelope = {
    data: PaymentCreateManyCustomerInput | PaymentCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutCustomerInput = {
    update: XOR<AccountUpdateWithoutCustomerInput, AccountUncheckedUpdateWithoutCustomerInput>
    create: XOR<AccountCreateWithoutCustomerInput, AccountUncheckedCreateWithoutCustomerInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutCustomerInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutCustomerInput, AccountUncheckedUpdateWithoutCustomerInput>
  }

  export type AccountUpdateWithoutCustomerInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutAccountsNestedInput
    parent?: AccountUpdateOneWithoutChildrenNestedInput
    children?: AccountUpdateManyWithoutParentNestedInput
    entries?: AccountEntryUpdateManyWithoutAccountNestedInput
    vendor?: VendorUpdateOneWithoutAccountNestedInput
    voucherEntries?: VoucherEntryUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    children?: AccountUncheckedUpdateManyWithoutParentNestedInput
    entries?: AccountEntryUncheckedUpdateManyWithoutAccountNestedInput
    vendor?: VendorUncheckedUpdateOneWithoutAccountNestedInput
    voucherEntries?: VoucherEntryUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type CompanyUpsertWithoutCustomersInput = {
    update: XOR<CompanyUpdateWithoutCustomersInput, CompanyUncheckedUpdateWithoutCustomersInput>
    create: XOR<CompanyCreateWithoutCustomersInput, CompanyUncheckedCreateWithoutCustomersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCustomersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCustomersInput, CompanyUncheckedUpdateWithoutCustomersInput>
  }

  export type CompanyUpdateWithoutCustomersInput = {
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCompanyNestedInput
    jobs?: JobUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    ports?: PortUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    ports?: PortUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUncheckedUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ServiceInvoiceUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ServiceInvoiceWhereUniqueInput
    update: XOR<ServiceInvoiceUpdateWithoutCustomerInput, ServiceInvoiceUncheckedUpdateWithoutCustomerInput>
    create: XOR<ServiceInvoiceCreateWithoutCustomerInput, ServiceInvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type ServiceInvoiceUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ServiceInvoiceWhereUniqueInput
    data: XOR<ServiceInvoiceUpdateWithoutCustomerInput, ServiceInvoiceUncheckedUpdateWithoutCustomerInput>
  }

  export type ServiceInvoiceUpdateManyWithWhereWithoutCustomerInput = {
    where: ServiceInvoiceScalarWhereInput
    data: XOR<ServiceInvoiceUpdateManyMutationInput, ServiceInvoiceUncheckedUpdateManyWithoutCustomerInput>
  }

  export type FreightInvoiceUpsertWithWhereUniqueWithoutCustomerInput = {
    where: FreightInvoiceWhereUniqueInput
    update: XOR<FreightInvoiceUpdateWithoutCustomerInput, FreightInvoiceUncheckedUpdateWithoutCustomerInput>
    create: XOR<FreightInvoiceCreateWithoutCustomerInput, FreightInvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type FreightInvoiceUpdateWithWhereUniqueWithoutCustomerInput = {
    where: FreightInvoiceWhereUniqueInput
    data: XOR<FreightInvoiceUpdateWithoutCustomerInput, FreightInvoiceUncheckedUpdateWithoutCustomerInput>
  }

  export type FreightInvoiceUpdateManyWithWhereWithoutCustomerInput = {
    where: FreightInvoiceScalarWhereInput
    data: XOR<FreightInvoiceUpdateManyMutationInput, FreightInvoiceUncheckedUpdateManyWithoutCustomerInput>
  }

  export type JobUpsertWithWhereUniqueWithoutCustomerInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutCustomerInput, JobUncheckedUpdateWithoutCustomerInput>
    create: XOR<JobCreateWithoutCustomerInput, JobUncheckedCreateWithoutCustomerInput>
  }

  export type JobUpdateWithWhereUniqueWithoutCustomerInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutCustomerInput, JobUncheckedUpdateWithoutCustomerInput>
  }

  export type JobUpdateManyWithWhereWithoutCustomerInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutCustomerInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutCustomerInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutCustomerInput, PaymentUncheckedUpdateWithoutCustomerInput>
    create: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutCustomerInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutCustomerInput, PaymentUncheckedUpdateWithoutCustomerInput>
  }

  export type PaymentUpdateManyWithWhereWithoutCustomerInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutCustomerInput>
  }

  export type ExpenseCreateWithoutVendorInput = {
    description: string
    costPrice?: number
    sellingPrice?: number
    currencyCode?: string
    exchangeRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutExpensesInput
    job: JobCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutVendorInput = {
    id?: number
    jobId: number
    description: string
    costPrice?: number
    sellingPrice?: number
    currencyCode?: string
    exchangeRate?: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutVendorInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutVendorInput, ExpenseUncheckedCreateWithoutVendorInput>
  }

  export type ExpenseCreateManyVendorInputEnvelope = {
    data: ExpenseCreateManyVendorInput | ExpenseCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutVendorInput = {
    receiptNumber: string
    date?: Date | string
    amount: number
    mode?: $Enums.PaymentMode
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    company: CompanyCreateNestedOneWithoutPaymentsInput
    customer?: CustomerCreateNestedOneWithoutPaymentsInput
    transaction: TransactionCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutVendorInput = {
    id?: number
    receiptNumber: string
    date?: Date | string
    amount: number
    mode?: $Enums.PaymentMode
    reference?: string | null
    customerId?: number | null
    transactionId: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
  }

  export type PaymentCreateOrConnectWithoutVendorInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutVendorInput, PaymentUncheckedCreateWithoutVendorInput>
  }

  export type PaymentCreateManyVendorInputEnvelope = {
    data: PaymentCreateManyVendorInput | PaymentCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseInvoiceCreateWithoutVendorInput = {
    purchaseNumber: string
    date?: Date | string
    status?: $Enums.InvoiceStatus
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutPurchaseInvoicesInput
    transaction?: TransactionCreateNestedOneWithoutPurchaseInput
    items?: PurchaseInvoiceItemCreateNestedManyWithoutPurchaseInvoiceInput
  }

  export type PurchaseInvoiceUncheckedCreateWithoutVendorInput = {
    id?: number
    purchaseNumber: string
    date?: Date | string
    status?: $Enums.InvoiceStatus
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    companyId: number
    transactionId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutPurchaseInvoiceInput
  }

  export type PurchaseInvoiceCreateOrConnectWithoutVendorInput = {
    where: PurchaseInvoiceWhereUniqueInput
    create: XOR<PurchaseInvoiceCreateWithoutVendorInput, PurchaseInvoiceUncheckedCreateWithoutVendorInput>
  }

  export type PurchaseInvoiceCreateManyVendorInputEnvelope = {
    data: PurchaseInvoiceCreateManyVendorInput | PurchaseInvoiceCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutVendorInput = {
    code: string
    name: string
    type: $Enums.AccountType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    company: CompanyCreateNestedOneWithoutAccountsInput
    parent?: AccountCreateNestedOneWithoutChildrenInput
    children?: AccountCreateNestedManyWithoutParentInput
    entries?: AccountEntryCreateNestedManyWithoutAccountInput
    customer?: CustomerCreateNestedOneWithoutAccountInput
    voucherEntries?: VoucherEntryCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutVendorInput = {
    id?: number
    code: string
    name: string
    type: $Enums.AccountType
    description?: string | null
    parentId?: number | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    children?: AccountUncheckedCreateNestedManyWithoutParentInput
    entries?: AccountEntryUncheckedCreateNestedManyWithoutAccountInput
    customer?: CustomerUncheckedCreateNestedOneWithoutAccountInput
    voucherEntries?: VoucherEntryUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutVendorInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutVendorInput, AccountUncheckedCreateWithoutVendorInput>
  }

  export type CompanyCreateWithoutVendorsInput = {
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyCreateNestedManyWithoutCompanyInput
    customers?: CustomerCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCompanyInput
    jobs?: JobCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    ports?: PortCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutVendorsInput = {
    id?: number
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyUncheckedCreateNestedManyWithoutCompanyInput
    customers?: CustomerUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    jobs?: JobUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    ports?: PortUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingUncheckedCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutVendorsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutVendorsInput, CompanyUncheckedCreateWithoutVendorsInput>
  }

  export type FreightInvoiceItemCreateWithoutVendorInput = {
    description: string
    quantity?: number
    rate?: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
    invoice: FreightInvoiceCreateNestedOneWithoutItemsInput
  }

  export type FreightInvoiceItemUncheckedCreateWithoutVendorInput = {
    id?: number
    invoiceId: number
    description: string
    quantity?: number
    rate?: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
  }

  export type FreightInvoiceItemCreateOrConnectWithoutVendorInput = {
    where: FreightInvoiceItemWhereUniqueInput
    create: XOR<FreightInvoiceItemCreateWithoutVendorInput, FreightInvoiceItemUncheckedCreateWithoutVendorInput>
  }

  export type FreightInvoiceItemCreateManyVendorInputEnvelope = {
    data: FreightInvoiceItemCreateManyVendorInput | FreightInvoiceItemCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseUpsertWithWhereUniqueWithoutVendorInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutVendorInput, ExpenseUncheckedUpdateWithoutVendorInput>
    create: XOR<ExpenseCreateWithoutVendorInput, ExpenseUncheckedCreateWithoutVendorInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutVendorInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutVendorInput, ExpenseUncheckedUpdateWithoutVendorInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutVendorInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutVendorInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutVendorInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutVendorInput, PaymentUncheckedUpdateWithoutVendorInput>
    create: XOR<PaymentCreateWithoutVendorInput, PaymentUncheckedCreateWithoutVendorInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutVendorInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutVendorInput, PaymentUncheckedUpdateWithoutVendorInput>
  }

  export type PaymentUpdateManyWithWhereWithoutVendorInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutVendorInput>
  }

  export type PurchaseInvoiceUpsertWithWhereUniqueWithoutVendorInput = {
    where: PurchaseInvoiceWhereUniqueInput
    update: XOR<PurchaseInvoiceUpdateWithoutVendorInput, PurchaseInvoiceUncheckedUpdateWithoutVendorInput>
    create: XOR<PurchaseInvoiceCreateWithoutVendorInput, PurchaseInvoiceUncheckedCreateWithoutVendorInput>
  }

  export type PurchaseInvoiceUpdateWithWhereUniqueWithoutVendorInput = {
    where: PurchaseInvoiceWhereUniqueInput
    data: XOR<PurchaseInvoiceUpdateWithoutVendorInput, PurchaseInvoiceUncheckedUpdateWithoutVendorInput>
  }

  export type PurchaseInvoiceUpdateManyWithWhereWithoutVendorInput = {
    where: PurchaseInvoiceScalarWhereInput
    data: XOR<PurchaseInvoiceUpdateManyMutationInput, PurchaseInvoiceUncheckedUpdateManyWithoutVendorInput>
  }

  export type AccountUpsertWithoutVendorInput = {
    update: XOR<AccountUpdateWithoutVendorInput, AccountUncheckedUpdateWithoutVendorInput>
    create: XOR<AccountCreateWithoutVendorInput, AccountUncheckedCreateWithoutVendorInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutVendorInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutVendorInput, AccountUncheckedUpdateWithoutVendorInput>
  }

  export type AccountUpdateWithoutVendorInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutAccountsNestedInput
    parent?: AccountUpdateOneWithoutChildrenNestedInput
    children?: AccountUpdateManyWithoutParentNestedInput
    entries?: AccountEntryUpdateManyWithoutAccountNestedInput
    customer?: CustomerUpdateOneWithoutAccountNestedInput
    voucherEntries?: VoucherEntryUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    children?: AccountUncheckedUpdateManyWithoutParentNestedInput
    entries?: AccountEntryUncheckedUpdateManyWithoutAccountNestedInput
    customer?: CustomerUncheckedUpdateOneWithoutAccountNestedInput
    voucherEntries?: VoucherEntryUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type CompanyUpsertWithoutVendorsInput = {
    update: XOR<CompanyUpdateWithoutVendorsInput, CompanyUncheckedUpdateWithoutVendorsInput>
    create: XOR<CompanyCreateWithoutVendorsInput, CompanyUncheckedCreateWithoutVendorsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutVendorsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutVendorsInput, CompanyUncheckedUpdateWithoutVendorsInput>
  }

  export type CompanyUpdateWithoutVendorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCompanyNestedInput
    jobs?: JobUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    ports?: PortUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutVendorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUncheckedUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    ports?: PortUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUncheckedUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type FreightInvoiceItemUpsertWithWhereUniqueWithoutVendorInput = {
    where: FreightInvoiceItemWhereUniqueInput
    update: XOR<FreightInvoiceItemUpdateWithoutVendorInput, FreightInvoiceItemUncheckedUpdateWithoutVendorInput>
    create: XOR<FreightInvoiceItemCreateWithoutVendorInput, FreightInvoiceItemUncheckedCreateWithoutVendorInput>
  }

  export type FreightInvoiceItemUpdateWithWhereUniqueWithoutVendorInput = {
    where: FreightInvoiceItemWhereUniqueInput
    data: XOR<FreightInvoiceItemUpdateWithoutVendorInput, FreightInvoiceItemUncheckedUpdateWithoutVendorInput>
  }

  export type FreightInvoiceItemUpdateManyWithWhereWithoutVendorInput = {
    where: FreightInvoiceItemScalarWhereInput
    data: XOR<FreightInvoiceItemUpdateManyMutationInput, FreightInvoiceItemUncheckedUpdateManyWithoutVendorInput>
  }

  export type FreightInvoiceItemScalarWhereInput = {
    AND?: FreightInvoiceItemScalarWhereInput | FreightInvoiceItemScalarWhereInput[]
    OR?: FreightInvoiceItemScalarWhereInput[]
    NOT?: FreightInvoiceItemScalarWhereInput | FreightInvoiceItemScalarWhereInput[]
    id?: IntFilter<"FreightInvoiceItem"> | number
    invoiceId?: IntFilter<"FreightInvoiceItem"> | number
    description?: StringFilter<"FreightInvoiceItem"> | string
    quantity?: FloatFilter<"FreightInvoiceItem"> | number
    rate?: FloatFilter<"FreightInvoiceItem"> | number
    amount?: FloatFilter<"FreightInvoiceItem"> | number
    taxPercentage?: FloatFilter<"FreightInvoiceItem"> | number
    taxAmount?: FloatFilter<"FreightInvoiceItem"> | number
    total?: FloatFilter<"FreightInvoiceItem"> | number
    vendorId?: IntNullableFilter<"FreightInvoiceItem"> | number | null
  }

  export type ExpenseCreateWithoutJobInput = {
    description: string
    costPrice?: number
    sellingPrice?: number
    currencyCode?: string
    exchangeRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutExpensesInput
    vendor?: VendorCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutJobInput = {
    id?: number
    vendorId?: number | null
    description: string
    costPrice?: number
    sellingPrice?: number
    currencyCode?: string
    exchangeRate?: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutJobInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutJobInput, ExpenseUncheckedCreateWithoutJobInput>
  }

  export type ExpenseCreateManyJobInputEnvelope = {
    data: ExpenseCreateManyJobInput | ExpenseCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type ServiceInvoiceCreateWithoutJobInput = {
    invoiceNumber: string
    date?: Date | string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    masterNumber?: string | null
    agentCode?: string | null
    shippingLine?: string | null
    origin?: string | null
    destination?: string | null
    creditDays?: number | null
    vendorType?: string | null
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    exchangeRate?: number
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    company: CompanyCreateNestedOneWithoutServiceInvoicesInput
    customer: CustomerCreateNestedOneWithoutServiceInvoicesInput
    transaction?: TransactionCreateNestedOneWithoutServiceInput
    items?: ServiceInvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type ServiceInvoiceUncheckedCreateWithoutJobInput = {
    id?: number
    invoiceNumber: string
    date?: Date | string
    customerId: number
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    masterNumber?: string | null
    agentCode?: string | null
    shippingLine?: string | null
    origin?: string | null
    destination?: string | null
    creditDays?: number | null
    vendorType?: string | null
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    exchangeRate?: number
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId?: number | null
    division?: string | null
    items?: ServiceInvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type ServiceInvoiceCreateOrConnectWithoutJobInput = {
    where: ServiceInvoiceWhereUniqueInput
    create: XOR<ServiceInvoiceCreateWithoutJobInput, ServiceInvoiceUncheckedCreateWithoutJobInput>
  }

  export type FreightInvoiceCreateWithoutJobInput = {
    invoiceNumber: string
    date?: Date | string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    usdRate?: number
    exchangeRate?: number
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    company: CompanyCreateNestedOneWithoutFreightInvoicesInput
    customer: CustomerCreateNestedOneWithoutFreightInvoicesInput
    transaction?: TransactionCreateNestedOneWithoutFreightInput
    items?: FreightInvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type FreightInvoiceUncheckedCreateWithoutJobInput = {
    id?: number
    invoiceNumber: string
    date?: Date | string
    customerId: number
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    usdRate?: number
    exchangeRate?: number
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId?: number | null
    division?: string | null
    items?: FreightInvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type FreightInvoiceCreateOrConnectWithoutJobInput = {
    where: FreightInvoiceWhereUniqueInput
    create: XOR<FreightInvoiceCreateWithoutJobInput, FreightInvoiceUncheckedCreateWithoutJobInput>
  }

  export type BranchCreateWithoutJobsInput = {
    name: string
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutBranchesInput
    taxSettings?: TaxSettingCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutJobsInput = {
    id?: number
    name: string
    location?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutJobsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutJobsInput, BranchUncheckedCreateWithoutJobsInput>
  }

  export type CompanyCreateWithoutJobsInput = {
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyCreateNestedManyWithoutCompanyInput
    customers?: CustomerCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    ports?: PortCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutJobsInput = {
    id?: number
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyUncheckedCreateNestedManyWithoutCompanyInput
    customers?: CustomerUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    ports?: PortUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingUncheckedCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutJobsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutJobsInput, CompanyUncheckedCreateWithoutJobsInput>
  }

  export type CustomerCreateWithoutJobsInput = {
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    account?: AccountCreateNestedOneWithoutCustomerInput
    company: CompanyCreateNestedOneWithoutCustomersInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCustomerInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutJobsInput = {
    id?: number
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    accountId?: number | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutJobsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutJobsInput, CustomerUncheckedCreateWithoutJobsInput>
  }

  export type PortCreateWithoutJobsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutPortsInput
  }

  export type PortUncheckedCreateWithoutJobsInput = {
    id?: number
    name: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortCreateOrConnectWithoutJobsInput = {
    where: PortWhereUniqueInput
    create: XOR<PortCreateWithoutJobsInput, PortUncheckedCreateWithoutJobsInput>
  }

  export type ExpenseUpsertWithWhereUniqueWithoutJobInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutJobInput, ExpenseUncheckedUpdateWithoutJobInput>
    create: XOR<ExpenseCreateWithoutJobInput, ExpenseUncheckedCreateWithoutJobInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutJobInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutJobInput, ExpenseUncheckedUpdateWithoutJobInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutJobInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutJobInput>
  }

  export type ServiceInvoiceUpsertWithoutJobInput = {
    update: XOR<ServiceInvoiceUpdateWithoutJobInput, ServiceInvoiceUncheckedUpdateWithoutJobInput>
    create: XOR<ServiceInvoiceCreateWithoutJobInput, ServiceInvoiceUncheckedCreateWithoutJobInput>
    where?: ServiceInvoiceWhereInput
  }

  export type ServiceInvoiceUpdateToOneWithWhereWithoutJobInput = {
    where?: ServiceInvoiceWhereInput
    data: XOR<ServiceInvoiceUpdateWithoutJobInput, ServiceInvoiceUncheckedUpdateWithoutJobInput>
  }

  export type ServiceInvoiceUpdateWithoutJobInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    masterNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agentCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingLine?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    creditDays?: NullableIntFieldUpdateOperationsInput | number | null
    vendorType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutServiceInvoicesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutServiceInvoicesNestedInput
    transaction?: TransactionUpdateOneWithoutServiceNestedInput
    items?: ServiceInvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type ServiceInvoiceUncheckedUpdateWithoutJobInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: IntFieldUpdateOperationsInput | number
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    masterNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agentCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingLine?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    creditDays?: NullableIntFieldUpdateOperationsInput | number | null
    vendorType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ServiceInvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type FreightInvoiceUpsertWithoutJobInput = {
    update: XOR<FreightInvoiceUpdateWithoutJobInput, FreightInvoiceUncheckedUpdateWithoutJobInput>
    create: XOR<FreightInvoiceCreateWithoutJobInput, FreightInvoiceUncheckedCreateWithoutJobInput>
    where?: FreightInvoiceWhereInput
  }

  export type FreightInvoiceUpdateToOneWithWhereWithoutJobInput = {
    where?: FreightInvoiceWhereInput
    data: XOR<FreightInvoiceUpdateWithoutJobInput, FreightInvoiceUncheckedUpdateWithoutJobInput>
  }

  export type FreightInvoiceUpdateWithoutJobInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    usdRate?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutFreightInvoicesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutFreightInvoicesNestedInput
    transaction?: TransactionUpdateOneWithoutFreightNestedInput
    items?: FreightInvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type FreightInvoiceUncheckedUpdateWithoutJobInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: IntFieldUpdateOperationsInput | number
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    usdRate?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    items?: FreightInvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type BranchUpsertWithoutJobsInput = {
    update: XOR<BranchUpdateWithoutJobsInput, BranchUncheckedUpdateWithoutJobsInput>
    create: XOR<BranchCreateWithoutJobsInput, BranchUncheckedCreateWithoutJobsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutJobsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutJobsInput, BranchUncheckedUpdateWithoutJobsInput>
  }

  export type BranchUpdateWithoutJobsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutBranchesNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutJobsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type CompanyUpsertWithoutJobsInput = {
    update: XOR<CompanyUpdateWithoutJobsInput, CompanyUncheckedUpdateWithoutJobsInput>
    create: XOR<CompanyCreateWithoutJobsInput, CompanyUncheckedCreateWithoutJobsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutJobsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutJobsInput, CompanyUncheckedUpdateWithoutJobsInput>
  }

  export type CompanyUpdateWithoutJobsInput = {
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    ports?: PortUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutJobsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUncheckedUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    ports?: PortUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUncheckedUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CustomerUpsertWithoutJobsInput = {
    update: XOR<CustomerUpdateWithoutJobsInput, CustomerUncheckedUpdateWithoutJobsInput>
    create: XOR<CustomerCreateWithoutJobsInput, CustomerUncheckedCreateWithoutJobsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutJobsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutJobsInput, CustomerUncheckedUpdateWithoutJobsInput>
  }

  export type CustomerUpdateWithoutJobsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneWithoutCustomerNestedInput
    company?: CompanyUpdateOneRequiredWithoutCustomersNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCustomerNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutJobsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type PortUpsertWithoutJobsInput = {
    update: XOR<PortUpdateWithoutJobsInput, PortUncheckedUpdateWithoutJobsInput>
    create: XOR<PortCreateWithoutJobsInput, PortUncheckedCreateWithoutJobsInput>
    where?: PortWhereInput
  }

  export type PortUpdateToOneWithWhereWithoutJobsInput = {
    where?: PortWhereInput
    data: XOR<PortUpdateWithoutJobsInput, PortUncheckedUpdateWithoutJobsInput>
  }

  export type PortUpdateWithoutJobsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPortsNestedInput
  }

  export type PortUncheckedUpdateWithoutJobsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateWithoutExpensesMasterInput = {
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyCreateNestedManyWithoutCompanyInput
    customers?: CustomerCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCompanyInput
    jobs?: JobCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    ports?: PortCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutExpensesMasterInput = {
    id?: number
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyUncheckedCreateNestedManyWithoutCompanyInput
    customers?: CustomerUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    jobs?: JobUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    ports?: PortUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingUncheckedCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutExpensesMasterInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutExpensesMasterInput, CompanyUncheckedCreateWithoutExpensesMasterInput>
  }

  export type CompanyUpsertWithoutExpensesMasterInput = {
    update: XOR<CompanyUpdateWithoutExpensesMasterInput, CompanyUncheckedUpdateWithoutExpensesMasterInput>
    create: XOR<CompanyCreateWithoutExpensesMasterInput, CompanyUncheckedCreateWithoutExpensesMasterInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutExpensesMasterInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutExpensesMasterInput, CompanyUncheckedUpdateWithoutExpensesMasterInput>
  }

  export type CompanyUpdateWithoutExpensesMasterInput = {
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCompanyNestedInput
    jobs?: JobUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    ports?: PortUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutExpensesMasterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUncheckedUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    ports?: PortUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUncheckedUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutExpensesInput = {
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyCreateNestedManyWithoutCompanyInput
    customers?: CustomerCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCompanyInput
    jobs?: JobCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    ports?: PortCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutExpensesInput = {
    id?: number
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyUncheckedCreateNestedManyWithoutCompanyInput
    customers?: CustomerUncheckedCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    jobs?: JobUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    ports?: PortUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingUncheckedCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutExpensesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutExpensesInput, CompanyUncheckedCreateWithoutExpensesInput>
  }

  export type JobCreateWithoutExpensesInput = {
    jobNumber: string
    date?: Date | string
    jobDate?: Date | string
    jobType?: $Enums.JobType
    status?: $Enums.JobStatus
    vessel?: string | null
    place?: string | null
    shipperRef?: string | null
    gdNo?: string | null
    gdDate?: Date | string | null
    formE?: string | null
    formEDate?: Date | string | null
    commodity?: string | null
    volume?: string | null
    containerNo?: string | null
    packages?: number | null
    weight?: number | null
    hawbBl?: string | null
    handledBy?: string | null
    salesPerson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    division?: string | null
    serviceInvoice?: ServiceInvoiceCreateNestedOneWithoutJobInput
    freightInvoice?: FreightInvoiceCreateNestedOneWithoutJobInput
    branch?: BranchCreateNestedOneWithoutJobsInput
    company: CompanyCreateNestedOneWithoutJobsInput
    customer: CustomerCreateNestedOneWithoutJobsInput
    pod?: PortCreateNestedOneWithoutJobsInput
  }

  export type JobUncheckedCreateWithoutExpensesInput = {
    id?: number
    jobNumber: string
    date?: Date | string
    jobDate?: Date | string
    jobType?: $Enums.JobType
    status?: $Enums.JobStatus
    customerId: number
    vessel?: string | null
    place?: string | null
    shipperRef?: string | null
    gdNo?: string | null
    gdDate?: Date | string | null
    formE?: string | null
    formEDate?: Date | string | null
    commodity?: string | null
    volume?: string | null
    containerNo?: string | null
    podId?: number | null
    packages?: number | null
    weight?: number | null
    hawbBl?: string | null
    handledBy?: string | null
    salesPerson?: string | null
    companyId: number
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    division?: string | null
    serviceInvoice?: ServiceInvoiceUncheckedCreateNestedOneWithoutJobInput
    freightInvoice?: FreightInvoiceUncheckedCreateNestedOneWithoutJobInput
  }

  export type JobCreateOrConnectWithoutExpensesInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutExpensesInput, JobUncheckedCreateWithoutExpensesInput>
  }

  export type VendorCreateWithoutExpensesInput = {
    name: string
    code: string
    type?: string | null
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    payments?: PaymentCreateNestedManyWithoutVendorInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutVendorInput
    account?: AccountCreateNestedOneWithoutVendorInput
    company: CompanyCreateNestedOneWithoutVendorsInput
    freightItems?: FreightInvoiceItemCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutExpensesInput = {
    id?: number
    name: string
    code: string
    type?: string | null
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    accountId?: number | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    payments?: PaymentUncheckedCreateNestedManyWithoutVendorInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutVendorInput
    freightItems?: FreightInvoiceItemUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutExpensesInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutExpensesInput, VendorUncheckedCreateWithoutExpensesInput>
  }

  export type CompanyUpsertWithoutExpensesInput = {
    update: XOR<CompanyUpdateWithoutExpensesInput, CompanyUncheckedUpdateWithoutExpensesInput>
    create: XOR<CompanyCreateWithoutExpensesInput, CompanyUncheckedCreateWithoutExpensesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutExpensesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutExpensesInput, CompanyUncheckedUpdateWithoutExpensesInput>
  }

  export type CompanyUpdateWithoutExpensesInput = {
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCompanyNestedInput
    jobs?: JobUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    ports?: PortUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutExpensesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUncheckedUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    ports?: PortUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUncheckedUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type JobUpsertWithoutExpensesInput = {
    update: XOR<JobUpdateWithoutExpensesInput, JobUncheckedUpdateWithoutExpensesInput>
    create: XOR<JobCreateWithoutExpensesInput, JobUncheckedCreateWithoutExpensesInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutExpensesInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutExpensesInput, JobUncheckedUpdateWithoutExpensesInput>
  }

  export type JobUpdateWithoutExpensesInput = {
    jobNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    place?: NullableStringFieldUpdateOperationsInput | string | null
    shipperRef?: NullableStringFieldUpdateOperationsInput | string | null
    gdNo?: NullableStringFieldUpdateOperationsInput | string | null
    gdDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formE?: NullableStringFieldUpdateOperationsInput | string | null
    formEDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commodity?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    containerNo?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    hawbBl?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    salesPerson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    serviceInvoice?: ServiceInvoiceUpdateOneWithoutJobNestedInput
    freightInvoice?: FreightInvoiceUpdateOneWithoutJobNestedInput
    branch?: BranchUpdateOneWithoutJobsNestedInput
    company?: CompanyUpdateOneRequiredWithoutJobsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutJobsNestedInput
    pod?: PortUpdateOneWithoutJobsNestedInput
  }

  export type JobUncheckedUpdateWithoutExpensesInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    customerId?: IntFieldUpdateOperationsInput | number
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    place?: NullableStringFieldUpdateOperationsInput | string | null
    shipperRef?: NullableStringFieldUpdateOperationsInput | string | null
    gdNo?: NullableStringFieldUpdateOperationsInput | string | null
    gdDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formE?: NullableStringFieldUpdateOperationsInput | string | null
    formEDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commodity?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    containerNo?: NullableStringFieldUpdateOperationsInput | string | null
    podId?: NullableIntFieldUpdateOperationsInput | number | null
    packages?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    hawbBl?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    salesPerson?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    serviceInvoice?: ServiceInvoiceUncheckedUpdateOneWithoutJobNestedInput
    freightInvoice?: FreightInvoiceUncheckedUpdateOneWithoutJobNestedInput
  }

  export type VendorUpsertWithoutExpensesInput = {
    update: XOR<VendorUpdateWithoutExpensesInput, VendorUncheckedUpdateWithoutExpensesInput>
    create: XOR<VendorCreateWithoutExpensesInput, VendorUncheckedCreateWithoutExpensesInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutExpensesInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutExpensesInput, VendorUncheckedUpdateWithoutExpensesInput>
  }

  export type VendorUpdateWithoutExpensesInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: PaymentUpdateManyWithoutVendorNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutVendorNestedInput
    account?: AccountUpdateOneWithoutVendorNestedInput
    company?: CompanyUpdateOneRequiredWithoutVendorsNestedInput
    freightItems?: FreightInvoiceItemUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutExpensesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: PaymentUncheckedUpdateManyWithoutVendorNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutVendorNestedInput
    freightItems?: FreightInvoiceItemUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type CompanyCreateWithoutServiceInvoicesInput = {
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyCreateNestedManyWithoutCompanyInput
    customers?: CustomerCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCompanyInput
    jobs?: JobCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    ports?: PortCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutServiceInvoicesInput = {
    id?: number
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyUncheckedCreateNestedManyWithoutCompanyInput
    customers?: CustomerUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    jobs?: JobUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    ports?: PortUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingUncheckedCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutServiceInvoicesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutServiceInvoicesInput, CompanyUncheckedCreateWithoutServiceInvoicesInput>
  }

  export type CustomerCreateWithoutServiceInvoicesInput = {
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    account?: AccountCreateNestedOneWithoutCustomerInput
    company: CompanyCreateNestedOneWithoutCustomersInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCustomerInput
    jobs?: JobCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutServiceInvoicesInput = {
    id?: number
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    accountId?: number | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    jobs?: JobUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutServiceInvoicesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutServiceInvoicesInput, CustomerUncheckedCreateWithoutServiceInvoicesInput>
  }

  export type JobCreateWithoutServiceInvoiceInput = {
    jobNumber: string
    date?: Date | string
    jobDate?: Date | string
    jobType?: $Enums.JobType
    status?: $Enums.JobStatus
    vessel?: string | null
    place?: string | null
    shipperRef?: string | null
    gdNo?: string | null
    gdDate?: Date | string | null
    formE?: string | null
    formEDate?: Date | string | null
    commodity?: string | null
    volume?: string | null
    containerNo?: string | null
    packages?: number | null
    weight?: number | null
    hawbBl?: string | null
    handledBy?: string | null
    salesPerson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    division?: string | null
    expenses?: ExpenseCreateNestedManyWithoutJobInput
    freightInvoice?: FreightInvoiceCreateNestedOneWithoutJobInput
    branch?: BranchCreateNestedOneWithoutJobsInput
    company: CompanyCreateNestedOneWithoutJobsInput
    customer: CustomerCreateNestedOneWithoutJobsInput
    pod?: PortCreateNestedOneWithoutJobsInput
  }

  export type JobUncheckedCreateWithoutServiceInvoiceInput = {
    id?: number
    jobNumber: string
    date?: Date | string
    jobDate?: Date | string
    jobType?: $Enums.JobType
    status?: $Enums.JobStatus
    customerId: number
    vessel?: string | null
    place?: string | null
    shipperRef?: string | null
    gdNo?: string | null
    gdDate?: Date | string | null
    formE?: string | null
    formEDate?: Date | string | null
    commodity?: string | null
    volume?: string | null
    containerNo?: string | null
    podId?: number | null
    packages?: number | null
    weight?: number | null
    hawbBl?: string | null
    handledBy?: string | null
    salesPerson?: string | null
    companyId: number
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    division?: string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutJobInput
    freightInvoice?: FreightInvoiceUncheckedCreateNestedOneWithoutJobInput
  }

  export type JobCreateOrConnectWithoutServiceInvoiceInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutServiceInvoiceInput, JobUncheckedCreateWithoutServiceInvoiceInput>
  }

  export type TransactionCreateWithoutServiceInput = {
    reference: string
    date?: Date | string
    description?: string | null
    type?: $Enums.TransactionType
    createdAt?: Date | string
    updatedAt?: Date | string
    isLocked?: boolean
    entries?: AccountEntryCreateNestedManyWithoutTransactionInput
    freight?: FreightInvoiceCreateNestedOneWithoutTransactionInput
    payment?: PaymentCreateNestedOneWithoutTransactionInput
    purchase?: PurchaseInvoiceCreateNestedOneWithoutTransactionInput
    company: CompanyCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutServiceInput = {
    id?: number
    reference: string
    date?: Date | string
    description?: string | null
    type?: $Enums.TransactionType
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isLocked?: boolean
    entries?: AccountEntryUncheckedCreateNestedManyWithoutTransactionInput
    freight?: FreightInvoiceUncheckedCreateNestedOneWithoutTransactionInput
    payment?: PaymentUncheckedCreateNestedOneWithoutTransactionInput
    purchase?: PurchaseInvoiceUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutServiceInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutServiceInput, TransactionUncheckedCreateWithoutServiceInput>
  }

  export type ServiceInvoiceItemCreateWithoutInvoiceInput = {
    description: string
    quantity?: number
    rate?: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
    product?: ProductCreateNestedOneWithoutServiceItemsInput
  }

  export type ServiceInvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: number
    description: string
    quantity?: number
    rate?: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
    productId?: number | null
  }

  export type ServiceInvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: ServiceInvoiceItemWhereUniqueInput
    create: XOR<ServiceInvoiceItemCreateWithoutInvoiceInput, ServiceInvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type ServiceInvoiceItemCreateManyInvoiceInputEnvelope = {
    data: ServiceInvoiceItemCreateManyInvoiceInput | ServiceInvoiceItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutServiceInvoicesInput = {
    update: XOR<CompanyUpdateWithoutServiceInvoicesInput, CompanyUncheckedUpdateWithoutServiceInvoicesInput>
    create: XOR<CompanyCreateWithoutServiceInvoicesInput, CompanyUncheckedCreateWithoutServiceInvoicesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutServiceInvoicesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutServiceInvoicesInput, CompanyUncheckedUpdateWithoutServiceInvoicesInput>
  }

  export type CompanyUpdateWithoutServiceInvoicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCompanyNestedInput
    jobs?: JobUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    ports?: PortUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutServiceInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUncheckedUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    ports?: PortUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUncheckedUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CustomerUpsertWithoutServiceInvoicesInput = {
    update: XOR<CustomerUpdateWithoutServiceInvoicesInput, CustomerUncheckedUpdateWithoutServiceInvoicesInput>
    create: XOR<CustomerCreateWithoutServiceInvoicesInput, CustomerUncheckedCreateWithoutServiceInvoicesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutServiceInvoicesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutServiceInvoicesInput, CustomerUncheckedUpdateWithoutServiceInvoicesInput>
  }

  export type CustomerUpdateWithoutServiceInvoicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneWithoutCustomerNestedInput
    company?: CompanyUpdateOneRequiredWithoutCustomersNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCustomerNestedInput
    jobs?: JobUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutServiceInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type JobUpsertWithoutServiceInvoiceInput = {
    update: XOR<JobUpdateWithoutServiceInvoiceInput, JobUncheckedUpdateWithoutServiceInvoiceInput>
    create: XOR<JobCreateWithoutServiceInvoiceInput, JobUncheckedCreateWithoutServiceInvoiceInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutServiceInvoiceInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutServiceInvoiceInput, JobUncheckedUpdateWithoutServiceInvoiceInput>
  }

  export type JobUpdateWithoutServiceInvoiceInput = {
    jobNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    place?: NullableStringFieldUpdateOperationsInput | string | null
    shipperRef?: NullableStringFieldUpdateOperationsInput | string | null
    gdNo?: NullableStringFieldUpdateOperationsInput | string | null
    gdDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formE?: NullableStringFieldUpdateOperationsInput | string | null
    formEDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commodity?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    containerNo?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    hawbBl?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    salesPerson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUpdateManyWithoutJobNestedInput
    freightInvoice?: FreightInvoiceUpdateOneWithoutJobNestedInput
    branch?: BranchUpdateOneWithoutJobsNestedInput
    company?: CompanyUpdateOneRequiredWithoutJobsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutJobsNestedInput
    pod?: PortUpdateOneWithoutJobsNestedInput
  }

  export type JobUncheckedUpdateWithoutServiceInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    customerId?: IntFieldUpdateOperationsInput | number
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    place?: NullableStringFieldUpdateOperationsInput | string | null
    shipperRef?: NullableStringFieldUpdateOperationsInput | string | null
    gdNo?: NullableStringFieldUpdateOperationsInput | string | null
    gdDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formE?: NullableStringFieldUpdateOperationsInput | string | null
    formEDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commodity?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    containerNo?: NullableStringFieldUpdateOperationsInput | string | null
    podId?: NullableIntFieldUpdateOperationsInput | number | null
    packages?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    hawbBl?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    salesPerson?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutJobNestedInput
    freightInvoice?: FreightInvoiceUncheckedUpdateOneWithoutJobNestedInput
  }

  export type TransactionUpsertWithoutServiceInput = {
    update: XOR<TransactionUpdateWithoutServiceInput, TransactionUncheckedUpdateWithoutServiceInput>
    create: XOR<TransactionCreateWithoutServiceInput, TransactionUncheckedCreateWithoutServiceInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutServiceInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutServiceInput, TransactionUncheckedUpdateWithoutServiceInput>
  }

  export type TransactionUpdateWithoutServiceInput = {
    reference?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    entries?: AccountEntryUpdateManyWithoutTransactionNestedInput
    freight?: FreightInvoiceUpdateOneWithoutTransactionNestedInput
    payment?: PaymentUpdateOneWithoutTransactionNestedInput
    purchase?: PurchaseInvoiceUpdateOneWithoutTransactionNestedInput
    company?: CompanyUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    entries?: AccountEntryUncheckedUpdateManyWithoutTransactionNestedInput
    freight?: FreightInvoiceUncheckedUpdateOneWithoutTransactionNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutTransactionNestedInput
    purchase?: PurchaseInvoiceUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type ServiceInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: ServiceInvoiceItemWhereUniqueInput
    update: XOR<ServiceInvoiceItemUpdateWithoutInvoiceInput, ServiceInvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<ServiceInvoiceItemCreateWithoutInvoiceInput, ServiceInvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type ServiceInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: ServiceInvoiceItemWhereUniqueInput
    data: XOR<ServiceInvoiceItemUpdateWithoutInvoiceInput, ServiceInvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type ServiceInvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: ServiceInvoiceItemScalarWhereInput
    data: XOR<ServiceInvoiceItemUpdateManyMutationInput, ServiceInvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type ServiceInvoiceItemScalarWhereInput = {
    AND?: ServiceInvoiceItemScalarWhereInput | ServiceInvoiceItemScalarWhereInput[]
    OR?: ServiceInvoiceItemScalarWhereInput[]
    NOT?: ServiceInvoiceItemScalarWhereInput | ServiceInvoiceItemScalarWhereInput[]
    id?: IntFilter<"ServiceInvoiceItem"> | number
    invoiceId?: IntFilter<"ServiceInvoiceItem"> | number
    description?: StringFilter<"ServiceInvoiceItem"> | string
    quantity?: FloatFilter<"ServiceInvoiceItem"> | number
    rate?: FloatFilter<"ServiceInvoiceItem"> | number
    amount?: FloatFilter<"ServiceInvoiceItem"> | number
    taxPercentage?: FloatFilter<"ServiceInvoiceItem"> | number
    taxAmount?: FloatFilter<"ServiceInvoiceItem"> | number
    total?: FloatFilter<"ServiceInvoiceItem"> | number
    productId?: IntNullableFilter<"ServiceInvoiceItem"> | number | null
  }

  export type ServiceInvoiceCreateWithoutItemsInput = {
    invoiceNumber: string
    date?: Date | string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    masterNumber?: string | null
    agentCode?: string | null
    shippingLine?: string | null
    origin?: string | null
    destination?: string | null
    creditDays?: number | null
    vendorType?: string | null
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    exchangeRate?: number
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    company: CompanyCreateNestedOneWithoutServiceInvoicesInput
    customer: CustomerCreateNestedOneWithoutServiceInvoicesInput
    job: JobCreateNestedOneWithoutServiceInvoiceInput
    transaction?: TransactionCreateNestedOneWithoutServiceInput
  }

  export type ServiceInvoiceUncheckedCreateWithoutItemsInput = {
    id?: number
    invoiceNumber: string
    date?: Date | string
    jobId: number
    customerId: number
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    masterNumber?: string | null
    agentCode?: string | null
    shippingLine?: string | null
    origin?: string | null
    destination?: string | null
    creditDays?: number | null
    vendorType?: string | null
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    exchangeRate?: number
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId?: number | null
    division?: string | null
  }

  export type ServiceInvoiceCreateOrConnectWithoutItemsInput = {
    where: ServiceInvoiceWhereUniqueInput
    create: XOR<ServiceInvoiceCreateWithoutItemsInput, ServiceInvoiceUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutServiceItemsInput = {
    sku?: string | null
    name: string
    description?: string | null
    unit?: string
    purchasePrice?: number
    sellingPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    category: ProductCategoryCreateNestedOneWithoutProductsInput
    company: CompanyCreateNestedOneWithoutProductsInput
    purchaseItems?: PurchaseInvoiceItemCreateNestedManyWithoutProductInput
    movements?: StockMovementCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutServiceItemsInput = {
    id?: number
    sku?: string | null
    name: string
    description?: string | null
    unit?: string
    purchasePrice?: number
    sellingPrice?: number
    categoryId: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    purchaseItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutProductInput
    movements?: StockMovementUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutServiceItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutServiceItemsInput, ProductUncheckedCreateWithoutServiceItemsInput>
  }

  export type ServiceInvoiceUpsertWithoutItemsInput = {
    update: XOR<ServiceInvoiceUpdateWithoutItemsInput, ServiceInvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<ServiceInvoiceCreateWithoutItemsInput, ServiceInvoiceUncheckedCreateWithoutItemsInput>
    where?: ServiceInvoiceWhereInput
  }

  export type ServiceInvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: ServiceInvoiceWhereInput
    data: XOR<ServiceInvoiceUpdateWithoutItemsInput, ServiceInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type ServiceInvoiceUpdateWithoutItemsInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    masterNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agentCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingLine?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    creditDays?: NullableIntFieldUpdateOperationsInput | number | null
    vendorType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutServiceInvoicesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutServiceInvoicesNestedInput
    job?: JobUpdateOneRequiredWithoutServiceInvoiceNestedInput
    transaction?: TransactionUpdateOneWithoutServiceNestedInput
  }

  export type ServiceInvoiceUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    masterNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agentCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingLine?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    creditDays?: NullableIntFieldUpdateOperationsInput | number | null
    vendorType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpsertWithoutServiceItemsInput = {
    update: XOR<ProductUpdateWithoutServiceItemsInput, ProductUncheckedUpdateWithoutServiceItemsInput>
    create: XOR<ProductCreateWithoutServiceItemsInput, ProductUncheckedCreateWithoutServiceItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutServiceItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutServiceItemsInput, ProductUncheckedUpdateWithoutServiceItemsInput>
  }

  export type ProductUpdateWithoutServiceItemsInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    company?: CompanyUpdateOneRequiredWithoutProductsNestedInput
    purchaseItems?: PurchaseInvoiceItemUpdateManyWithoutProductNestedInput
    movements?: StockMovementUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutServiceItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaseItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutProductNestedInput
    movements?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CompanyCreateWithoutFreightInvoicesInput = {
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyCreateNestedManyWithoutCompanyInput
    customers?: CustomerCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCompanyInput
    jobs?: JobCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    ports?: PortCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutFreightInvoicesInput = {
    id?: number
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyUncheckedCreateNestedManyWithoutCompanyInput
    customers?: CustomerUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    jobs?: JobUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    ports?: PortUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingUncheckedCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutFreightInvoicesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutFreightInvoicesInput, CompanyUncheckedCreateWithoutFreightInvoicesInput>
  }

  export type CustomerCreateWithoutFreightInvoicesInput = {
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    account?: AccountCreateNestedOneWithoutCustomerInput
    company: CompanyCreateNestedOneWithoutCustomersInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCustomerInput
    jobs?: JobCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutFreightInvoicesInput = {
    id?: number
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    accountId?: number | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    jobs?: JobUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutFreightInvoicesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutFreightInvoicesInput, CustomerUncheckedCreateWithoutFreightInvoicesInput>
  }

  export type TransactionCreateWithoutFreightInput = {
    reference: string
    date?: Date | string
    description?: string | null
    type?: $Enums.TransactionType
    createdAt?: Date | string
    updatedAt?: Date | string
    isLocked?: boolean
    entries?: AccountEntryCreateNestedManyWithoutTransactionInput
    service?: ServiceInvoiceCreateNestedOneWithoutTransactionInput
    payment?: PaymentCreateNestedOneWithoutTransactionInput
    purchase?: PurchaseInvoiceCreateNestedOneWithoutTransactionInput
    company: CompanyCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutFreightInput = {
    id?: number
    reference: string
    date?: Date | string
    description?: string | null
    type?: $Enums.TransactionType
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isLocked?: boolean
    entries?: AccountEntryUncheckedCreateNestedManyWithoutTransactionInput
    service?: ServiceInvoiceUncheckedCreateNestedOneWithoutTransactionInput
    payment?: PaymentUncheckedCreateNestedOneWithoutTransactionInput
    purchase?: PurchaseInvoiceUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutFreightInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutFreightInput, TransactionUncheckedCreateWithoutFreightInput>
  }

  export type JobCreateWithoutFreightInvoiceInput = {
    jobNumber: string
    date?: Date | string
    jobDate?: Date | string
    jobType?: $Enums.JobType
    status?: $Enums.JobStatus
    vessel?: string | null
    place?: string | null
    shipperRef?: string | null
    gdNo?: string | null
    gdDate?: Date | string | null
    formE?: string | null
    formEDate?: Date | string | null
    commodity?: string | null
    volume?: string | null
    containerNo?: string | null
    packages?: number | null
    weight?: number | null
    hawbBl?: string | null
    handledBy?: string | null
    salesPerson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    division?: string | null
    expenses?: ExpenseCreateNestedManyWithoutJobInput
    serviceInvoice?: ServiceInvoiceCreateNestedOneWithoutJobInput
    branch?: BranchCreateNestedOneWithoutJobsInput
    company: CompanyCreateNestedOneWithoutJobsInput
    customer: CustomerCreateNestedOneWithoutJobsInput
    pod?: PortCreateNestedOneWithoutJobsInput
  }

  export type JobUncheckedCreateWithoutFreightInvoiceInput = {
    id?: number
    jobNumber: string
    date?: Date | string
    jobDate?: Date | string
    jobType?: $Enums.JobType
    status?: $Enums.JobStatus
    customerId: number
    vessel?: string | null
    place?: string | null
    shipperRef?: string | null
    gdNo?: string | null
    gdDate?: Date | string | null
    formE?: string | null
    formEDate?: Date | string | null
    commodity?: string | null
    volume?: string | null
    containerNo?: string | null
    podId?: number | null
    packages?: number | null
    weight?: number | null
    hawbBl?: string | null
    handledBy?: string | null
    salesPerson?: string | null
    companyId: number
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    division?: string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutJobInput
    serviceInvoice?: ServiceInvoiceUncheckedCreateNestedOneWithoutJobInput
  }

  export type JobCreateOrConnectWithoutFreightInvoiceInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutFreightInvoiceInput, JobUncheckedCreateWithoutFreightInvoiceInput>
  }

  export type FreightInvoiceItemCreateWithoutInvoiceInput = {
    description: string
    quantity?: number
    rate?: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
    vendor?: VendorCreateNestedOneWithoutFreightItemsInput
  }

  export type FreightInvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: number
    description: string
    quantity?: number
    rate?: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
    vendorId?: number | null
  }

  export type FreightInvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: FreightInvoiceItemWhereUniqueInput
    create: XOR<FreightInvoiceItemCreateWithoutInvoiceInput, FreightInvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type FreightInvoiceItemCreateManyInvoiceInputEnvelope = {
    data: FreightInvoiceItemCreateManyInvoiceInput | FreightInvoiceItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutFreightInvoicesInput = {
    update: XOR<CompanyUpdateWithoutFreightInvoicesInput, CompanyUncheckedUpdateWithoutFreightInvoicesInput>
    create: XOR<CompanyCreateWithoutFreightInvoicesInput, CompanyUncheckedCreateWithoutFreightInvoicesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutFreightInvoicesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutFreightInvoicesInput, CompanyUncheckedUpdateWithoutFreightInvoicesInput>
  }

  export type CompanyUpdateWithoutFreightInvoicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCompanyNestedInput
    jobs?: JobUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    ports?: PortUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutFreightInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUncheckedUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    ports?: PortUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUncheckedUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CustomerUpsertWithoutFreightInvoicesInput = {
    update: XOR<CustomerUpdateWithoutFreightInvoicesInput, CustomerUncheckedUpdateWithoutFreightInvoicesInput>
    create: XOR<CustomerCreateWithoutFreightInvoicesInput, CustomerUncheckedCreateWithoutFreightInvoicesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutFreightInvoicesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutFreightInvoicesInput, CustomerUncheckedUpdateWithoutFreightInvoicesInput>
  }

  export type CustomerUpdateWithoutFreightInvoicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneWithoutCustomerNestedInput
    company?: CompanyUpdateOneRequiredWithoutCustomersNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCustomerNestedInput
    jobs?: JobUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutFreightInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type TransactionUpsertWithoutFreightInput = {
    update: XOR<TransactionUpdateWithoutFreightInput, TransactionUncheckedUpdateWithoutFreightInput>
    create: XOR<TransactionCreateWithoutFreightInput, TransactionUncheckedCreateWithoutFreightInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutFreightInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutFreightInput, TransactionUncheckedUpdateWithoutFreightInput>
  }

  export type TransactionUpdateWithoutFreightInput = {
    reference?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    entries?: AccountEntryUpdateManyWithoutTransactionNestedInput
    service?: ServiceInvoiceUpdateOneWithoutTransactionNestedInput
    payment?: PaymentUpdateOneWithoutTransactionNestedInput
    purchase?: PurchaseInvoiceUpdateOneWithoutTransactionNestedInput
    company?: CompanyUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutFreightInput = {
    id?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    entries?: AccountEntryUncheckedUpdateManyWithoutTransactionNestedInput
    service?: ServiceInvoiceUncheckedUpdateOneWithoutTransactionNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutTransactionNestedInput
    purchase?: PurchaseInvoiceUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type JobUpsertWithoutFreightInvoiceInput = {
    update: XOR<JobUpdateWithoutFreightInvoiceInput, JobUncheckedUpdateWithoutFreightInvoiceInput>
    create: XOR<JobCreateWithoutFreightInvoiceInput, JobUncheckedCreateWithoutFreightInvoiceInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutFreightInvoiceInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutFreightInvoiceInput, JobUncheckedUpdateWithoutFreightInvoiceInput>
  }

  export type JobUpdateWithoutFreightInvoiceInput = {
    jobNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    place?: NullableStringFieldUpdateOperationsInput | string | null
    shipperRef?: NullableStringFieldUpdateOperationsInput | string | null
    gdNo?: NullableStringFieldUpdateOperationsInput | string | null
    gdDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formE?: NullableStringFieldUpdateOperationsInput | string | null
    formEDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commodity?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    containerNo?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    hawbBl?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    salesPerson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUpdateManyWithoutJobNestedInput
    serviceInvoice?: ServiceInvoiceUpdateOneWithoutJobNestedInput
    branch?: BranchUpdateOneWithoutJobsNestedInput
    company?: CompanyUpdateOneRequiredWithoutJobsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutJobsNestedInput
    pod?: PortUpdateOneWithoutJobsNestedInput
  }

  export type JobUncheckedUpdateWithoutFreightInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    customerId?: IntFieldUpdateOperationsInput | number
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    place?: NullableStringFieldUpdateOperationsInput | string | null
    shipperRef?: NullableStringFieldUpdateOperationsInput | string | null
    gdNo?: NullableStringFieldUpdateOperationsInput | string | null
    gdDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formE?: NullableStringFieldUpdateOperationsInput | string | null
    formEDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commodity?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    containerNo?: NullableStringFieldUpdateOperationsInput | string | null
    podId?: NullableIntFieldUpdateOperationsInput | number | null
    packages?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    hawbBl?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    salesPerson?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutJobNestedInput
    serviceInvoice?: ServiceInvoiceUncheckedUpdateOneWithoutJobNestedInput
  }

  export type FreightInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: FreightInvoiceItemWhereUniqueInput
    update: XOR<FreightInvoiceItemUpdateWithoutInvoiceInput, FreightInvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<FreightInvoiceItemCreateWithoutInvoiceInput, FreightInvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type FreightInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: FreightInvoiceItemWhereUniqueInput
    data: XOR<FreightInvoiceItemUpdateWithoutInvoiceInput, FreightInvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type FreightInvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: FreightInvoiceItemScalarWhereInput
    data: XOR<FreightInvoiceItemUpdateManyMutationInput, FreightInvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type FreightInvoiceCreateWithoutItemsInput = {
    invoiceNumber: string
    date?: Date | string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    usdRate?: number
    exchangeRate?: number
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    company: CompanyCreateNestedOneWithoutFreightInvoicesInput
    customer: CustomerCreateNestedOneWithoutFreightInvoicesInput
    transaction?: TransactionCreateNestedOneWithoutFreightInput
    job?: JobCreateNestedOneWithoutFreightInvoiceInput
  }

  export type FreightInvoiceUncheckedCreateWithoutItemsInput = {
    id?: number
    invoiceNumber: string
    date?: Date | string
    jobId?: number | null
    customerId: number
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    usdRate?: number
    exchangeRate?: number
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId?: number | null
    division?: string | null
  }

  export type FreightInvoiceCreateOrConnectWithoutItemsInput = {
    where: FreightInvoiceWhereUniqueInput
    create: XOR<FreightInvoiceCreateWithoutItemsInput, FreightInvoiceUncheckedCreateWithoutItemsInput>
  }

  export type VendorCreateWithoutFreightItemsInput = {
    name: string
    code: string
    type?: string | null
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    expenses?: ExpenseCreateNestedManyWithoutVendorInput
    payments?: PaymentCreateNestedManyWithoutVendorInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutVendorInput
    account?: AccountCreateNestedOneWithoutVendorInput
    company: CompanyCreateNestedOneWithoutVendorsInput
  }

  export type VendorUncheckedCreateWithoutFreightItemsInput = {
    id?: number
    name: string
    code: string
    type?: string | null
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    accountId?: number | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutVendorInput
    payments?: PaymentUncheckedCreateNestedManyWithoutVendorInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutFreightItemsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutFreightItemsInput, VendorUncheckedCreateWithoutFreightItemsInput>
  }

  export type FreightInvoiceUpsertWithoutItemsInput = {
    update: XOR<FreightInvoiceUpdateWithoutItemsInput, FreightInvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<FreightInvoiceCreateWithoutItemsInput, FreightInvoiceUncheckedCreateWithoutItemsInput>
    where?: FreightInvoiceWhereInput
  }

  export type FreightInvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: FreightInvoiceWhereInput
    data: XOR<FreightInvoiceUpdateWithoutItemsInput, FreightInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type FreightInvoiceUpdateWithoutItemsInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    usdRate?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutFreightInvoicesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutFreightInvoicesNestedInput
    transaction?: TransactionUpdateOneWithoutFreightNestedInput
    job?: JobUpdateOneWithoutFreightInvoiceNestedInput
  }

  export type FreightInvoiceUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: IntFieldUpdateOperationsInput | number
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    usdRate?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VendorUpsertWithoutFreightItemsInput = {
    update: XOR<VendorUpdateWithoutFreightItemsInput, VendorUncheckedUpdateWithoutFreightItemsInput>
    create: XOR<VendorCreateWithoutFreightItemsInput, VendorUncheckedCreateWithoutFreightItemsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutFreightItemsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutFreightItemsInput, VendorUncheckedUpdateWithoutFreightItemsInput>
  }

  export type VendorUpdateWithoutFreightItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUpdateManyWithoutVendorNestedInput
    payments?: PaymentUpdateManyWithoutVendorNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutVendorNestedInput
    account?: AccountUpdateOneWithoutVendorNestedInput
    company?: CompanyUpdateOneRequiredWithoutVendorsNestedInput
  }

  export type VendorUncheckedUpdateWithoutFreightItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutVendorNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutVendorNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type ProductCreateWithoutCategoryInput = {
    sku?: string | null
    name: string
    description?: string | null
    unit?: string
    purchasePrice?: number
    sellingPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    serviceItems?: ServiceInvoiceItemCreateNestedManyWithoutProductInput
    company: CompanyCreateNestedOneWithoutProductsInput
    purchaseItems?: PurchaseInvoiceItemCreateNestedManyWithoutProductInput
    movements?: StockMovementCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: number
    sku?: string | null
    name: string
    description?: string | null
    unit?: string
    purchasePrice?: number
    sellingPrice?: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    serviceItems?: ServiceInvoiceItemUncheckedCreateNestedManyWithoutProductInput
    purchaseItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutProductInput
    movements?: StockMovementUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutProductCategoriesInput = {
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyCreateNestedManyWithoutCompanyInput
    customers?: CustomerCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCompanyInput
    jobs?: JobCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    ports?: PortCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutProductCategoriesInput = {
    id?: number
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyUncheckedCreateNestedManyWithoutCompanyInput
    customers?: CustomerUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    jobs?: JobUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    ports?: PortUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingUncheckedCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutProductCategoriesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutProductCategoriesInput, CompanyUncheckedCreateWithoutProductCategoriesInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type CompanyUpsertWithoutProductCategoriesInput = {
    update: XOR<CompanyUpdateWithoutProductCategoriesInput, CompanyUncheckedUpdateWithoutProductCategoriesInput>
    create: XOR<CompanyCreateWithoutProductCategoriesInput, CompanyUncheckedCreateWithoutProductCategoriesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutProductCategoriesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutProductCategoriesInput, CompanyUncheckedUpdateWithoutProductCategoriesInput>
  }

  export type CompanyUpdateWithoutProductCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCompanyNestedInput
    jobs?: JobUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    ports?: PortUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutProductCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUncheckedUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    ports?: PortUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUncheckedUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ServiceInvoiceItemCreateWithoutProductInput = {
    description: string
    quantity?: number
    rate?: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
    invoice: ServiceInvoiceCreateNestedOneWithoutItemsInput
  }

  export type ServiceInvoiceItemUncheckedCreateWithoutProductInput = {
    id?: number
    invoiceId: number
    description: string
    quantity?: number
    rate?: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
  }

  export type ServiceInvoiceItemCreateOrConnectWithoutProductInput = {
    where: ServiceInvoiceItemWhereUniqueInput
    create: XOR<ServiceInvoiceItemCreateWithoutProductInput, ServiceInvoiceItemUncheckedCreateWithoutProductInput>
  }

  export type ServiceInvoiceItemCreateManyProductInputEnvelope = {
    data: ServiceInvoiceItemCreateManyProductInput | ServiceInvoiceItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductCategoryCreateWithoutProductsInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutProductCategoriesInput
  }

  export type ProductCategoryUncheckedCreateWithoutProductsInput = {
    id?: number
    name: string
    description?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryCreateOrConnectWithoutProductsInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
  }

  export type CompanyCreateWithoutProductsInput = {
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyCreateNestedManyWithoutCompanyInput
    customers?: CustomerCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCompanyInput
    jobs?: JobCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    ports?: PortCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutProductsInput = {
    id?: number
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyUncheckedCreateNestedManyWithoutCompanyInput
    customers?: CustomerUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    jobs?: JobUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    ports?: PortUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingUncheckedCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutProductsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutProductsInput, CompanyUncheckedCreateWithoutProductsInput>
  }

  export type PurchaseInvoiceItemCreateWithoutProductInput = {
    description?: string | null
    quantity: number
    rate: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
    purchaseInvoice: PurchaseInvoiceCreateNestedOneWithoutItemsInput
  }

  export type PurchaseInvoiceItemUncheckedCreateWithoutProductInput = {
    id?: number
    purchaseInvoiceId: number
    description?: string | null
    quantity: number
    rate: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
  }

  export type PurchaseInvoiceItemCreateOrConnectWithoutProductInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    create: XOR<PurchaseInvoiceItemCreateWithoutProductInput, PurchaseInvoiceItemUncheckedCreateWithoutProductInput>
  }

  export type PurchaseInvoiceItemCreateManyProductInputEnvelope = {
    data: PurchaseInvoiceItemCreateManyProductInput | PurchaseInvoiceItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type StockMovementCreateWithoutProductInput = {
    quantity: number
    type: string
    reference?: string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutStockMovementsInput
    warehouse?: WarehouseCreateNestedOneWithoutStockMovementsInput
  }

  export type StockMovementUncheckedCreateWithoutProductInput = {
    id?: number
    warehouseId?: number | null
    quantity: number
    type: string
    reference?: string | null
    companyId: number
    createdAt?: Date | string
  }

  export type StockMovementCreateOrConnectWithoutProductInput = {
    where: StockMovementWhereUniqueInput
    create: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput>
  }

  export type StockMovementCreateManyProductInputEnvelope = {
    data: StockMovementCreateManyProductInput | StockMovementCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ServiceInvoiceItemUpsertWithWhereUniqueWithoutProductInput = {
    where: ServiceInvoiceItemWhereUniqueInput
    update: XOR<ServiceInvoiceItemUpdateWithoutProductInput, ServiceInvoiceItemUncheckedUpdateWithoutProductInput>
    create: XOR<ServiceInvoiceItemCreateWithoutProductInput, ServiceInvoiceItemUncheckedCreateWithoutProductInput>
  }

  export type ServiceInvoiceItemUpdateWithWhereUniqueWithoutProductInput = {
    where: ServiceInvoiceItemWhereUniqueInput
    data: XOR<ServiceInvoiceItemUpdateWithoutProductInput, ServiceInvoiceItemUncheckedUpdateWithoutProductInput>
  }

  export type ServiceInvoiceItemUpdateManyWithWhereWithoutProductInput = {
    where: ServiceInvoiceItemScalarWhereInput
    data: XOR<ServiceInvoiceItemUpdateManyMutationInput, ServiceInvoiceItemUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductCategoryUpsertWithoutProductsInput = {
    update: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCategoryUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutProductCategoriesNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUpsertWithoutProductsInput = {
    update: XOR<CompanyUpdateWithoutProductsInput, CompanyUncheckedUpdateWithoutProductsInput>
    create: XOR<CompanyCreateWithoutProductsInput, CompanyUncheckedCreateWithoutProductsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutProductsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutProductsInput, CompanyUncheckedUpdateWithoutProductsInput>
  }

  export type CompanyUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCompanyNestedInput
    jobs?: JobUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    ports?: PortUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUncheckedUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    ports?: PortUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUncheckedUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PurchaseInvoiceItemUpsertWithWhereUniqueWithoutProductInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    update: XOR<PurchaseInvoiceItemUpdateWithoutProductInput, PurchaseInvoiceItemUncheckedUpdateWithoutProductInput>
    create: XOR<PurchaseInvoiceItemCreateWithoutProductInput, PurchaseInvoiceItemUncheckedCreateWithoutProductInput>
  }

  export type PurchaseInvoiceItemUpdateWithWhereUniqueWithoutProductInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    data: XOR<PurchaseInvoiceItemUpdateWithoutProductInput, PurchaseInvoiceItemUncheckedUpdateWithoutProductInput>
  }

  export type PurchaseInvoiceItemUpdateManyWithWhereWithoutProductInput = {
    where: PurchaseInvoiceItemScalarWhereInput
    data: XOR<PurchaseInvoiceItemUpdateManyMutationInput, PurchaseInvoiceItemUncheckedUpdateManyWithoutProductInput>
  }

  export type PurchaseInvoiceItemScalarWhereInput = {
    AND?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
    OR?: PurchaseInvoiceItemScalarWhereInput[]
    NOT?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
    id?: IntFilter<"PurchaseInvoiceItem"> | number
    purchaseInvoiceId?: IntFilter<"PurchaseInvoiceItem"> | number
    productId?: IntFilter<"PurchaseInvoiceItem"> | number
    description?: StringNullableFilter<"PurchaseInvoiceItem"> | string | null
    quantity?: FloatFilter<"PurchaseInvoiceItem"> | number
    rate?: FloatFilter<"PurchaseInvoiceItem"> | number
    amount?: FloatFilter<"PurchaseInvoiceItem"> | number
    taxPercentage?: FloatFilter<"PurchaseInvoiceItem"> | number
    taxAmount?: FloatFilter<"PurchaseInvoiceItem"> | number
    total?: FloatFilter<"PurchaseInvoiceItem"> | number
  }

  export type StockMovementUpsertWithWhereUniqueWithoutProductInput = {
    where: StockMovementWhereUniqueInput
    update: XOR<StockMovementUpdateWithoutProductInput, StockMovementUncheckedUpdateWithoutProductInput>
    create: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput>
  }

  export type StockMovementUpdateWithWhereUniqueWithoutProductInput = {
    where: StockMovementWhereUniqueInput
    data: XOR<StockMovementUpdateWithoutProductInput, StockMovementUncheckedUpdateWithoutProductInput>
  }

  export type StockMovementUpdateManyWithWhereWithoutProductInput = {
    where: StockMovementScalarWhereInput
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyWithoutProductInput>
  }

  export type StockMovementCreateWithoutWarehouseInput = {
    quantity: number
    type: string
    reference?: string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutStockMovementsInput
    product: ProductCreateNestedOneWithoutMovementsInput
  }

  export type StockMovementUncheckedCreateWithoutWarehouseInput = {
    id?: number
    productId: number
    quantity: number
    type: string
    reference?: string | null
    companyId: number
    createdAt?: Date | string
  }

  export type StockMovementCreateOrConnectWithoutWarehouseInput = {
    where: StockMovementWhereUniqueInput
    create: XOR<StockMovementCreateWithoutWarehouseInput, StockMovementUncheckedCreateWithoutWarehouseInput>
  }

  export type StockMovementCreateManyWarehouseInputEnvelope = {
    data: StockMovementCreateManyWarehouseInput | StockMovementCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutWarehousesInput = {
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyCreateNestedManyWithoutCompanyInput
    customers?: CustomerCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCompanyInput
    jobs?: JobCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    ports?: PortCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutWarehousesInput = {
    id?: number
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyUncheckedCreateNestedManyWithoutCompanyInput
    customers?: CustomerUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    jobs?: JobUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    ports?: PortUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingUncheckedCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutWarehousesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutWarehousesInput, CompanyUncheckedCreateWithoutWarehousesInput>
  }

  export type StockMovementUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: StockMovementWhereUniqueInput
    update: XOR<StockMovementUpdateWithoutWarehouseInput, StockMovementUncheckedUpdateWithoutWarehouseInput>
    create: XOR<StockMovementCreateWithoutWarehouseInput, StockMovementUncheckedCreateWithoutWarehouseInput>
  }

  export type StockMovementUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: StockMovementWhereUniqueInput
    data: XOR<StockMovementUpdateWithoutWarehouseInput, StockMovementUncheckedUpdateWithoutWarehouseInput>
  }

  export type StockMovementUpdateManyWithWhereWithoutWarehouseInput = {
    where: StockMovementScalarWhereInput
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type CompanyUpsertWithoutWarehousesInput = {
    update: XOR<CompanyUpdateWithoutWarehousesInput, CompanyUncheckedUpdateWithoutWarehousesInput>
    create: XOR<CompanyCreateWithoutWarehousesInput, CompanyUncheckedCreateWithoutWarehousesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutWarehousesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutWarehousesInput, CompanyUncheckedUpdateWithoutWarehousesInput>
  }

  export type CompanyUpdateWithoutWarehousesInput = {
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCompanyNestedInput
    jobs?: JobUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    ports?: PortUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutWarehousesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUncheckedUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    ports?: PortUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUncheckedUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutStockMovementsInput = {
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyCreateNestedManyWithoutCompanyInput
    customers?: CustomerCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCompanyInput
    jobs?: JobCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    ports?: PortCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutStockMovementsInput = {
    id?: number
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyUncheckedCreateNestedManyWithoutCompanyInput
    customers?: CustomerUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    jobs?: JobUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    ports?: PortUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingUncheckedCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutStockMovementsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutStockMovementsInput, CompanyUncheckedCreateWithoutStockMovementsInput>
  }

  export type ProductCreateWithoutMovementsInput = {
    sku?: string | null
    name: string
    description?: string | null
    unit?: string
    purchasePrice?: number
    sellingPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    serviceItems?: ServiceInvoiceItemCreateNestedManyWithoutProductInput
    category: ProductCategoryCreateNestedOneWithoutProductsInput
    company: CompanyCreateNestedOneWithoutProductsInput
    purchaseItems?: PurchaseInvoiceItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutMovementsInput = {
    id?: number
    sku?: string | null
    name: string
    description?: string | null
    unit?: string
    purchasePrice?: number
    sellingPrice?: number
    categoryId: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    serviceItems?: ServiceInvoiceItemUncheckedCreateNestedManyWithoutProductInput
    purchaseItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutMovementsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutMovementsInput, ProductUncheckedCreateWithoutMovementsInput>
  }

  export type WarehouseCreateWithoutStockMovementsInput = {
    name: string
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutWarehousesInput
  }

  export type WarehouseUncheckedCreateWithoutStockMovementsInput = {
    id?: number
    name: string
    location?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseCreateOrConnectWithoutStockMovementsInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutStockMovementsInput, WarehouseUncheckedCreateWithoutStockMovementsInput>
  }

  export type CompanyUpsertWithoutStockMovementsInput = {
    update: XOR<CompanyUpdateWithoutStockMovementsInput, CompanyUncheckedUpdateWithoutStockMovementsInput>
    create: XOR<CompanyCreateWithoutStockMovementsInput, CompanyUncheckedCreateWithoutStockMovementsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutStockMovementsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutStockMovementsInput, CompanyUncheckedUpdateWithoutStockMovementsInput>
  }

  export type CompanyUpdateWithoutStockMovementsInput = {
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCompanyNestedInput
    jobs?: JobUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    ports?: PortUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutStockMovementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUncheckedUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    ports?: PortUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUncheckedUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ProductUpsertWithoutMovementsInput = {
    update: XOR<ProductUpdateWithoutMovementsInput, ProductUncheckedUpdateWithoutMovementsInput>
    create: XOR<ProductCreateWithoutMovementsInput, ProductUncheckedCreateWithoutMovementsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutMovementsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutMovementsInput, ProductUncheckedUpdateWithoutMovementsInput>
  }

  export type ProductUpdateWithoutMovementsInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceItems?: ServiceInvoiceItemUpdateManyWithoutProductNestedInput
    category?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    company?: CompanyUpdateOneRequiredWithoutProductsNestedInput
    purchaseItems?: PurchaseInvoiceItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutMovementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceItems?: ServiceInvoiceItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type WarehouseUpsertWithoutStockMovementsInput = {
    update: XOR<WarehouseUpdateWithoutStockMovementsInput, WarehouseUncheckedUpdateWithoutStockMovementsInput>
    create: XOR<WarehouseCreateWithoutStockMovementsInput, WarehouseUncheckedCreateWithoutStockMovementsInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutStockMovementsInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutStockMovementsInput, WarehouseUncheckedUpdateWithoutStockMovementsInput>
  }

  export type WarehouseUpdateWithoutStockMovementsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutWarehousesNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutStockMovementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateWithoutPurchaseInvoicesInput = {
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyCreateNestedManyWithoutCompanyInput
    customers?: CustomerCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCompanyInput
    jobs?: JobCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    ports?: PortCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPurchaseInvoicesInput = {
    id?: number
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyUncheckedCreateNestedManyWithoutCompanyInput
    customers?: CustomerUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    jobs?: JobUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    ports?: PortUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingUncheckedCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPurchaseInvoicesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPurchaseInvoicesInput, CompanyUncheckedCreateWithoutPurchaseInvoicesInput>
  }

  export type TransactionCreateWithoutPurchaseInput = {
    reference: string
    date?: Date | string
    description?: string | null
    type?: $Enums.TransactionType
    createdAt?: Date | string
    updatedAt?: Date | string
    isLocked?: boolean
    entries?: AccountEntryCreateNestedManyWithoutTransactionInput
    service?: ServiceInvoiceCreateNestedOneWithoutTransactionInput
    freight?: FreightInvoiceCreateNestedOneWithoutTransactionInput
    payment?: PaymentCreateNestedOneWithoutTransactionInput
    company: CompanyCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutPurchaseInput = {
    id?: number
    reference: string
    date?: Date | string
    description?: string | null
    type?: $Enums.TransactionType
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isLocked?: boolean
    entries?: AccountEntryUncheckedCreateNestedManyWithoutTransactionInput
    service?: ServiceInvoiceUncheckedCreateNestedOneWithoutTransactionInput
    freight?: FreightInvoiceUncheckedCreateNestedOneWithoutTransactionInput
    payment?: PaymentUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutPurchaseInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutPurchaseInput, TransactionUncheckedCreateWithoutPurchaseInput>
  }

  export type VendorCreateWithoutPurchaseInvoicesInput = {
    name: string
    code: string
    type?: string | null
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    expenses?: ExpenseCreateNestedManyWithoutVendorInput
    payments?: PaymentCreateNestedManyWithoutVendorInput
    account?: AccountCreateNestedOneWithoutVendorInput
    company: CompanyCreateNestedOneWithoutVendorsInput
    freightItems?: FreightInvoiceItemCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutPurchaseInvoicesInput = {
    id?: number
    name: string
    code: string
    type?: string | null
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    accountId?: number | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutVendorInput
    payments?: PaymentUncheckedCreateNestedManyWithoutVendorInput
    freightItems?: FreightInvoiceItemUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutPurchaseInvoicesInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutPurchaseInvoicesInput, VendorUncheckedCreateWithoutPurchaseInvoicesInput>
  }

  export type PurchaseInvoiceItemCreateWithoutPurchaseInvoiceInput = {
    description?: string | null
    quantity: number
    rate: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
    product: ProductCreateNestedOneWithoutPurchaseItemsInput
  }

  export type PurchaseInvoiceItemUncheckedCreateWithoutPurchaseInvoiceInput = {
    id?: number
    productId: number
    description?: string | null
    quantity: number
    rate: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
  }

  export type PurchaseInvoiceItemCreateOrConnectWithoutPurchaseInvoiceInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    create: XOR<PurchaseInvoiceItemCreateWithoutPurchaseInvoiceInput, PurchaseInvoiceItemUncheckedCreateWithoutPurchaseInvoiceInput>
  }

  export type PurchaseInvoiceItemCreateManyPurchaseInvoiceInputEnvelope = {
    data: PurchaseInvoiceItemCreateManyPurchaseInvoiceInput | PurchaseInvoiceItemCreateManyPurchaseInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutPurchaseInvoicesInput = {
    update: XOR<CompanyUpdateWithoutPurchaseInvoicesInput, CompanyUncheckedUpdateWithoutPurchaseInvoicesInput>
    create: XOR<CompanyCreateWithoutPurchaseInvoicesInput, CompanyUncheckedCreateWithoutPurchaseInvoicesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPurchaseInvoicesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPurchaseInvoicesInput, CompanyUncheckedUpdateWithoutPurchaseInvoicesInput>
  }

  export type CompanyUpdateWithoutPurchaseInvoicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCompanyNestedInput
    jobs?: JobUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    ports?: PortUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPurchaseInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUncheckedUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    ports?: PortUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUncheckedUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type TransactionUpsertWithoutPurchaseInput = {
    update: XOR<TransactionUpdateWithoutPurchaseInput, TransactionUncheckedUpdateWithoutPurchaseInput>
    create: XOR<TransactionCreateWithoutPurchaseInput, TransactionUncheckedCreateWithoutPurchaseInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutPurchaseInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutPurchaseInput, TransactionUncheckedUpdateWithoutPurchaseInput>
  }

  export type TransactionUpdateWithoutPurchaseInput = {
    reference?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    entries?: AccountEntryUpdateManyWithoutTransactionNestedInput
    service?: ServiceInvoiceUpdateOneWithoutTransactionNestedInput
    freight?: FreightInvoiceUpdateOneWithoutTransactionNestedInput
    payment?: PaymentUpdateOneWithoutTransactionNestedInput
    company?: CompanyUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutPurchaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    entries?: AccountEntryUncheckedUpdateManyWithoutTransactionNestedInput
    service?: ServiceInvoiceUncheckedUpdateOneWithoutTransactionNestedInput
    freight?: FreightInvoiceUncheckedUpdateOneWithoutTransactionNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type VendorUpsertWithoutPurchaseInvoicesInput = {
    update: XOR<VendorUpdateWithoutPurchaseInvoicesInput, VendorUncheckedUpdateWithoutPurchaseInvoicesInput>
    create: XOR<VendorCreateWithoutPurchaseInvoicesInput, VendorUncheckedCreateWithoutPurchaseInvoicesInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutPurchaseInvoicesInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutPurchaseInvoicesInput, VendorUncheckedUpdateWithoutPurchaseInvoicesInput>
  }

  export type VendorUpdateWithoutPurchaseInvoicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUpdateManyWithoutVendorNestedInput
    payments?: PaymentUpdateManyWithoutVendorNestedInput
    account?: AccountUpdateOneWithoutVendorNestedInput
    company?: CompanyUpdateOneRequiredWithoutVendorsNestedInput
    freightItems?: FreightInvoiceItemUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutPurchaseInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutVendorNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutVendorNestedInput
    freightItems?: FreightInvoiceItemUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type PurchaseInvoiceItemUpsertWithWhereUniqueWithoutPurchaseInvoiceInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    update: XOR<PurchaseInvoiceItemUpdateWithoutPurchaseInvoiceInput, PurchaseInvoiceItemUncheckedUpdateWithoutPurchaseInvoiceInput>
    create: XOR<PurchaseInvoiceItemCreateWithoutPurchaseInvoiceInput, PurchaseInvoiceItemUncheckedCreateWithoutPurchaseInvoiceInput>
  }

  export type PurchaseInvoiceItemUpdateWithWhereUniqueWithoutPurchaseInvoiceInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    data: XOR<PurchaseInvoiceItemUpdateWithoutPurchaseInvoiceInput, PurchaseInvoiceItemUncheckedUpdateWithoutPurchaseInvoiceInput>
  }

  export type PurchaseInvoiceItemUpdateManyWithWhereWithoutPurchaseInvoiceInput = {
    where: PurchaseInvoiceItemScalarWhereInput
    data: XOR<PurchaseInvoiceItemUpdateManyMutationInput, PurchaseInvoiceItemUncheckedUpdateManyWithoutPurchaseInvoiceInput>
  }

  export type ProductCreateWithoutPurchaseItemsInput = {
    sku?: string | null
    name: string
    description?: string | null
    unit?: string
    purchasePrice?: number
    sellingPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    serviceItems?: ServiceInvoiceItemCreateNestedManyWithoutProductInput
    category: ProductCategoryCreateNestedOneWithoutProductsInput
    company: CompanyCreateNestedOneWithoutProductsInput
    movements?: StockMovementCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPurchaseItemsInput = {
    id?: number
    sku?: string | null
    name: string
    description?: string | null
    unit?: string
    purchasePrice?: number
    sellingPrice?: number
    categoryId: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    serviceItems?: ServiceInvoiceItemUncheckedCreateNestedManyWithoutProductInput
    movements?: StockMovementUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPurchaseItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPurchaseItemsInput, ProductUncheckedCreateWithoutPurchaseItemsInput>
  }

  export type PurchaseInvoiceCreateWithoutItemsInput = {
    purchaseNumber: string
    date?: Date | string
    status?: $Enums.InvoiceStatus
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutPurchaseInvoicesInput
    transaction?: TransactionCreateNestedOneWithoutPurchaseInput
    vendor: VendorCreateNestedOneWithoutPurchaseInvoicesInput
  }

  export type PurchaseInvoiceUncheckedCreateWithoutItemsInput = {
    id?: number
    purchaseNumber: string
    date?: Date | string
    vendorId: number
    status?: $Enums.InvoiceStatus
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    companyId: number
    transactionId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PurchaseInvoiceCreateOrConnectWithoutItemsInput = {
    where: PurchaseInvoiceWhereUniqueInput
    create: XOR<PurchaseInvoiceCreateWithoutItemsInput, PurchaseInvoiceUncheckedCreateWithoutItemsInput>
  }

  export type ProductUpsertWithoutPurchaseItemsInput = {
    update: XOR<ProductUpdateWithoutPurchaseItemsInput, ProductUncheckedUpdateWithoutPurchaseItemsInput>
    create: XOR<ProductCreateWithoutPurchaseItemsInput, ProductUncheckedCreateWithoutPurchaseItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPurchaseItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPurchaseItemsInput, ProductUncheckedUpdateWithoutPurchaseItemsInput>
  }

  export type ProductUpdateWithoutPurchaseItemsInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceItems?: ServiceInvoiceItemUpdateManyWithoutProductNestedInput
    category?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    company?: CompanyUpdateOneRequiredWithoutProductsNestedInput
    movements?: StockMovementUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPurchaseItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceItems?: ServiceInvoiceItemUncheckedUpdateManyWithoutProductNestedInput
    movements?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
  }

  export type PurchaseInvoiceUpsertWithoutItemsInput = {
    update: XOR<PurchaseInvoiceUpdateWithoutItemsInput, PurchaseInvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<PurchaseInvoiceCreateWithoutItemsInput, PurchaseInvoiceUncheckedCreateWithoutItemsInput>
    where?: PurchaseInvoiceWhereInput
  }

  export type PurchaseInvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: PurchaseInvoiceWhereInput
    data: XOR<PurchaseInvoiceUpdateWithoutItemsInput, PurchaseInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type PurchaseInvoiceUpdateWithoutItemsInput = {
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutPurchaseInvoicesNestedInput
    transaction?: TransactionUpdateOneWithoutPurchaseNestedInput
    vendor?: VendorUpdateOneRequiredWithoutPurchaseInvoicesNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: IntFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompanyCreateWithoutAccountsInput = {
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyCreateNestedManyWithoutCompanyInput
    customers?: CustomerCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCompanyInput
    jobs?: JobCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    ports?: PortCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAccountsInput = {
    id?: number
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyUncheckedCreateNestedManyWithoutCompanyInput
    customers?: CustomerUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    jobs?: JobUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    ports?: PortUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingUncheckedCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAccountsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAccountsInput, CompanyUncheckedCreateWithoutAccountsInput>
  }

  export type AccountCreateWithoutChildrenInput = {
    code: string
    name: string
    type: $Enums.AccountType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    company: CompanyCreateNestedOneWithoutAccountsInput
    parent?: AccountCreateNestedOneWithoutChildrenInput
    entries?: AccountEntryCreateNestedManyWithoutAccountInput
    customer?: CustomerCreateNestedOneWithoutAccountInput
    vendor?: VendorCreateNestedOneWithoutAccountInput
    voucherEntries?: VoucherEntryCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutChildrenInput = {
    id?: number
    code: string
    name: string
    type: $Enums.AccountType
    description?: string | null
    parentId?: number | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    entries?: AccountEntryUncheckedCreateNestedManyWithoutAccountInput
    customer?: CustomerUncheckedCreateNestedOneWithoutAccountInput
    vendor?: VendorUncheckedCreateNestedOneWithoutAccountInput
    voucherEntries?: VoucherEntryUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutChildrenInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutChildrenInput, AccountUncheckedCreateWithoutChildrenInput>
  }

  export type AccountCreateWithoutParentInput = {
    code: string
    name: string
    type: $Enums.AccountType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    company: CompanyCreateNestedOneWithoutAccountsInput
    children?: AccountCreateNestedManyWithoutParentInput
    entries?: AccountEntryCreateNestedManyWithoutAccountInput
    customer?: CustomerCreateNestedOneWithoutAccountInput
    vendor?: VendorCreateNestedOneWithoutAccountInput
    voucherEntries?: VoucherEntryCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutParentInput = {
    id?: number
    code: string
    name: string
    type: $Enums.AccountType
    description?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    children?: AccountUncheckedCreateNestedManyWithoutParentInput
    entries?: AccountEntryUncheckedCreateNestedManyWithoutAccountInput
    customer?: CustomerUncheckedCreateNestedOneWithoutAccountInput
    vendor?: VendorUncheckedCreateNestedOneWithoutAccountInput
    voucherEntries?: VoucherEntryUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutParentInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutParentInput, AccountUncheckedCreateWithoutParentInput>
  }

  export type AccountCreateManyParentInputEnvelope = {
    data: AccountCreateManyParentInput | AccountCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type AccountEntryCreateWithoutAccountInput = {
    description?: string | null
    debit?: number
    credit?: number
    createdAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutEntriesInput
  }

  export type AccountEntryUncheckedCreateWithoutAccountInput = {
    id?: number
    transactionId: number
    description?: string | null
    debit?: number
    credit?: number
    createdAt?: Date | string
  }

  export type AccountEntryCreateOrConnectWithoutAccountInput = {
    where: AccountEntryWhereUniqueInput
    create: XOR<AccountEntryCreateWithoutAccountInput, AccountEntryUncheckedCreateWithoutAccountInput>
  }

  export type AccountEntryCreateManyAccountInputEnvelope = {
    data: AccountEntryCreateManyAccountInput | AccountEntryCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutAccountInput = {
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    company: CompanyCreateNestedOneWithoutCustomersInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCustomerInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCustomerInput
    jobs?: JobCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutAccountInput = {
    id?: number
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    jobs?: JobUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutAccountInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutAccountInput, CustomerUncheckedCreateWithoutAccountInput>
  }

  export type VendorCreateWithoutAccountInput = {
    name: string
    code: string
    type?: string | null
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    expenses?: ExpenseCreateNestedManyWithoutVendorInput
    payments?: PaymentCreateNestedManyWithoutVendorInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutVendorInput
    company: CompanyCreateNestedOneWithoutVendorsInput
    freightItems?: FreightInvoiceItemCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutAccountInput = {
    id?: number
    name: string
    code: string
    type?: string | null
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutVendorInput
    payments?: PaymentUncheckedCreateNestedManyWithoutVendorInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutVendorInput
    freightItems?: FreightInvoiceItemUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutAccountInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutAccountInput, VendorUncheckedCreateWithoutAccountInput>
  }

  export type VoucherEntryCreateWithoutAccountInput = {
    debit?: number
    credit?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    voucher: VoucherCreateNestedOneWithoutEntriesInput
  }

  export type VoucherEntryUncheckedCreateWithoutAccountInput = {
    id?: number
    voucherId: number
    debit?: number
    credit?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoucherEntryCreateOrConnectWithoutAccountInput = {
    where: VoucherEntryWhereUniqueInput
    create: XOR<VoucherEntryCreateWithoutAccountInput, VoucherEntryUncheckedCreateWithoutAccountInput>
  }

  export type VoucherEntryCreateManyAccountInputEnvelope = {
    data: VoucherEntryCreateManyAccountInput | VoucherEntryCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutAccountsInput = {
    update: XOR<CompanyUpdateWithoutAccountsInput, CompanyUncheckedUpdateWithoutAccountsInput>
    create: XOR<CompanyCreateWithoutAccountsInput, CompanyUncheckedCreateWithoutAccountsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAccountsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAccountsInput, CompanyUncheckedUpdateWithoutAccountsInput>
  }

  export type CompanyUpdateWithoutAccountsInput = {
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCompanyNestedInput
    jobs?: JobUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    ports?: PortUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUncheckedUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    ports?: PortUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUncheckedUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type AccountUpsertWithoutChildrenInput = {
    update: XOR<AccountUpdateWithoutChildrenInput, AccountUncheckedUpdateWithoutChildrenInput>
    create: XOR<AccountCreateWithoutChildrenInput, AccountUncheckedCreateWithoutChildrenInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutChildrenInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutChildrenInput, AccountUncheckedUpdateWithoutChildrenInput>
  }

  export type AccountUpdateWithoutChildrenInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutAccountsNestedInput
    parent?: AccountUpdateOneWithoutChildrenNestedInput
    entries?: AccountEntryUpdateManyWithoutAccountNestedInput
    customer?: CustomerUpdateOneWithoutAccountNestedInput
    vendor?: VendorUpdateOneWithoutAccountNestedInput
    voucherEntries?: VoucherEntryUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutChildrenInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    entries?: AccountEntryUncheckedUpdateManyWithoutAccountNestedInput
    customer?: CustomerUncheckedUpdateOneWithoutAccountNestedInput
    vendor?: VendorUncheckedUpdateOneWithoutAccountNestedInput
    voucherEntries?: VoucherEntryUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountUpsertWithWhereUniqueWithoutParentInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutParentInput, AccountUncheckedUpdateWithoutParentInput>
    create: XOR<AccountCreateWithoutParentInput, AccountUncheckedCreateWithoutParentInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutParentInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutParentInput, AccountUncheckedUpdateWithoutParentInput>
  }

  export type AccountUpdateManyWithWhereWithoutParentInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutParentInput>
  }

  export type AccountEntryUpsertWithWhereUniqueWithoutAccountInput = {
    where: AccountEntryWhereUniqueInput
    update: XOR<AccountEntryUpdateWithoutAccountInput, AccountEntryUncheckedUpdateWithoutAccountInput>
    create: XOR<AccountEntryCreateWithoutAccountInput, AccountEntryUncheckedCreateWithoutAccountInput>
  }

  export type AccountEntryUpdateWithWhereUniqueWithoutAccountInput = {
    where: AccountEntryWhereUniqueInput
    data: XOR<AccountEntryUpdateWithoutAccountInput, AccountEntryUncheckedUpdateWithoutAccountInput>
  }

  export type AccountEntryUpdateManyWithWhereWithoutAccountInput = {
    where: AccountEntryScalarWhereInput
    data: XOR<AccountEntryUpdateManyMutationInput, AccountEntryUncheckedUpdateManyWithoutAccountInput>
  }

  export type AccountEntryScalarWhereInput = {
    AND?: AccountEntryScalarWhereInput | AccountEntryScalarWhereInput[]
    OR?: AccountEntryScalarWhereInput[]
    NOT?: AccountEntryScalarWhereInput | AccountEntryScalarWhereInput[]
    id?: IntFilter<"AccountEntry"> | number
    transactionId?: IntFilter<"AccountEntry"> | number
    accountId?: IntFilter<"AccountEntry"> | number
    description?: StringNullableFilter<"AccountEntry"> | string | null
    debit?: FloatFilter<"AccountEntry"> | number
    credit?: FloatFilter<"AccountEntry"> | number
    createdAt?: DateTimeFilter<"AccountEntry"> | Date | string
  }

  export type CustomerUpsertWithoutAccountInput = {
    update: XOR<CustomerUpdateWithoutAccountInput, CustomerUncheckedUpdateWithoutAccountInput>
    create: XOR<CustomerCreateWithoutAccountInput, CustomerUncheckedCreateWithoutAccountInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutAccountInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutAccountInput, CustomerUncheckedUpdateWithoutAccountInput>
  }

  export type CustomerUpdateWithoutAccountInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutCustomersNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCustomerNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCustomerNestedInput
    jobs?: JobUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type VendorUpsertWithoutAccountInput = {
    update: XOR<VendorUpdateWithoutAccountInput, VendorUncheckedUpdateWithoutAccountInput>
    create: XOR<VendorCreateWithoutAccountInput, VendorUncheckedCreateWithoutAccountInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutAccountInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutAccountInput, VendorUncheckedUpdateWithoutAccountInput>
  }

  export type VendorUpdateWithoutAccountInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUpdateManyWithoutVendorNestedInput
    payments?: PaymentUpdateManyWithoutVendorNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutVendorNestedInput
    company?: CompanyUpdateOneRequiredWithoutVendorsNestedInput
    freightItems?: FreightInvoiceItemUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutVendorNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutVendorNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutVendorNestedInput
    freightItems?: FreightInvoiceItemUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VoucherEntryUpsertWithWhereUniqueWithoutAccountInput = {
    where: VoucherEntryWhereUniqueInput
    update: XOR<VoucherEntryUpdateWithoutAccountInput, VoucherEntryUncheckedUpdateWithoutAccountInput>
    create: XOR<VoucherEntryCreateWithoutAccountInput, VoucherEntryUncheckedCreateWithoutAccountInput>
  }

  export type VoucherEntryUpdateWithWhereUniqueWithoutAccountInput = {
    where: VoucherEntryWhereUniqueInput
    data: XOR<VoucherEntryUpdateWithoutAccountInput, VoucherEntryUncheckedUpdateWithoutAccountInput>
  }

  export type VoucherEntryUpdateManyWithWhereWithoutAccountInput = {
    where: VoucherEntryScalarWhereInput
    data: XOR<VoucherEntryUpdateManyMutationInput, VoucherEntryUncheckedUpdateManyWithoutAccountInput>
  }

  export type VoucherEntryScalarWhereInput = {
    AND?: VoucherEntryScalarWhereInput | VoucherEntryScalarWhereInput[]
    OR?: VoucherEntryScalarWhereInput[]
    NOT?: VoucherEntryScalarWhereInput | VoucherEntryScalarWhereInput[]
    id?: IntFilter<"VoucherEntry"> | number
    voucherId?: IntFilter<"VoucherEntry"> | number
    accountId?: IntFilter<"VoucherEntry"> | number
    debit?: FloatFilter<"VoucherEntry"> | number
    credit?: FloatFilter<"VoucherEntry"> | number
    description?: StringNullableFilter<"VoucherEntry"> | string | null
    createdAt?: DateTimeFilter<"VoucherEntry"> | Date | string
    updatedAt?: DateTimeFilter<"VoucherEntry"> | Date | string
  }

  export type AccountEntryCreateWithoutTransactionInput = {
    description?: string | null
    debit?: number
    credit?: number
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutEntriesInput
  }

  export type AccountEntryUncheckedCreateWithoutTransactionInput = {
    id?: number
    accountId: number
    description?: string | null
    debit?: number
    credit?: number
    createdAt?: Date | string
  }

  export type AccountEntryCreateOrConnectWithoutTransactionInput = {
    where: AccountEntryWhereUniqueInput
    create: XOR<AccountEntryCreateWithoutTransactionInput, AccountEntryUncheckedCreateWithoutTransactionInput>
  }

  export type AccountEntryCreateManyTransactionInputEnvelope = {
    data: AccountEntryCreateManyTransactionInput | AccountEntryCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type ServiceInvoiceCreateWithoutTransactionInput = {
    invoiceNumber: string
    date?: Date | string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    masterNumber?: string | null
    agentCode?: string | null
    shippingLine?: string | null
    origin?: string | null
    destination?: string | null
    creditDays?: number | null
    vendorType?: string | null
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    exchangeRate?: number
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    company: CompanyCreateNestedOneWithoutServiceInvoicesInput
    customer: CustomerCreateNestedOneWithoutServiceInvoicesInput
    job: JobCreateNestedOneWithoutServiceInvoiceInput
    items?: ServiceInvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type ServiceInvoiceUncheckedCreateWithoutTransactionInput = {
    id?: number
    invoiceNumber: string
    date?: Date | string
    jobId: number
    customerId: number
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    masterNumber?: string | null
    agentCode?: string | null
    shippingLine?: string | null
    origin?: string | null
    destination?: string | null
    creditDays?: number | null
    vendorType?: string | null
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    exchangeRate?: number
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    items?: ServiceInvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type ServiceInvoiceCreateOrConnectWithoutTransactionInput = {
    where: ServiceInvoiceWhereUniqueInput
    create: XOR<ServiceInvoiceCreateWithoutTransactionInput, ServiceInvoiceUncheckedCreateWithoutTransactionInput>
  }

  export type FreightInvoiceCreateWithoutTransactionInput = {
    invoiceNumber: string
    date?: Date | string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    usdRate?: number
    exchangeRate?: number
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    company: CompanyCreateNestedOneWithoutFreightInvoicesInput
    customer: CustomerCreateNestedOneWithoutFreightInvoicesInput
    job?: JobCreateNestedOneWithoutFreightInvoiceInput
    items?: FreightInvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type FreightInvoiceUncheckedCreateWithoutTransactionInput = {
    id?: number
    invoiceNumber: string
    date?: Date | string
    jobId?: number | null
    customerId: number
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    usdRate?: number
    exchangeRate?: number
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    items?: FreightInvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type FreightInvoiceCreateOrConnectWithoutTransactionInput = {
    where: FreightInvoiceWhereUniqueInput
    create: XOR<FreightInvoiceCreateWithoutTransactionInput, FreightInvoiceUncheckedCreateWithoutTransactionInput>
  }

  export type PaymentCreateWithoutTransactionInput = {
    receiptNumber: string
    date?: Date | string
    amount: number
    mode?: $Enums.PaymentMode
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    company: CompanyCreateNestedOneWithoutPaymentsInput
    customer?: CustomerCreateNestedOneWithoutPaymentsInput
    vendor?: VendorCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutTransactionInput = {
    id?: number
    receiptNumber: string
    date?: Date | string
    amount: number
    mode?: $Enums.PaymentMode
    reference?: string | null
    customerId?: number | null
    vendorId?: number | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
  }

  export type PaymentCreateOrConnectWithoutTransactionInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
  }

  export type PurchaseInvoiceCreateWithoutTransactionInput = {
    purchaseNumber: string
    date?: Date | string
    status?: $Enums.InvoiceStatus
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutPurchaseInvoicesInput
    vendor: VendorCreateNestedOneWithoutPurchaseInvoicesInput
    items?: PurchaseInvoiceItemCreateNestedManyWithoutPurchaseInvoiceInput
  }

  export type PurchaseInvoiceUncheckedCreateWithoutTransactionInput = {
    id?: number
    purchaseNumber: string
    date?: Date | string
    vendorId: number
    status?: $Enums.InvoiceStatus
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutPurchaseInvoiceInput
  }

  export type PurchaseInvoiceCreateOrConnectWithoutTransactionInput = {
    where: PurchaseInvoiceWhereUniqueInput
    create: XOR<PurchaseInvoiceCreateWithoutTransactionInput, PurchaseInvoiceUncheckedCreateWithoutTransactionInput>
  }

  export type CompanyCreateWithoutTransactionsInput = {
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyCreateNestedManyWithoutCompanyInput
    customers?: CustomerCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCompanyInput
    jobs?: JobCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    ports?: PortCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutTransactionsInput = {
    id?: number
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyUncheckedCreateNestedManyWithoutCompanyInput
    customers?: CustomerUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    jobs?: JobUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    ports?: PortUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingUncheckedCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutTransactionsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutTransactionsInput, CompanyUncheckedCreateWithoutTransactionsInput>
  }

  export type AccountEntryUpsertWithWhereUniqueWithoutTransactionInput = {
    where: AccountEntryWhereUniqueInput
    update: XOR<AccountEntryUpdateWithoutTransactionInput, AccountEntryUncheckedUpdateWithoutTransactionInput>
    create: XOR<AccountEntryCreateWithoutTransactionInput, AccountEntryUncheckedCreateWithoutTransactionInput>
  }

  export type AccountEntryUpdateWithWhereUniqueWithoutTransactionInput = {
    where: AccountEntryWhereUniqueInput
    data: XOR<AccountEntryUpdateWithoutTransactionInput, AccountEntryUncheckedUpdateWithoutTransactionInput>
  }

  export type AccountEntryUpdateManyWithWhereWithoutTransactionInput = {
    where: AccountEntryScalarWhereInput
    data: XOR<AccountEntryUpdateManyMutationInput, AccountEntryUncheckedUpdateManyWithoutTransactionInput>
  }

  export type ServiceInvoiceUpsertWithoutTransactionInput = {
    update: XOR<ServiceInvoiceUpdateWithoutTransactionInput, ServiceInvoiceUncheckedUpdateWithoutTransactionInput>
    create: XOR<ServiceInvoiceCreateWithoutTransactionInput, ServiceInvoiceUncheckedCreateWithoutTransactionInput>
    where?: ServiceInvoiceWhereInput
  }

  export type ServiceInvoiceUpdateToOneWithWhereWithoutTransactionInput = {
    where?: ServiceInvoiceWhereInput
    data: XOR<ServiceInvoiceUpdateWithoutTransactionInput, ServiceInvoiceUncheckedUpdateWithoutTransactionInput>
  }

  export type ServiceInvoiceUpdateWithoutTransactionInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    masterNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agentCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingLine?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    creditDays?: NullableIntFieldUpdateOperationsInput | number | null
    vendorType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutServiceInvoicesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutServiceInvoicesNestedInput
    job?: JobUpdateOneRequiredWithoutServiceInvoiceNestedInput
    items?: ServiceInvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type ServiceInvoiceUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    masterNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agentCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingLine?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    creditDays?: NullableIntFieldUpdateOperationsInput | number | null
    vendorType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ServiceInvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type FreightInvoiceUpsertWithoutTransactionInput = {
    update: XOR<FreightInvoiceUpdateWithoutTransactionInput, FreightInvoiceUncheckedUpdateWithoutTransactionInput>
    create: XOR<FreightInvoiceCreateWithoutTransactionInput, FreightInvoiceUncheckedCreateWithoutTransactionInput>
    where?: FreightInvoiceWhereInput
  }

  export type FreightInvoiceUpdateToOneWithWhereWithoutTransactionInput = {
    where?: FreightInvoiceWhereInput
    data: XOR<FreightInvoiceUpdateWithoutTransactionInput, FreightInvoiceUncheckedUpdateWithoutTransactionInput>
  }

  export type FreightInvoiceUpdateWithoutTransactionInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    usdRate?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutFreightInvoicesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutFreightInvoicesNestedInput
    job?: JobUpdateOneWithoutFreightInvoiceNestedInput
    items?: FreightInvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type FreightInvoiceUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: IntFieldUpdateOperationsInput | number
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    usdRate?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    items?: FreightInvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type PaymentUpsertWithoutTransactionInput = {
    update: XOR<PaymentUpdateWithoutTransactionInput, PaymentUncheckedUpdateWithoutTransactionInput>
    create: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutTransactionInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutTransactionInput, PaymentUncheckedUpdateWithoutTransactionInput>
  }

  export type PaymentUpdateWithoutTransactionInput = {
    receiptNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    mode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutPaymentsNestedInput
    customer?: CustomerUpdateOneWithoutPaymentsNestedInput
    vendor?: VendorUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    mode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseInvoiceUpsertWithoutTransactionInput = {
    update: XOR<PurchaseInvoiceUpdateWithoutTransactionInput, PurchaseInvoiceUncheckedUpdateWithoutTransactionInput>
    create: XOR<PurchaseInvoiceCreateWithoutTransactionInput, PurchaseInvoiceUncheckedCreateWithoutTransactionInput>
    where?: PurchaseInvoiceWhereInput
  }

  export type PurchaseInvoiceUpdateToOneWithWhereWithoutTransactionInput = {
    where?: PurchaseInvoiceWhereInput
    data: XOR<PurchaseInvoiceUpdateWithoutTransactionInput, PurchaseInvoiceUncheckedUpdateWithoutTransactionInput>
  }

  export type PurchaseInvoiceUpdateWithoutTransactionInput = {
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutPurchaseInvoicesNestedInput
    vendor?: VendorUpdateOneRequiredWithoutPurchaseInvoicesNestedInput
    items?: PurchaseInvoiceItemUpdateManyWithoutPurchaseInvoiceNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: IntFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: PurchaseInvoiceItemUncheckedUpdateManyWithoutPurchaseInvoiceNestedInput
  }

  export type CompanyUpsertWithoutTransactionsInput = {
    update: XOR<CompanyUpdateWithoutTransactionsInput, CompanyUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CompanyCreateWithoutTransactionsInput, CompanyUncheckedCreateWithoutTransactionsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutTransactionsInput, CompanyUncheckedUpdateWithoutTransactionsInput>
  }

  export type CompanyUpdateWithoutTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCompanyNestedInput
    jobs?: JobUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    ports?: PortUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUncheckedUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    ports?: PortUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUncheckedUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type AccountCreateWithoutEntriesInput = {
    code: string
    name: string
    type: $Enums.AccountType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    company: CompanyCreateNestedOneWithoutAccountsInput
    parent?: AccountCreateNestedOneWithoutChildrenInput
    children?: AccountCreateNestedManyWithoutParentInput
    customer?: CustomerCreateNestedOneWithoutAccountInput
    vendor?: VendorCreateNestedOneWithoutAccountInput
    voucherEntries?: VoucherEntryCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutEntriesInput = {
    id?: number
    code: string
    name: string
    type: $Enums.AccountType
    description?: string | null
    parentId?: number | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    children?: AccountUncheckedCreateNestedManyWithoutParentInput
    customer?: CustomerUncheckedCreateNestedOneWithoutAccountInput
    vendor?: VendorUncheckedCreateNestedOneWithoutAccountInput
    voucherEntries?: VoucherEntryUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutEntriesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutEntriesInput, AccountUncheckedCreateWithoutEntriesInput>
  }

  export type TransactionCreateWithoutEntriesInput = {
    reference: string
    date?: Date | string
    description?: string | null
    type?: $Enums.TransactionType
    createdAt?: Date | string
    updatedAt?: Date | string
    isLocked?: boolean
    service?: ServiceInvoiceCreateNestedOneWithoutTransactionInput
    freight?: FreightInvoiceCreateNestedOneWithoutTransactionInput
    payment?: PaymentCreateNestedOneWithoutTransactionInput
    purchase?: PurchaseInvoiceCreateNestedOneWithoutTransactionInput
    company: CompanyCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutEntriesInput = {
    id?: number
    reference: string
    date?: Date | string
    description?: string | null
    type?: $Enums.TransactionType
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isLocked?: boolean
    service?: ServiceInvoiceUncheckedCreateNestedOneWithoutTransactionInput
    freight?: FreightInvoiceUncheckedCreateNestedOneWithoutTransactionInput
    payment?: PaymentUncheckedCreateNestedOneWithoutTransactionInput
    purchase?: PurchaseInvoiceUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutEntriesInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutEntriesInput, TransactionUncheckedCreateWithoutEntriesInput>
  }

  export type AccountUpsertWithoutEntriesInput = {
    update: XOR<AccountUpdateWithoutEntriesInput, AccountUncheckedUpdateWithoutEntriesInput>
    create: XOR<AccountCreateWithoutEntriesInput, AccountUncheckedCreateWithoutEntriesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutEntriesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutEntriesInput, AccountUncheckedUpdateWithoutEntriesInput>
  }

  export type AccountUpdateWithoutEntriesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutAccountsNestedInput
    parent?: AccountUpdateOneWithoutChildrenNestedInput
    children?: AccountUpdateManyWithoutParentNestedInput
    customer?: CustomerUpdateOneWithoutAccountNestedInput
    vendor?: VendorUpdateOneWithoutAccountNestedInput
    voucherEntries?: VoucherEntryUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    children?: AccountUncheckedUpdateManyWithoutParentNestedInput
    customer?: CustomerUncheckedUpdateOneWithoutAccountNestedInput
    vendor?: VendorUncheckedUpdateOneWithoutAccountNestedInput
    voucherEntries?: VoucherEntryUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type TransactionUpsertWithoutEntriesInput = {
    update: XOR<TransactionUpdateWithoutEntriesInput, TransactionUncheckedUpdateWithoutEntriesInput>
    create: XOR<TransactionCreateWithoutEntriesInput, TransactionUncheckedCreateWithoutEntriesInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutEntriesInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutEntriesInput, TransactionUncheckedUpdateWithoutEntriesInput>
  }

  export type TransactionUpdateWithoutEntriesInput = {
    reference?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    service?: ServiceInvoiceUpdateOneWithoutTransactionNestedInput
    freight?: FreightInvoiceUpdateOneWithoutTransactionNestedInput
    payment?: PaymentUpdateOneWithoutTransactionNestedInput
    purchase?: PurchaseInvoiceUpdateOneWithoutTransactionNestedInput
    company?: CompanyUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    service?: ServiceInvoiceUncheckedUpdateOneWithoutTransactionNestedInput
    freight?: FreightInvoiceUncheckedUpdateOneWithoutTransactionNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutTransactionNestedInput
    purchase?: PurchaseInvoiceUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type CompanyCreateWithoutPaymentsInput = {
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyCreateNestedManyWithoutCompanyInput
    customers?: CustomerCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCompanyInput
    jobs?: JobCreateNestedManyWithoutCompanyInput
    ports?: PortCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPaymentsInput = {
    id?: number
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyUncheckedCreateNestedManyWithoutCompanyInput
    customers?: CustomerUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    jobs?: JobUncheckedCreateNestedManyWithoutCompanyInput
    ports?: PortUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingUncheckedCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPaymentsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPaymentsInput, CompanyUncheckedCreateWithoutPaymentsInput>
  }

  export type CustomerCreateWithoutPaymentsInput = {
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    account?: AccountCreateNestedOneWithoutCustomerInput
    company: CompanyCreateNestedOneWithoutCustomersInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCustomerInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCustomerInput
    jobs?: JobCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutPaymentsInput = {
    id?: number
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    accountId?: number | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    jobs?: JobUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutPaymentsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPaymentsInput, CustomerUncheckedCreateWithoutPaymentsInput>
  }

  export type TransactionCreateWithoutPaymentInput = {
    reference: string
    date?: Date | string
    description?: string | null
    type?: $Enums.TransactionType
    createdAt?: Date | string
    updatedAt?: Date | string
    isLocked?: boolean
    entries?: AccountEntryCreateNestedManyWithoutTransactionInput
    service?: ServiceInvoiceCreateNestedOneWithoutTransactionInput
    freight?: FreightInvoiceCreateNestedOneWithoutTransactionInput
    purchase?: PurchaseInvoiceCreateNestedOneWithoutTransactionInput
    company: CompanyCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutPaymentInput = {
    id?: number
    reference: string
    date?: Date | string
    description?: string | null
    type?: $Enums.TransactionType
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isLocked?: boolean
    entries?: AccountEntryUncheckedCreateNestedManyWithoutTransactionInput
    service?: ServiceInvoiceUncheckedCreateNestedOneWithoutTransactionInput
    freight?: FreightInvoiceUncheckedCreateNestedOneWithoutTransactionInput
    purchase?: PurchaseInvoiceUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutPaymentInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput>
  }

  export type VendorCreateWithoutPaymentsInput = {
    name: string
    code: string
    type?: string | null
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    expenses?: ExpenseCreateNestedManyWithoutVendorInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutVendorInput
    account?: AccountCreateNestedOneWithoutVendorInput
    company: CompanyCreateNestedOneWithoutVendorsInput
    freightItems?: FreightInvoiceItemCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutPaymentsInput = {
    id?: number
    name: string
    code: string
    type?: string | null
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    accountId?: number | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutVendorInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutVendorInput
    freightItems?: FreightInvoiceItemUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutPaymentsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutPaymentsInput, VendorUncheckedCreateWithoutPaymentsInput>
  }

  export type CompanyUpsertWithoutPaymentsInput = {
    update: XOR<CompanyUpdateWithoutPaymentsInput, CompanyUncheckedUpdateWithoutPaymentsInput>
    create: XOR<CompanyCreateWithoutPaymentsInput, CompanyUncheckedCreateWithoutPaymentsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPaymentsInput, CompanyUncheckedUpdateWithoutPaymentsInput>
  }

  export type CompanyUpdateWithoutPaymentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCompanyNestedInput
    jobs?: JobUpdateManyWithoutCompanyNestedInput
    ports?: PortUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUncheckedUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCompanyNestedInput
    ports?: PortUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUncheckedUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CustomerUpsertWithoutPaymentsInput = {
    update: XOR<CustomerUpdateWithoutPaymentsInput, CustomerUncheckedUpdateWithoutPaymentsInput>
    create: XOR<CustomerCreateWithoutPaymentsInput, CustomerUncheckedCreateWithoutPaymentsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutPaymentsInput, CustomerUncheckedUpdateWithoutPaymentsInput>
  }

  export type CustomerUpdateWithoutPaymentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneWithoutCustomerNestedInput
    company?: CompanyUpdateOneRequiredWithoutCustomersNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCustomerNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCustomerNestedInput
    jobs?: JobUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type TransactionUpsertWithoutPaymentInput = {
    update: XOR<TransactionUpdateWithoutPaymentInput, TransactionUncheckedUpdateWithoutPaymentInput>
    create: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutPaymentInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutPaymentInput, TransactionUncheckedUpdateWithoutPaymentInput>
  }

  export type TransactionUpdateWithoutPaymentInput = {
    reference?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    entries?: AccountEntryUpdateManyWithoutTransactionNestedInput
    service?: ServiceInvoiceUpdateOneWithoutTransactionNestedInput
    freight?: FreightInvoiceUpdateOneWithoutTransactionNestedInput
    purchase?: PurchaseInvoiceUpdateOneWithoutTransactionNestedInput
    company?: CompanyUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    entries?: AccountEntryUncheckedUpdateManyWithoutTransactionNestedInput
    service?: ServiceInvoiceUncheckedUpdateOneWithoutTransactionNestedInput
    freight?: FreightInvoiceUncheckedUpdateOneWithoutTransactionNestedInput
    purchase?: PurchaseInvoiceUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type VendorUpsertWithoutPaymentsInput = {
    update: XOR<VendorUpdateWithoutPaymentsInput, VendorUncheckedUpdateWithoutPaymentsInput>
    create: XOR<VendorCreateWithoutPaymentsInput, VendorUncheckedCreateWithoutPaymentsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutPaymentsInput, VendorUncheckedUpdateWithoutPaymentsInput>
  }

  export type VendorUpdateWithoutPaymentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUpdateManyWithoutVendorNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutVendorNestedInput
    account?: AccountUpdateOneWithoutVendorNestedInput
    company?: CompanyUpdateOneRequiredWithoutVendorsNestedInput
    freightItems?: FreightInvoiceItemUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutVendorNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutVendorNestedInput
    freightItems?: FreightInvoiceItemUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type CompanyCreateWithoutAuditLogsInput = {
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyCreateNestedManyWithoutCompanyInput
    customers?: CustomerCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCompanyInput
    jobs?: JobCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    ports?: PortCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAuditLogsInput = {
    id?: number
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyUncheckedCreateNestedManyWithoutCompanyInput
    customers?: CustomerUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    jobs?: JobUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    ports?: PortUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingUncheckedCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAuditLogsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserCreateWithoutAuditLogsInput = {
    email: string
    name?: string | null
    password: string
    role?: $Enums.Role
    branch?: string | null
    department?: string | null
    region?: string | null
    division?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutUsersInput
    postedVouchers?: VoucherCreateNestedManyWithoutPostedByInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: number
    email: string
    name?: string | null
    password: string
    role?: $Enums.Role
    companyId?: number | null
    branch?: string | null
    department?: string | null
    region?: string | null
    division?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postedVouchers?: VoucherUncheckedCreateNestedManyWithoutPostedByInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type CompanyUpsertWithoutAuditLogsInput = {
    update: XOR<CompanyUpdateWithoutAuditLogsInput, CompanyUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAuditLogsInput, CompanyUncheckedUpdateWithoutAuditLogsInput>
  }

  export type CompanyUpdateWithoutAuditLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCompanyNestedInput
    jobs?: JobUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    ports?: PortUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAuditLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUncheckedUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    ports?: PortUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUncheckedUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    branch?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutUsersNestedInput
    postedVouchers?: VoucherUpdateManyWithoutPostedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedVouchers?: VoucherUncheckedUpdateManyWithoutPostedByNestedInput
  }

  export type CompanyCreateWithoutFinancialPeriodsInput = {
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyCreateNestedManyWithoutCompanyInput
    customers?: CustomerCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCompanyInput
    jobs?: JobCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    ports?: PortCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutFinancialPeriodsInput = {
    id?: number
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyUncheckedCreateNestedManyWithoutCompanyInput
    customers?: CustomerUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterUncheckedCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    jobs?: JobUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    ports?: PortUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingUncheckedCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutFinancialPeriodsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutFinancialPeriodsInput, CompanyUncheckedCreateWithoutFinancialPeriodsInput>
  }

  export type CompanyUpsertWithoutFinancialPeriodsInput = {
    update: XOR<CompanyUpdateWithoutFinancialPeriodsInput, CompanyUncheckedUpdateWithoutFinancialPeriodsInput>
    create: XOR<CompanyCreateWithoutFinancialPeriodsInput, CompanyUncheckedCreateWithoutFinancialPeriodsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutFinancialPeriodsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutFinancialPeriodsInput, CompanyUncheckedUpdateWithoutFinancialPeriodsInput>
  }

  export type CompanyUpdateWithoutFinancialPeriodsInput = {
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCompanyNestedInput
    jobs?: JobUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    ports?: PortUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutFinancialPeriodsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUncheckedUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUncheckedUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    ports?: PortUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUncheckedUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type JobCreateWithoutPodInput = {
    jobNumber: string
    date?: Date | string
    jobDate?: Date | string
    jobType?: $Enums.JobType
    status?: $Enums.JobStatus
    vessel?: string | null
    place?: string | null
    shipperRef?: string | null
    gdNo?: string | null
    gdDate?: Date | string | null
    formE?: string | null
    formEDate?: Date | string | null
    commodity?: string | null
    volume?: string | null
    containerNo?: string | null
    packages?: number | null
    weight?: number | null
    hawbBl?: string | null
    handledBy?: string | null
    salesPerson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    division?: string | null
    expenses?: ExpenseCreateNestedManyWithoutJobInput
    serviceInvoice?: ServiceInvoiceCreateNestedOneWithoutJobInput
    freightInvoice?: FreightInvoiceCreateNestedOneWithoutJobInput
    branch?: BranchCreateNestedOneWithoutJobsInput
    company: CompanyCreateNestedOneWithoutJobsInput
    customer: CustomerCreateNestedOneWithoutJobsInput
  }

  export type JobUncheckedCreateWithoutPodInput = {
    id?: number
    jobNumber: string
    date?: Date | string
    jobDate?: Date | string
    jobType?: $Enums.JobType
    status?: $Enums.JobStatus
    customerId: number
    vessel?: string | null
    place?: string | null
    shipperRef?: string | null
    gdNo?: string | null
    gdDate?: Date | string | null
    formE?: string | null
    formEDate?: Date | string | null
    commodity?: string | null
    volume?: string | null
    containerNo?: string | null
    packages?: number | null
    weight?: number | null
    hawbBl?: string | null
    handledBy?: string | null
    salesPerson?: string | null
    companyId: number
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    division?: string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutJobInput
    serviceInvoice?: ServiceInvoiceUncheckedCreateNestedOneWithoutJobInput
    freightInvoice?: FreightInvoiceUncheckedCreateNestedOneWithoutJobInput
  }

  export type JobCreateOrConnectWithoutPodInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutPodInput, JobUncheckedCreateWithoutPodInput>
  }

  export type JobCreateManyPodInputEnvelope = {
    data: JobCreateManyPodInput | JobCreateManyPodInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutPortsInput = {
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyCreateNestedManyWithoutCompanyInput
    customers?: CustomerCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCompanyInput
    jobs?: JobCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPortsInput = {
    id?: number
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyUncheckedCreateNestedManyWithoutCompanyInput
    customers?: CustomerUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    jobs?: JobUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingUncheckedCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPortsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPortsInput, CompanyUncheckedCreateWithoutPortsInput>
  }

  export type JobUpsertWithWhereUniqueWithoutPodInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutPodInput, JobUncheckedUpdateWithoutPodInput>
    create: XOR<JobCreateWithoutPodInput, JobUncheckedCreateWithoutPodInput>
  }

  export type JobUpdateWithWhereUniqueWithoutPodInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutPodInput, JobUncheckedUpdateWithoutPodInput>
  }

  export type JobUpdateManyWithWhereWithoutPodInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutPodInput>
  }

  export type CompanyUpsertWithoutPortsInput = {
    update: XOR<CompanyUpdateWithoutPortsInput, CompanyUncheckedUpdateWithoutPortsInput>
    create: XOR<CompanyCreateWithoutPortsInput, CompanyUncheckedCreateWithoutPortsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPortsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPortsInput, CompanyUncheckedUpdateWithoutPortsInput>
  }

  export type CompanyUpdateWithoutPortsInput = {
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCompanyNestedInput
    jobs?: JobUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPortsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUncheckedUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUncheckedUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutVouchersInput = {
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyCreateNestedManyWithoutCompanyInput
    customers?: CustomerCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceCreateNestedManyWithoutCompanyInput
    jobs?: JobCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    ports?: PortCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutVouchersInput = {
    id?: number
    name: string
    uniqueId: string
    address?: string | null
    phone?: string | null
    email?: string | null
    industry?: string | null
    logo?: string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    country?: string | null
    fiscalYearEnd?: Date | string | null
    fiscalYearStart?: Date | string | null
    postalCode?: string | null
    registrationNo?: string | null
    state?: string | null
    tagline?: string | null
    taxNumber?: string | null
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    currencies?: CompanyCurrencyUncheckedCreateNestedManyWithoutCompanyInput
    customers?: CustomerUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expensesMaster?: ExpenseMasterUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    serviceInvoices?: ServiceInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    freightInvoices?: FreightInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    jobs?: JobUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    ports?: PortUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCompanyInput
    systemSettings?: SystemSettingUncheckedCreateNestedManyWithoutCompanyInput
    taxSettings?: TaxSettingUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutVouchersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutVouchersInput, CompanyUncheckedCreateWithoutVouchersInput>
  }

  export type UserCreateWithoutPostedVouchersInput = {
    email: string
    name?: string | null
    password: string
    role?: $Enums.Role
    branch?: string | null
    department?: string | null
    region?: string | null
    division?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    company?: CompanyCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutPostedVouchersInput = {
    id?: number
    email: string
    name?: string | null
    password: string
    role?: $Enums.Role
    companyId?: number | null
    branch?: string | null
    department?: string | null
    region?: string | null
    division?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostedVouchersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostedVouchersInput, UserUncheckedCreateWithoutPostedVouchersInput>
  }

  export type VoucherEntryCreateWithoutVoucherInput = {
    debit?: number
    credit?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutVoucherEntriesInput
  }

  export type VoucherEntryUncheckedCreateWithoutVoucherInput = {
    id?: number
    accountId: number
    debit?: number
    credit?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoucherEntryCreateOrConnectWithoutVoucherInput = {
    where: VoucherEntryWhereUniqueInput
    create: XOR<VoucherEntryCreateWithoutVoucherInput, VoucherEntryUncheckedCreateWithoutVoucherInput>
  }

  export type VoucherEntryCreateManyVoucherInputEnvelope = {
    data: VoucherEntryCreateManyVoucherInput | VoucherEntryCreateManyVoucherInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutVouchersInput = {
    update: XOR<CompanyUpdateWithoutVouchersInput, CompanyUncheckedUpdateWithoutVouchersInput>
    create: XOR<CompanyCreateWithoutVouchersInput, CompanyUncheckedCreateWithoutVouchersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutVouchersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutVouchersInput, CompanyUncheckedUpdateWithoutVouchersInput>
  }

  export type CompanyUpdateWithoutVouchersInput = {
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCompanyNestedInput
    jobs?: JobUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    ports?: PortUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutVouchersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYearStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    currencies?: CompanyCurrencyUncheckedUpdateManyWithoutCompanyNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expensesMaster?: ExpenseMasterUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    ports?: PortUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCompanyNestedInput
    systemSettings?: SystemSettingUncheckedUpdateManyWithoutCompanyNestedInput
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutPostedVouchersInput = {
    update: XOR<UserUpdateWithoutPostedVouchersInput, UserUncheckedUpdateWithoutPostedVouchersInput>
    create: XOR<UserCreateWithoutPostedVouchersInput, UserUncheckedCreateWithoutPostedVouchersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostedVouchersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostedVouchersInput, UserUncheckedUpdateWithoutPostedVouchersInput>
  }

  export type UserUpdateWithoutPostedVouchersInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    branch?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutPostedVouchersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VoucherEntryUpsertWithWhereUniqueWithoutVoucherInput = {
    where: VoucherEntryWhereUniqueInput
    update: XOR<VoucherEntryUpdateWithoutVoucherInput, VoucherEntryUncheckedUpdateWithoutVoucherInput>
    create: XOR<VoucherEntryCreateWithoutVoucherInput, VoucherEntryUncheckedCreateWithoutVoucherInput>
  }

  export type VoucherEntryUpdateWithWhereUniqueWithoutVoucherInput = {
    where: VoucherEntryWhereUniqueInput
    data: XOR<VoucherEntryUpdateWithoutVoucherInput, VoucherEntryUncheckedUpdateWithoutVoucherInput>
  }

  export type VoucherEntryUpdateManyWithWhereWithoutVoucherInput = {
    where: VoucherEntryScalarWhereInput
    data: XOR<VoucherEntryUpdateManyMutationInput, VoucherEntryUncheckedUpdateManyWithoutVoucherInput>
  }

  export type AccountCreateWithoutVoucherEntriesInput = {
    code: string
    name: string
    type: $Enums.AccountType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    company: CompanyCreateNestedOneWithoutAccountsInput
    parent?: AccountCreateNestedOneWithoutChildrenInput
    children?: AccountCreateNestedManyWithoutParentInput
    entries?: AccountEntryCreateNestedManyWithoutAccountInput
    customer?: CustomerCreateNestedOneWithoutAccountInput
    vendor?: VendorCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutVoucherEntriesInput = {
    id?: number
    code: string
    name: string
    type: $Enums.AccountType
    description?: string | null
    parentId?: number | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
    children?: AccountUncheckedCreateNestedManyWithoutParentInput
    entries?: AccountEntryUncheckedCreateNestedManyWithoutAccountInput
    customer?: CustomerUncheckedCreateNestedOneWithoutAccountInput
    vendor?: VendorUncheckedCreateNestedOneWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutVoucherEntriesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutVoucherEntriesInput, AccountUncheckedCreateWithoutVoucherEntriesInput>
  }

  export type VoucherCreateWithoutEntriesInput = {
    voucherNumber: string
    voucherType: $Enums.VoucherType
    status?: $Enums.VoucherStatus
    date?: Date | string
    postingDate?: Date | string | null
    paymentMode?: $Enums.PaymentMode | null
    instrumentNo?: string | null
    instrumentDate?: Date | string | null
    bankName?: string | null
    narration?: string | null
    division?: string | null
    isPosted?: boolean
    postedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutVouchersInput
    postedBy?: UserCreateNestedOneWithoutPostedVouchersInput
  }

  export type VoucherUncheckedCreateWithoutEntriesInput = {
    id?: number
    voucherNumber: string
    voucherType: $Enums.VoucherType
    status?: $Enums.VoucherStatus
    date?: Date | string
    postingDate?: Date | string | null
    paymentMode?: $Enums.PaymentMode | null
    instrumentNo?: string | null
    instrumentDate?: Date | string | null
    bankName?: string | null
    narration?: string | null
    companyId: number
    division?: string | null
    isPosted?: boolean
    postedAt?: Date | string | null
    postedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoucherCreateOrConnectWithoutEntriesInput = {
    where: VoucherWhereUniqueInput
    create: XOR<VoucherCreateWithoutEntriesInput, VoucherUncheckedCreateWithoutEntriesInput>
  }

  export type AccountUpsertWithoutVoucherEntriesInput = {
    update: XOR<AccountUpdateWithoutVoucherEntriesInput, AccountUncheckedUpdateWithoutVoucherEntriesInput>
    create: XOR<AccountCreateWithoutVoucherEntriesInput, AccountUncheckedCreateWithoutVoucherEntriesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutVoucherEntriesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutVoucherEntriesInput, AccountUncheckedUpdateWithoutVoucherEntriesInput>
  }

  export type AccountUpdateWithoutVoucherEntriesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutAccountsNestedInput
    parent?: AccountUpdateOneWithoutChildrenNestedInput
    children?: AccountUpdateManyWithoutParentNestedInput
    entries?: AccountEntryUpdateManyWithoutAccountNestedInput
    customer?: CustomerUpdateOneWithoutAccountNestedInput
    vendor?: VendorUpdateOneWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutVoucherEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    children?: AccountUncheckedUpdateManyWithoutParentNestedInput
    entries?: AccountEntryUncheckedUpdateManyWithoutAccountNestedInput
    customer?: CustomerUncheckedUpdateOneWithoutAccountNestedInput
    vendor?: VendorUncheckedUpdateOneWithoutAccountNestedInput
  }

  export type VoucherUpsertWithoutEntriesInput = {
    update: XOR<VoucherUpdateWithoutEntriesInput, VoucherUncheckedUpdateWithoutEntriesInput>
    create: XOR<VoucherCreateWithoutEntriesInput, VoucherUncheckedCreateWithoutEntriesInput>
    where?: VoucherWhereInput
  }

  export type VoucherUpdateToOneWithWhereWithoutEntriesInput = {
    where?: VoucherWhereInput
    data: XOR<VoucherUpdateWithoutEntriesInput, VoucherUncheckedUpdateWithoutEntriesInput>
  }

  export type VoucherUpdateWithoutEntriesInput = {
    voucherNumber?: StringFieldUpdateOperationsInput | string
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    postingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    instrumentNo?: NullableStringFieldUpdateOperationsInput | string | null
    instrumentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutVouchersNestedInput
    postedBy?: UserUpdateOneWithoutPostedVouchersNestedInput
  }

  export type VoucherUncheckedUpdateWithoutEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    voucherNumber?: StringFieldUpdateOperationsInput | string
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    postingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    instrumentNo?: NullableStringFieldUpdateOperationsInput | string | null
    instrumentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    division?: NullableStringFieldUpdateOperationsInput | string | null
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyCompanyInput = {
    id?: number
    code: string
    name: string
    type: $Enums.AccountType
    description?: string | null
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
  }

  export type AuditLogCreateManyCompanyInput = {
    id?: number
    userId: number
    action: string
    module: string
    entityId?: number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type BranchCreateManyCompanyInput = {
    id?: number
    name: string
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyCurrencyCreateManyCompanyInput = {
    id?: number
    currencyId: number
    exchangeRate?: number
    isDefault?: boolean
  }

  export type CustomerCreateManyCompanyInput = {
    id?: number
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    accountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
  }

  export type ExpenseCreateManyCompanyInput = {
    id?: number
    jobId: number
    vendorId?: number | null
    description: string
    costPrice?: number
    sellingPrice?: number
    currencyCode?: string
    exchangeRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseMasterCreateManyCompanyInput = {
    id?: number
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancialPeriodCreateManyCompanyInput = {
    id?: number
    month: number
    year: number
    isClosed?: boolean
    closedById?: number | null
    closedAt?: Date | string | null
  }

  export type ServiceInvoiceCreateManyCompanyInput = {
    id?: number
    invoiceNumber: string
    date?: Date | string
    jobId: number
    customerId: number
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    masterNumber?: string | null
    agentCode?: string | null
    shippingLine?: string | null
    origin?: string | null
    destination?: string | null
    creditDays?: number | null
    vendorType?: string | null
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    exchangeRate?: number
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId?: number | null
    division?: string | null
  }

  export type FreightInvoiceCreateManyCompanyInput = {
    id?: number
    invoiceNumber: string
    date?: Date | string
    jobId?: number | null
    customerId: number
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    usdRate?: number
    exchangeRate?: number
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId?: number | null
    division?: string | null
  }

  export type JobCreateManyCompanyInput = {
    id?: number
    jobNumber: string
    date?: Date | string
    jobDate?: Date | string
    jobType?: $Enums.JobType
    status?: $Enums.JobStatus
    customerId: number
    vessel?: string | null
    place?: string | null
    shipperRef?: string | null
    gdNo?: string | null
    gdDate?: Date | string | null
    formE?: string | null
    formEDate?: Date | string | null
    commodity?: string | null
    volume?: string | null
    containerNo?: string | null
    podId?: number | null
    packages?: number | null
    weight?: number | null
    hawbBl?: string | null
    handledBy?: string | null
    salesPerson?: string | null
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    division?: string | null
  }

  export type PaymentCreateManyCompanyInput = {
    id?: number
    receiptNumber: string
    date?: Date | string
    amount: number
    mode?: $Enums.PaymentMode
    reference?: string | null
    customerId?: number | null
    vendorId?: number | null
    transactionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
  }

  export type PortCreateManyCompanyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateManyCompanyInput = {
    id?: number
    sku?: string | null
    name: string
    description?: string | null
    unit?: string
    purchasePrice?: number
    sellingPrice?: number
    categoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductCategoryCreateManyCompanyInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceCreateManyCompanyInput = {
    id?: number
    purchaseNumber: string
    date?: Date | string
    vendorId: number
    status?: $Enums.InvoiceStatus
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    transactionId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type StockMovementCreateManyCompanyInput = {
    id?: number
    productId: number
    warehouseId?: number | null
    quantity: number
    type: string
    reference?: string | null
    createdAt?: Date | string
  }

  export type SystemSettingCreateManyCompanyInput = {
    id?: number
    key: string
    value: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxSettingCreateManyCompanyInput = {
    id?: number
    name: string
    percentage: number
    type: string
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyCompanyInput = {
    id?: number
    reference: string
    date?: Date | string
    description?: string | null
    type?: $Enums.TransactionType
    createdAt?: Date | string
    updatedAt?: Date | string
    isLocked?: boolean
  }

  export type UserCreateManyCompanyInput = {
    id?: number
    email: string
    name?: string | null
    password: string
    role?: $Enums.Role
    branch?: string | null
    department?: string | null
    region?: string | null
    division?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorCreateManyCompanyInput = {
    id?: number
    name: string
    code: string
    type?: string | null
    address?: string | null
    phone?: string | null
    email?: string | null
    taxNumber?: string | null
    accountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
  }

  export type VoucherCreateManyCompanyInput = {
    id?: number
    voucherNumber: string
    voucherType: $Enums.VoucherType
    status?: $Enums.VoucherStatus
    date?: Date | string
    postingDate?: Date | string | null
    paymentMode?: $Enums.PaymentMode | null
    instrumentNo?: string | null
    instrumentDate?: Date | string | null
    bankName?: string | null
    narration?: string | null
    division?: string | null
    isPosted?: boolean
    postedAt?: Date | string | null
    postedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseCreateManyCompanyInput = {
    id?: number
    name: string
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutCompanyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    parent?: AccountUpdateOneWithoutChildrenNestedInput
    children?: AccountUpdateManyWithoutParentNestedInput
    entries?: AccountEntryUpdateManyWithoutAccountNestedInput
    customer?: CustomerUpdateOneWithoutAccountNestedInput
    vendor?: VendorUpdateOneWithoutAccountNestedInput
    voucherEntries?: VoucherEntryUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    children?: AccountUncheckedUpdateManyWithoutParentNestedInput
    entries?: AccountEntryUncheckedUpdateManyWithoutAccountNestedInput
    customer?: CustomerUncheckedUpdateOneWithoutAccountNestedInput
    vendor?: VendorUncheckedUpdateOneWithoutAccountNestedInput
    voucherEntries?: VoucherEntryUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUpdateWithoutCompanyInput = {
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUpdateManyWithoutBranchNestedInput
    taxSettings?: TaxSettingUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutBranchNestedInput
    taxSettings?: TaxSettingUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCurrencyUpdateWithoutCompanyInput = {
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    currency?: CurrencyUpdateOneRequiredWithoutCompaniesNestedInput
  }

  export type CompanyCurrencyUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    currencyId?: IntFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CompanyCurrencyUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    currencyId?: IntFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CustomerUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneWithoutCustomerNestedInput
    serviceInvoices?: ServiceInvoiceUpdateManyWithoutCustomerNestedInput
    freightInvoices?: FreightInvoiceUpdateManyWithoutCustomerNestedInput
    jobs?: JobUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    serviceInvoices?: ServiceInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    freightInvoices?: FreightInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseUpdateWithoutCompanyInput = {
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutExpensesNestedInput
    vendor?: VendorUpdateOneWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobId?: IntFieldUpdateOperationsInput | number
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobId?: IntFieldUpdateOperationsInput | number
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseMasterUpdateWithoutCompanyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseMasterUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseMasterUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialPeriodUpdateWithoutCompanyInput = {
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedById?: NullableIntFieldUpdateOperationsInput | number | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FinancialPeriodUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedById?: NullableIntFieldUpdateOperationsInput | number | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FinancialPeriodUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedById?: NullableIntFieldUpdateOperationsInput | number | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceInvoiceUpdateWithoutCompanyInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    masterNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agentCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingLine?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    creditDays?: NullableIntFieldUpdateOperationsInput | number | null
    vendorType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneRequiredWithoutServiceInvoicesNestedInput
    job?: JobUpdateOneRequiredWithoutServiceInvoiceNestedInput
    transaction?: TransactionUpdateOneWithoutServiceNestedInput
    items?: ServiceInvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type ServiceInvoiceUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    masterNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agentCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingLine?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    creditDays?: NullableIntFieldUpdateOperationsInput | number | null
    vendorType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ServiceInvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type ServiceInvoiceUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    masterNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agentCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingLine?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    creditDays?: NullableIntFieldUpdateOperationsInput | number | null
    vendorType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FreightInvoiceUpdateWithoutCompanyInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    usdRate?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneRequiredWithoutFreightInvoicesNestedInput
    transaction?: TransactionUpdateOneWithoutFreightNestedInput
    job?: JobUpdateOneWithoutFreightInvoiceNestedInput
    items?: FreightInvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type FreightInvoiceUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: IntFieldUpdateOperationsInput | number
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    usdRate?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    items?: FreightInvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type FreightInvoiceUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: IntFieldUpdateOperationsInput | number
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    usdRate?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobUpdateWithoutCompanyInput = {
    jobNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    place?: NullableStringFieldUpdateOperationsInput | string | null
    shipperRef?: NullableStringFieldUpdateOperationsInput | string | null
    gdNo?: NullableStringFieldUpdateOperationsInput | string | null
    gdDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formE?: NullableStringFieldUpdateOperationsInput | string | null
    formEDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commodity?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    containerNo?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    hawbBl?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    salesPerson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUpdateManyWithoutJobNestedInput
    serviceInvoice?: ServiceInvoiceUpdateOneWithoutJobNestedInput
    freightInvoice?: FreightInvoiceUpdateOneWithoutJobNestedInput
    branch?: BranchUpdateOneWithoutJobsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutJobsNestedInput
    pod?: PortUpdateOneWithoutJobsNestedInput
  }

  export type JobUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    customerId?: IntFieldUpdateOperationsInput | number
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    place?: NullableStringFieldUpdateOperationsInput | string | null
    shipperRef?: NullableStringFieldUpdateOperationsInput | string | null
    gdNo?: NullableStringFieldUpdateOperationsInput | string | null
    gdDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formE?: NullableStringFieldUpdateOperationsInput | string | null
    formEDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commodity?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    containerNo?: NullableStringFieldUpdateOperationsInput | string | null
    podId?: NullableIntFieldUpdateOperationsInput | number | null
    packages?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    hawbBl?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    salesPerson?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutJobNestedInput
    serviceInvoice?: ServiceInvoiceUncheckedUpdateOneWithoutJobNestedInput
    freightInvoice?: FreightInvoiceUncheckedUpdateOneWithoutJobNestedInput
  }

  export type JobUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    customerId?: IntFieldUpdateOperationsInput | number
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    place?: NullableStringFieldUpdateOperationsInput | string | null
    shipperRef?: NullableStringFieldUpdateOperationsInput | string | null
    gdNo?: NullableStringFieldUpdateOperationsInput | string | null
    gdDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formE?: NullableStringFieldUpdateOperationsInput | string | null
    formEDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commodity?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    containerNo?: NullableStringFieldUpdateOperationsInput | string | null
    podId?: NullableIntFieldUpdateOperationsInput | number | null
    packages?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    hawbBl?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    salesPerson?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUpdateWithoutCompanyInput = {
    receiptNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    mode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutPaymentsNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutPaymentNestedInput
    vendor?: VendorUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    mode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    transactionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    mode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    transactionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PortUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUpdateManyWithoutPodNestedInput
  }

  export type PortUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutPodNestedInput
  }

  export type PortUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutCompanyInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceItems?: ServiceInvoiceItemUpdateManyWithoutProductNestedInput
    category?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    purchaseItems?: PurchaseInvoiceItemUpdateManyWithoutProductNestedInput
    movements?: StockMovementUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceItems?: ServiceInvoiceItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutProductNestedInput
    movements?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCategoryUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceUpdateWithoutCompanyInput = {
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction?: TransactionUpdateOneWithoutPurchaseNestedInput
    vendor?: VendorUpdateOneRequiredWithoutPurchaseInvoicesNestedInput
    items?: PurchaseInvoiceItemUpdateManyWithoutPurchaseInvoiceNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: IntFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: PurchaseInvoiceItemUncheckedUpdateManyWithoutPurchaseInvoiceNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: IntFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockMovementUpdateWithoutCompanyInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutMovementsNestedInput
    warehouse?: WarehouseUpdateOneWithoutStockMovementsNestedInput
  }

  export type StockMovementUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    warehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    warehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUpdateWithoutCompanyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxSettingUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutTaxSettingsNestedInput
  }

  export type TaxSettingUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxSettingUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutCompanyInput = {
    reference?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    entries?: AccountEntryUpdateManyWithoutTransactionNestedInput
    service?: ServiceInvoiceUpdateOneWithoutTransactionNestedInput
    freight?: FreightInvoiceUpdateOneWithoutTransactionNestedInput
    payment?: PaymentUpdateOneWithoutTransactionNestedInput
    purchase?: PurchaseInvoiceUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    entries?: AccountEntryUncheckedUpdateManyWithoutTransactionNestedInput
    service?: ServiceInvoiceUncheckedUpdateOneWithoutTransactionNestedInput
    freight?: FreightInvoiceUncheckedUpdateOneWithoutTransactionNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutTransactionNestedInput
    purchase?: PurchaseInvoiceUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpdateWithoutCompanyInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    branch?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    postedVouchers?: VoucherUpdateManyWithoutPostedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    branch?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    postedVouchers?: VoucherUncheckedUpdateManyWithoutPostedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    branch?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUpdateManyWithoutVendorNestedInput
    payments?: PaymentUpdateManyWithoutVendorNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutVendorNestedInput
    account?: AccountUpdateOneWithoutVendorNestedInput
    freightItems?: FreightInvoiceItemUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutVendorNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutVendorNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutVendorNestedInput
    freightItems?: FreightInvoiceItemUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VoucherUpdateWithoutCompanyInput = {
    voucherNumber?: StringFieldUpdateOperationsInput | string
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    postingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    instrumentNo?: NullableStringFieldUpdateOperationsInput | string | null
    instrumentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedBy?: UserUpdateOneWithoutPostedVouchersNestedInput
    entries?: VoucherEntryUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    voucherNumber?: StringFieldUpdateOperationsInput | string
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    postingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    instrumentNo?: NullableStringFieldUpdateOperationsInput | string | null
    instrumentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: VoucherEntryUncheckedUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    voucherNumber?: StringFieldUpdateOperationsInput | string
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    postingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    instrumentNo?: NullableStringFieldUpdateOperationsInput | string | null
    instrumentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockMovements?: StockMovementUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockMovements?: StockMovementUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobCreateManyBranchInput = {
    id?: number
    jobNumber: string
    date?: Date | string
    jobDate?: Date | string
    jobType?: $Enums.JobType
    status?: $Enums.JobStatus
    customerId: number
    vessel?: string | null
    place?: string | null
    shipperRef?: string | null
    gdNo?: string | null
    gdDate?: Date | string | null
    formE?: string | null
    formEDate?: Date | string | null
    commodity?: string | null
    volume?: string | null
    containerNo?: string | null
    podId?: number | null
    packages?: number | null
    weight?: number | null
    hawbBl?: string | null
    handledBy?: string | null
    salesPerson?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    division?: string | null
  }

  export type TaxSettingCreateManyBranchInput = {
    id?: number
    name: string
    percentage: number
    type: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobUpdateWithoutBranchInput = {
    jobNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    place?: NullableStringFieldUpdateOperationsInput | string | null
    shipperRef?: NullableStringFieldUpdateOperationsInput | string | null
    gdNo?: NullableStringFieldUpdateOperationsInput | string | null
    gdDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formE?: NullableStringFieldUpdateOperationsInput | string | null
    formEDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commodity?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    containerNo?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    hawbBl?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    salesPerson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUpdateManyWithoutJobNestedInput
    serviceInvoice?: ServiceInvoiceUpdateOneWithoutJobNestedInput
    freightInvoice?: FreightInvoiceUpdateOneWithoutJobNestedInput
    company?: CompanyUpdateOneRequiredWithoutJobsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutJobsNestedInput
    pod?: PortUpdateOneWithoutJobsNestedInput
  }

  export type JobUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    customerId?: IntFieldUpdateOperationsInput | number
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    place?: NullableStringFieldUpdateOperationsInput | string | null
    shipperRef?: NullableStringFieldUpdateOperationsInput | string | null
    gdNo?: NullableStringFieldUpdateOperationsInput | string | null
    gdDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formE?: NullableStringFieldUpdateOperationsInput | string | null
    formEDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commodity?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    containerNo?: NullableStringFieldUpdateOperationsInput | string | null
    podId?: NullableIntFieldUpdateOperationsInput | number | null
    packages?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    hawbBl?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    salesPerson?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutJobNestedInput
    serviceInvoice?: ServiceInvoiceUncheckedUpdateOneWithoutJobNestedInput
    freightInvoice?: FreightInvoiceUncheckedUpdateOneWithoutJobNestedInput
  }

  export type JobUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    customerId?: IntFieldUpdateOperationsInput | number
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    place?: NullableStringFieldUpdateOperationsInput | string | null
    shipperRef?: NullableStringFieldUpdateOperationsInput | string | null
    gdNo?: NullableStringFieldUpdateOperationsInput | string | null
    gdDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formE?: NullableStringFieldUpdateOperationsInput | string | null
    formEDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commodity?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    containerNo?: NullableStringFieldUpdateOperationsInput | string | null
    podId?: NullableIntFieldUpdateOperationsInput | number | null
    packages?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    hawbBl?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    salesPerson?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaxSettingUpdateWithoutBranchInput = {
    name?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutTaxSettingsNestedInput
  }

  export type TaxSettingUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxSettingUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCurrencyCreateManyCurrencyInput = {
    id?: number
    companyId: number
    exchangeRate?: number
    isDefault?: boolean
  }

  export type CompanyCurrencyUpdateWithoutCurrencyInput = {
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    company?: CompanyUpdateOneRequiredWithoutCurrenciesNestedInput
  }

  export type CompanyCurrencyUncheckedUpdateWithoutCurrencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CompanyCurrencyUncheckedUpdateManyWithoutCurrencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuditLogCreateManyUserInput = {
    id?: number
    action: string
    module: string
    entityId?: number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
    companyId: number
  }

  export type VoucherCreateManyPostedByInput = {
    id?: number
    voucherNumber: string
    voucherType: $Enums.VoucherType
    status?: $Enums.VoucherStatus
    date?: Date | string
    postingDate?: Date | string | null
    paymentMode?: $Enums.PaymentMode | null
    instrumentNo?: string | null
    instrumentDate?: Date | string | null
    bankName?: string | null
    narration?: string | null
    companyId: number
    division?: string | null
    isPosted?: boolean
    postedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
  }

  export type VoucherUpdateWithoutPostedByInput = {
    voucherNumber?: StringFieldUpdateOperationsInput | string
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    postingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    instrumentNo?: NullableStringFieldUpdateOperationsInput | string | null
    instrumentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutVouchersNestedInput
    entries?: VoucherEntryUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateWithoutPostedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    voucherNumber?: StringFieldUpdateOperationsInput | string
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    postingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    instrumentNo?: NullableStringFieldUpdateOperationsInput | string | null
    instrumentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    division?: NullableStringFieldUpdateOperationsInput | string | null
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: VoucherEntryUncheckedUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateManyWithoutPostedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    voucherNumber?: StringFieldUpdateOperationsInput | string
    voucherType?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    postingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    instrumentNo?: NullableStringFieldUpdateOperationsInput | string | null
    instrumentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    division?: NullableStringFieldUpdateOperationsInput | string | null
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceInvoiceCreateManyCustomerInput = {
    id?: number
    invoiceNumber: string
    date?: Date | string
    jobId: number
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    masterNumber?: string | null
    agentCode?: string | null
    shippingLine?: string | null
    origin?: string | null
    destination?: string | null
    creditDays?: number | null
    vendorType?: string | null
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    exchangeRate?: number
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId?: number | null
    division?: string | null
  }

  export type FreightInvoiceCreateManyCustomerInput = {
    id?: number
    invoiceNumber: string
    date?: Date | string
    jobId?: number | null
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    usdRate?: number
    exchangeRate?: number
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId?: number | null
    division?: string | null
  }

  export type JobCreateManyCustomerInput = {
    id?: number
    jobNumber: string
    date?: Date | string
    jobDate?: Date | string
    jobType?: $Enums.JobType
    status?: $Enums.JobStatus
    vessel?: string | null
    place?: string | null
    shipperRef?: string | null
    gdNo?: string | null
    gdDate?: Date | string | null
    formE?: string | null
    formEDate?: Date | string | null
    commodity?: string | null
    volume?: string | null
    containerNo?: string | null
    podId?: number | null
    packages?: number | null
    weight?: number | null
    hawbBl?: string | null
    handledBy?: string | null
    salesPerson?: string | null
    companyId: number
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    division?: string | null
  }

  export type PaymentCreateManyCustomerInput = {
    id?: number
    receiptNumber: string
    date?: Date | string
    amount: number
    mode?: $Enums.PaymentMode
    reference?: string | null
    vendorId?: number | null
    transactionId: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
  }

  export type ServiceInvoiceUpdateWithoutCustomerInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    masterNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agentCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingLine?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    creditDays?: NullableIntFieldUpdateOperationsInput | number | null
    vendorType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutServiceInvoicesNestedInput
    job?: JobUpdateOneRequiredWithoutServiceInvoiceNestedInput
    transaction?: TransactionUpdateOneWithoutServiceNestedInput
    items?: ServiceInvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type ServiceInvoiceUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobId?: IntFieldUpdateOperationsInput | number
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    masterNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agentCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingLine?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    creditDays?: NullableIntFieldUpdateOperationsInput | number | null
    vendorType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ServiceInvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type ServiceInvoiceUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobId?: IntFieldUpdateOperationsInput | number
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    masterNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agentCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingLine?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    creditDays?: NullableIntFieldUpdateOperationsInput | number | null
    vendorType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FreightInvoiceUpdateWithoutCustomerInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    usdRate?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutFreightInvoicesNestedInput
    transaction?: TransactionUpdateOneWithoutFreightNestedInput
    job?: JobUpdateOneWithoutFreightInvoiceNestedInput
    items?: FreightInvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type FreightInvoiceUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    usdRate?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    items?: FreightInvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type FreightInvoiceUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    usdRate?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobUpdateWithoutCustomerInput = {
    jobNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    place?: NullableStringFieldUpdateOperationsInput | string | null
    shipperRef?: NullableStringFieldUpdateOperationsInput | string | null
    gdNo?: NullableStringFieldUpdateOperationsInput | string | null
    gdDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formE?: NullableStringFieldUpdateOperationsInput | string | null
    formEDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commodity?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    containerNo?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    hawbBl?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    salesPerson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUpdateManyWithoutJobNestedInput
    serviceInvoice?: ServiceInvoiceUpdateOneWithoutJobNestedInput
    freightInvoice?: FreightInvoiceUpdateOneWithoutJobNestedInput
    branch?: BranchUpdateOneWithoutJobsNestedInput
    company?: CompanyUpdateOneRequiredWithoutJobsNestedInput
    pod?: PortUpdateOneWithoutJobsNestedInput
  }

  export type JobUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    place?: NullableStringFieldUpdateOperationsInput | string | null
    shipperRef?: NullableStringFieldUpdateOperationsInput | string | null
    gdNo?: NullableStringFieldUpdateOperationsInput | string | null
    gdDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formE?: NullableStringFieldUpdateOperationsInput | string | null
    formEDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commodity?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    containerNo?: NullableStringFieldUpdateOperationsInput | string | null
    podId?: NullableIntFieldUpdateOperationsInput | number | null
    packages?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    hawbBl?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    salesPerson?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutJobNestedInput
    serviceInvoice?: ServiceInvoiceUncheckedUpdateOneWithoutJobNestedInput
    freightInvoice?: FreightInvoiceUncheckedUpdateOneWithoutJobNestedInput
  }

  export type JobUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    place?: NullableStringFieldUpdateOperationsInput | string | null
    shipperRef?: NullableStringFieldUpdateOperationsInput | string | null
    gdNo?: NullableStringFieldUpdateOperationsInput | string | null
    gdDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formE?: NullableStringFieldUpdateOperationsInput | string | null
    formEDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commodity?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    containerNo?: NullableStringFieldUpdateOperationsInput | string | null
    podId?: NullableIntFieldUpdateOperationsInput | number | null
    packages?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    hawbBl?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    salesPerson?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUpdateWithoutCustomerInput = {
    receiptNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    mode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutPaymentsNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutPaymentNestedInput
    vendor?: VendorUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    mode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    transactionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    mode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    transactionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseCreateManyVendorInput = {
    id?: number
    jobId: number
    description: string
    costPrice?: number
    sellingPrice?: number
    currencyCode?: string
    exchangeRate?: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyVendorInput = {
    id?: number
    receiptNumber: string
    date?: Date | string
    amount: number
    mode?: $Enums.PaymentMode
    reference?: string | null
    customerId?: number | null
    transactionId: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
  }

  export type PurchaseInvoiceCreateManyVendorInput = {
    id?: number
    purchaseNumber: string
    date?: Date | string
    status?: $Enums.InvoiceStatus
    totalAmount?: number
    taxAmount?: number
    grandTotal?: number
    currencyCode?: string
    isApproved?: boolean
    approvedById?: number | null
    isLocked?: boolean
    lockedAt?: Date | string | null
    companyId: number
    transactionId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type FreightInvoiceItemCreateManyVendorInput = {
    id?: number
    invoiceId: number
    description: string
    quantity?: number
    rate?: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
  }

  export type ExpenseUpdateWithoutVendorInput = {
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutExpensesNestedInput
    job?: JobUpdateOneRequiredWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutVendorInput = {
    receiptNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    mode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutPaymentsNestedInput
    customer?: CustomerUpdateOneWithoutPaymentsNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    mode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    transactionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    mode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    transactionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseInvoiceUpdateWithoutVendorInput = {
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutPurchaseInvoicesNestedInput
    transaction?: TransactionUpdateOneWithoutPurchaseNestedInput
    items?: PurchaseInvoiceItemUpdateManyWithoutPurchaseInvoiceNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: PurchaseInvoiceItemUncheckedUpdateManyWithoutPurchaseInvoiceNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateManyWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FreightInvoiceItemUpdateWithoutVendorInput = {
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    invoice?: FreightInvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type FreightInvoiceItemUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type FreightInvoiceItemUncheckedUpdateManyWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type ExpenseCreateManyJobInput = {
    id?: number
    vendorId?: number | null
    description: string
    costPrice?: number
    sellingPrice?: number
    currencyCode?: string
    exchangeRate?: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateWithoutJobInput = {
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutExpensesNestedInput
    vendor?: VendorUpdateOneWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutJobInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyWithoutJobInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    currencyCode?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceInvoiceItemCreateManyInvoiceInput = {
    id?: number
    description: string
    quantity?: number
    rate?: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
    productId?: number | null
  }

  export type ServiceInvoiceItemUpdateWithoutInvoiceInput = {
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    product?: ProductUpdateOneWithoutServiceItemsNestedInput
  }

  export type ServiceInvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ServiceInvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FreightInvoiceItemCreateManyInvoiceInput = {
    id?: number
    description: string
    quantity?: number
    rate?: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
    vendorId?: number | null
  }

  export type FreightInvoiceItemUpdateWithoutInvoiceInput = {
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    vendor?: VendorUpdateOneWithoutFreightItemsNestedInput
  }

  export type FreightInvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FreightInvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductCreateManyCategoryInput = {
    id?: number
    sku?: string | null
    name: string
    description?: string | null
    unit?: string
    purchasePrice?: number
    sellingPrice?: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductUpdateWithoutCategoryInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceItems?: ServiceInvoiceItemUpdateManyWithoutProductNestedInput
    company?: CompanyUpdateOneRequiredWithoutProductsNestedInput
    purchaseItems?: PurchaseInvoiceItemUpdateManyWithoutProductNestedInput
    movements?: StockMovementUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceItems?: ServiceInvoiceItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutProductNestedInput
    movements?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceInvoiceItemCreateManyProductInput = {
    id?: number
    invoiceId: number
    description: string
    quantity?: number
    rate?: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
  }

  export type PurchaseInvoiceItemCreateManyProductInput = {
    id?: number
    purchaseInvoiceId: number
    description?: string | null
    quantity: number
    rate: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
  }

  export type StockMovementCreateManyProductInput = {
    id?: number
    warehouseId?: number | null
    quantity: number
    type: string
    reference?: string | null
    companyId: number
    createdAt?: Date | string
  }

  export type ServiceInvoiceItemUpdateWithoutProductInput = {
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    invoice?: ServiceInvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ServiceInvoiceItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type ServiceInvoiceItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type PurchaseInvoiceItemUpdateWithoutProductInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    purchaseInvoice?: PurchaseInvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PurchaseInvoiceItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseInvoiceId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseInvoiceId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type StockMovementUpdateWithoutProductInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutStockMovementsNestedInput
    warehouse?: WarehouseUpdateOneWithoutStockMovementsNestedInput
  }

  export type StockMovementUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    warehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    warehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementCreateManyWarehouseInput = {
    id?: number
    productId: number
    quantity: number
    type: string
    reference?: string | null
    companyId: number
    createdAt?: Date | string
  }

  export type StockMovementUpdateWithoutWarehouseInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutStockMovementsNestedInput
    product?: ProductUpdateOneRequiredWithoutMovementsNestedInput
  }

  export type StockMovementUncheckedUpdateWithoutWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateManyWithoutWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemCreateManyPurchaseInvoiceInput = {
    id?: number
    productId: number
    description?: string | null
    quantity: number
    rate: number
    amount: number
    taxPercentage?: number
    taxAmount?: number
    total: number
  }

  export type PurchaseInvoiceItemUpdateWithoutPurchaseInvoiceInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutPurchaseItemsNestedInput
  }

  export type PurchaseInvoiceItemUncheckedUpdateWithoutPurchaseInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyWithoutPurchaseInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxPercentage?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type AccountCreateManyParentInput = {
    id?: number
    code: string
    name: string
    type: $Enums.AccountType
    description?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: string | null
  }

  export type AccountEntryCreateManyAccountInput = {
    id?: number
    transactionId: number
    description?: string | null
    debit?: number
    credit?: number
    createdAt?: Date | string
  }

  export type VoucherEntryCreateManyAccountInput = {
    id?: number
    voucherId: number
    debit?: number
    credit?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutParentInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutAccountsNestedInput
    children?: AccountUpdateManyWithoutParentNestedInput
    entries?: AccountEntryUpdateManyWithoutAccountNestedInput
    customer?: CustomerUpdateOneWithoutAccountNestedInput
    vendor?: VendorUpdateOneWithoutAccountNestedInput
    voucherEntries?: VoucherEntryUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
    children?: AccountUncheckedUpdateManyWithoutParentNestedInput
    entries?: AccountEntryUncheckedUpdateManyWithoutAccountNestedInput
    customer?: CustomerUncheckedUpdateOneWithoutAccountNestedInput
    vendor?: VendorUncheckedUpdateOneWithoutAccountNestedInput
    voucherEntries?: VoucherEntryUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountEntryUpdateWithoutAccountInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutEntriesNestedInput
  }

  export type AccountEntryUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountEntryUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherEntryUpdateWithoutAccountInput = {
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voucher?: VoucherUpdateOneRequiredWithoutEntriesNestedInput
  }

  export type VoucherEntryUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    voucherId?: IntFieldUpdateOperationsInput | number
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherEntryUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    voucherId?: IntFieldUpdateOperationsInput | number
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountEntryCreateManyTransactionInput = {
    id?: number
    accountId: number
    description?: string | null
    debit?: number
    credit?: number
    createdAt?: Date | string
  }

  export type AccountEntryUpdateWithoutTransactionInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutEntriesNestedInput
  }

  export type AccountEntryUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountEntryUncheckedUpdateManyWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobCreateManyPodInput = {
    id?: number
    jobNumber: string
    date?: Date | string
    jobDate?: Date | string
    jobType?: $Enums.JobType
    status?: $Enums.JobStatus
    customerId: number
    vessel?: string | null
    place?: string | null
    shipperRef?: string | null
    gdNo?: string | null
    gdDate?: Date | string | null
    formE?: string | null
    formEDate?: Date | string | null
    commodity?: string | null
    volume?: string | null
    containerNo?: string | null
    packages?: number | null
    weight?: number | null
    hawbBl?: string | null
    handledBy?: string | null
    salesPerson?: string | null
    companyId: number
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    division?: string | null
  }

  export type JobUpdateWithoutPodInput = {
    jobNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    place?: NullableStringFieldUpdateOperationsInput | string | null
    shipperRef?: NullableStringFieldUpdateOperationsInput | string | null
    gdNo?: NullableStringFieldUpdateOperationsInput | string | null
    gdDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formE?: NullableStringFieldUpdateOperationsInput | string | null
    formEDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commodity?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    containerNo?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    hawbBl?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    salesPerson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUpdateManyWithoutJobNestedInput
    serviceInvoice?: ServiceInvoiceUpdateOneWithoutJobNestedInput
    freightInvoice?: FreightInvoiceUpdateOneWithoutJobNestedInput
    branch?: BranchUpdateOneWithoutJobsNestedInput
    company?: CompanyUpdateOneRequiredWithoutJobsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutJobsNestedInput
  }

  export type JobUncheckedUpdateWithoutPodInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    customerId?: IntFieldUpdateOperationsInput | number
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    place?: NullableStringFieldUpdateOperationsInput | string | null
    shipperRef?: NullableStringFieldUpdateOperationsInput | string | null
    gdNo?: NullableStringFieldUpdateOperationsInput | string | null
    gdDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formE?: NullableStringFieldUpdateOperationsInput | string | null
    formEDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commodity?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    containerNo?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    hawbBl?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    salesPerson?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutJobNestedInput
    serviceInvoice?: ServiceInvoiceUncheckedUpdateOneWithoutJobNestedInput
    freightInvoice?: FreightInvoiceUncheckedUpdateOneWithoutJobNestedInput
  }

  export type JobUncheckedUpdateManyWithoutPodInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jobType?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    customerId?: IntFieldUpdateOperationsInput | number
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    place?: NullableStringFieldUpdateOperationsInput | string | null
    shipperRef?: NullableStringFieldUpdateOperationsInput | string | null
    gdNo?: NullableStringFieldUpdateOperationsInput | string | null
    gdDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formE?: NullableStringFieldUpdateOperationsInput | string | null
    formEDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commodity?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    containerNo?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    hawbBl?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    salesPerson?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    division?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VoucherEntryCreateManyVoucherInput = {
    id?: number
    accountId: number
    debit?: number
    credit?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoucherEntryUpdateWithoutVoucherInput = {
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutVoucherEntriesNestedInput
  }

  export type VoucherEntryUncheckedUpdateWithoutVoucherInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherEntryUncheckedUpdateManyWithoutVoucherInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}